/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/


// From: http://dbaron.org/log/20100309-faster-timeouts

// Only add setZeroTimeout to the window object, and hide everything
// else in a closure.
(function() {
	var timeout = null;
	var messageName = "fi";

	// Like setTimeout, but only takes a function argument.  There's
	// no time argument (always zero) and no arguments (you have to
	// use a closure).
	function setFastTimeout(fn) {
		timeout = fn;
	};
	
	function invokeFastTimeout() {
		window.postMessage(messageName, "*");
	};

	function handleMessage(event) {
		if ( event.data === messageName ) {
			event.stopPropagation();
			timeout();
		}
	}

	window.addEventListener( "message", handleMessage, false, false );

	// Add the one thing we want added to the window object.
	window.setFastTimeout = setFastTimeout;
	window.invokeFastTimeout = invokeFastTimeout;
})();
/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	var globalInstance = null;
	
	var LogWindow = function( mainboard, divElement ) {
	
		globalInstance = this;
		var that = this;
		this._strArray = [];
		this._dataArray = [];
		this._element = document.createElement('textarea');
		this._element.rows = 15;
		this._element.cols = 80;
		divElement.appendChild( this._element );
		this._mainboard = mainboard;

		setInterval( function() { that._onTextRefresh(); }, 1000 );
	};

	
	LogWindow.prototype._onLog = function( log ) {
		//console.log( log );
		//this._addData( log );
	};
		
	
	LogWindow.prototype._addData = function( obj ) {
		this._dataArray.push( obj );
		if ( this._dataArray.length > 80 ) {
			this._dataArray.shift();
		}
	};
	
	
	LogWindow.prototype._onTextRefresh = function( consoleToo ) {
	
		var tot = '';
		for ( var i=0; i<this._dataArray.length; ++i ) {
			var str = this._dataArray[i];
			tot += str + "\r\n";
		}
		this._element.innerHTML = tot;
		if ( consoleToo ) {
			console.log( tot );
		}
	};

	
	Gui.LogWindow = LogWindow;
	
	
	Gui.log = function( module, str ) {
		if ( globalInstance ) {
			globalInstance._onLog( module + " " + str );
		}
	};

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

var Test = {};


(function(){
	"use strict";
	
	var eventArgs = []; // global to prevent memory reallocation
	
	
	var Event = function() {
		
		this._callbacks = [];
	};
	
	
	Event.prototype.connect = function( cb ) {
	
		this._callbacks.push( cb );
	};
	
	
	Event.prototype.invoke = function() {
		eventArgs = Array.prototype.slice.call(arguments, 0);
		for ( var i=0; i<this._callbacks.length; ++i ) {
			this._callbacks[i].apply( this, eventArgs );
		}
	};
	
	
	var EventBus = function() {
	
		this._map = {};
	};
	
	
	EventBus.prototype._get = function( name ) {
		if ( !this._map[ name ] ) {
			this._map[ name ] = new Event();
		}
		return this._map[ name ];
	};
	
	
	EventBus.prototype.connect = function( name, cb ) {
		this._get( name ).connect( cb );
	};
	
	
	EventBus.prototype.invoke = function( name ) {
		
		var event = this._map[ name ];
		if ( event ) {
			if ( arguments.length > 1 ) {
				eventArgs = Array.prototype.slice.call(arguments, 1);
			} else {
				eventArgs.length = 0;
			}
			event.invoke.apply( event, eventArgs );
		}
	};
	

	Nes.Event = Event;
	Nes.EventBus = EventBus;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

(function(){
	"use strict";
	
	var decompressIfNecessary = function( name, binaryString, completeCallback ) {

		if ( name.match( /\.zip$/i ) ) {
			// zip - decompress using jszip lib
			var zip = new JSZip( binaryString );
			var findArray = zip.file( /\.nes$/i );
			if ( findArray.length === 0 ) {
				throw new Error( "Could not find .nes file in zip file " + name );
			}
			completeCallback( null, findArray[0].asUint8Array() );
		} else if ( name.match( /\.7z$/i ) ) {
			// 7z - attempt to use lzma lib if it's compressed using LZMA
			Nes.decompress7z( name, binaryString, completeCallback );
		} else if ( name.match( /\.gz$/i ) ) {
			// gzip - use jsziptools lib
			var result = jz.gz.decompress( binaryString );
			completeCallback( null, result );
		} else if ( name.match( /\.nes$/i ) ) {
			// uncompressed file
			completeCallback( null, binaryString );
		} else {
			throw new Error( "Unsupported file extension for file " + name );
		}
	};
	
		
	var getRomNameFromUrl = function( url ) {
	
		var slashIndex = url.lastIndexOf( '/' );
		if ( slashIndex >= 0 ) {
			return url.slice( slashIndex + 1 );
		}
		return url;
	};
	
	
	var loadRomFromUrl = function( url, callback ) {
		
		// Load using a bog standard XHR request as then we can load as binary
		var that = this;
		var xhr = new XMLHttpRequest();
		xhr.open('GET', url, true);
		xhr.responseType = 'arraybuffer';
		xhr.overrideMimeType("application/octet-stream");
		xhr.onerror = function( err ) {
			callback( err );
		};
		xhr.onload = function(err) {
			if ( xhr.status === 200 ) {
				var binaryString = new Uint8Array( this.response );
				callback( null, getRomNameFromUrl( url ), binaryString );
			} else {
				callback( "Error loading rom file from URL: '" + url + "' HTTP code: " + xhr.status );
			}
		};

		xhr.send();
	};

	
	Nes.decompressIfNecessary = decompressIfNecessary;
	Nes.loadRomFromUrl = loadRomFromUrl;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

(function(){
	"use strict";
	
	var decompress7z = function( name, binaryString, completeCallback ) {

		// If lzma_worker.js is in the same directory, you don't need to set the path.
		var my_lzma = new LZMA( /*"../src/lzma_worker.js"*/ );
		
		my_lzma.decompress( binaryString,
			function( decompressedData ) {
				completeCallback( null, decompressedData );
			},
			function( progressPercent ) {
				if ( progressPercent < 0 ) {
					completeCallback( 'Error decompressing 7z' );
				}
			} );
	};

	
	Nes.decompress7z = decompress7z;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

(function(){
	"use strict";
	
	var uintArrayToString = function( uintArray ) {

		if ( !( uintArray instanceof Int32Array ) ) {
			throw new Error( 'Nes.uintArrayToString: Only accepts Int32Array parameter' );
		}
		var str = '';
		for ( var i=0, strLen = uintArray.length; i<strLen; i++ ) {
			var saveValue = uintArray[i];
			if ( saveValue > 0xFFFF ) {
				throw new Error( "Invalid value attempted to be serialised" );
			}
			str += String.fromCharCode( saveValue );
		}
		return str;
	};

	
	var stringToUintArray = function( str ) {

		var buf = new Int32Array( str.length );
		for ( var i=0, strLen = str.length; i<strLen; i++ ) {
			buf[i] = str.charCodeAt(i) | 0;
		}
		return buf;
	};
	
	
	Nes.uintArrayToString = uintArrayToString;
	Nes.stringToUintArray = stringToUintArray;
	
	
	var blobToString = function( blob ) {
	
		var url = window.webkitURL || window.URL;
		return url.createObjectURL(blob);
	};
	
	
	Nes.blobToString = blobToString;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.WebGl = this.WebGl || {};

(function(){
	"use strict";
	
	var defaultVertexShader =
			"void main(void) {" +
				"gl_Position = aModelViewProjectionMatrix * aVertexPosition;" +
				"vTextureCoord[0] = aTextureCoord;" +
			"}";
	
	var defaultFragmentShader =
			"uniform sampler2D rubyTexture;" +
			"void main(void) {" +
				"gl_FragColor = texture2D(rubyTexture, vec2(vTextureCoord[0].s, vTextureCoord[0].t));" +
			"}";
	
	
	var getGlContext = function( canvas ) {
		return canvas.getContext("webgl") || canvas.getContext("experimental-webgl")
	};
	
	
	// var MultiCallback = function() {
	
		// this._allCallback = null;
		// this._dueCount = 0;
		// this._completeCount = 0;
	// };
	
		
	// MultiCallback.prototype._callbackComplete = function() {
	
		// this._completeCount++;
		// this._checkComplete();
	// };
	
	
	// MultiCallback.prototype._checkComplete = function() {
	
		// if ( this._completeCount === this._dueCount ) {
			// this._allCallback();
		// }
	// };
	
	
	// MultiCallback.prototype.callback = function() {
		
		// this._dueCount++;
		// var that = this;
		// return function() { that._callbackComplete(); }
	// };
	
	
	// MultiCallback.prototype.start = function( allCallback ) {
	
		// this._allCallback = allCallback;
		// this._checkComplete();
	// };
	
	
	
	var VertexBuffer = function( glContext ) {
	
		this._glContext = glContext;
		this._itemSize = 0;
		this._itemCount = 0;
		this._buffer = this._glContext.createBuffer();
	};
	
	VertexBuffer.prototype.setData = function( vertices, itemSize, itemCount ) {
	
		// ELEMENT_ARRAY_BUFFER is used by index buffer, ARRAY_BUFFER by vertex and tex coord buffers
		this._itemSize = itemSize;
		this._itemCount = itemCount;
		this._glContext.bindBuffer( this._glContext.ARRAY_BUFFER, this._buffer );
		this._glContext.bufferData( this._glContext.ARRAY_BUFFER, vertices, this._glContext.STATIC_DRAW );
	};
	
	
	VertexBuffer.prototype.bind = function( positionAttribute ) {
		this._glContext.bindBuffer( this._glContext.ARRAY_BUFFER, this._buffer );
		this._glContext.vertexAttribPointer( positionAttribute, this._itemSize, this._glContext.FLOAT, false, 0, 0 );
	};
	
	
	
	var IndexBuffer = function( glContext ) {
	
		this._glContext = glContext;
		this._itemCount = 0;
		this._buffer = this._glContext.createBuffer();
	};
	
	IndexBuffer.prototype.setData = function( indices, itemCount ) {
		this._itemCount = itemCount;
		this._glContext.bindBuffer( this._glContext.ELEMENT_ARRAY_BUFFER, this._buffer );
		this._glContext.bufferData( this._glContext.ELEMENT_ARRAY_BUFFER, indices, this._glContext.STATIC_DRAW );
	};
	
	IndexBuffer.prototype.bind = function() {
		this._glContext.bindBuffer(this._glContext.ELEMENT_ARRAY_BUFFER, this._buffer);
	};
	
	IndexBuffer.prototype.draw = function() {
		this._glContext.drawElements(this._glContext.TRIANGLES, this._itemCount, this._glContext.UNSIGNED_SHORT, 0);
	};
	
	
	var ShaderProgram = function( glContext ) {
	
		this._fragment = null;
		this._vertex = null;
		
		this._glContext = glContext;
		// add some extensions - this enables fwidth() method, see https://www.khronos.org/registry/gles/extensions/OES/OES_standard_derivatives.txt
		this._glContext.getExtension('OES_standard_derivatives');
		
		this._uniformLocationCache = {};
		this._attribCache = {};
		this._shaderProgram = this._glContext.createProgram();
	};
	

	ShaderProgram.prototype._compileShader = function( glType, str ) {
	
		var shader = this._glContext.createShader( glType );
		
		var prepend = '';
		
		if ( str.indexOf( '#version' ) === 0 ) {
			var versionString = str.substr( 0, str.indexOf( '\n' ) );
			str = str.substring( versionString.length );
			prepend += versionString;
		}
		
		prepend += 'precision mediump float;\n'; // Bodge precision on script
		prepend += '#extension GL_OES_standard_derivatives : enable\n';
		
		if ( glType === this._glContext.VERTEX_SHADER ) {
			// Add variables common to all vertex shaders
			prepend += 'uniform mat4 aModelViewProjectionMatrix;\n';
			prepend += 'attribute vec4 aVertexPosition;\n';
			prepend += 'attribute vec4 aTextureCoord;\n';
		}
		
		prepend += 'varying vec4 vTextureCoord[8];\n';

		str = prepend + str;
		
		this._glContext.shaderSource(shader, str);
		this._glContext.compileShader(shader);

		if (!this._glContext.getShaderParameter(shader, this._glContext.COMPILE_STATUS)) {
			throw new Error( "Error compiling shader script " + this._glContext.getShaderInfoLog(shader) );
		}
		
		return shader;
	};
	
	
	ShaderProgram.prototype._shaderLoadSuccess = function( xmlRaw, callback ) {
	
		var fragmentStr, vertexStr;
		var fragmentXml, vertexXml;
		
		if ( xmlRaw ) {
			var xmlDoc = $( xmlRaw );
			fragmentXml = xmlDoc.find( 'fragment' )[0];
			vertexXml = xmlDoc.find( 'vertex' )[0];
		}

		if ( fragmentXml && fragmentXml.textContent ) {
			fragmentStr = fragmentXml.textContent;
		} else {
			fragmentStr = defaultFragmentShader;
		}
		if ( vertexXml && vertexXml.textContent ) {
			vertexStr = vertexXml.textContent;
		} else {
			vertexStr = defaultVertexShader;
		}

		if ( this._fragment ) {
			this._glContext.detachShader(this._shaderProgram, this._fragment);
		}
		if ( this._vertex ) {
			this._glContext.detachShader(this._shaderProgram, this._vertex);
		}
		
		this._fragment = this._compileShader( this._glContext.FRAGMENT_SHADER, fragmentStr );
		this._vertex = this._compileShader( this._glContext.VERTEX_SHADER, vertexStr );
		
		this._glContext.attachShader(this._shaderProgram, this._fragment);
		this._glContext.attachShader(this._shaderProgram, this._vertex);
		
		this._glContext.linkProgram( this._shaderProgram );

		if (!this._glContext.getProgramParameter( this._shaderProgram, this._glContext.LINK_STATUS )) {
			throw new Error( this._glContext.getProgramInfoLog( this._shaderProgram ) );
		}
		
		callback( null );
	};
	
	
	ShaderProgram.prototype.loadAndLink = function( shaderFile, callback ) {
	
		this._uniformLocationCache = {};
		this._attribCache = {};
		
		if ( shaderFile && shaderFile.length > 0 ) {
			var that = this;
			$['ajax']({
				'url': 'shaders/' + shaderFile,
				'success': function( xmlDoc ) { that._shaderLoadSuccess( xmlDoc, callback ); },
				'dataType': 'xml'
			});
		} else {
			this._shaderLoadSuccess( null, callback );
		}
	};
	
	
	ShaderProgram.prototype.use = function() {
	
		this._glContext.useProgram(this._shaderProgram);
	};
	
	
	ShaderProgram.prototype.getUniformLocation = function( name ) {
	
		if ( !this._uniformLocationCache.hasOwnProperty( name ) ) {
			 this._uniformLocationCache[ name ] = this._glContext.getUniformLocation(this._shaderProgram, name);
		}
		return this._uniformLocationCache[ name ];
	};
		
	
	ShaderProgram.prototype.getAttrib = function( name ) {
	
		if ( !this._attribCache.hasOwnProperty( name ) ) {
			this._attribCache[ name ] = this._glContext.getAttribLocation(this._shaderProgram, name);
			this._glContext.enableVertexAttribArray( this._attribCache[ name ] );
		}
		return this._attribCache[ name ];
	};
	
	
	var FillableTexture = function( glContext, width, height ) {
	
		this._glContext = glContext;
		this._texture = this._glContext.createTexture();
		this._glContext.bindTexture(this._glContext.TEXTURE_2D, this._texture);
		this._glContext.pixelStorei(this._glContext.UNPACK_FLIP_Y_WEBGL, true);
		this._glContext.texImage2D(this._glContext.TEXTURE_2D, 0, this._glContext.RGBA, width, height, 0, this._glContext.RGBA, this._glContext.UNSIGNED_BYTE, null );
	};
	
	FillableTexture.prototype.bind = function() {
	
		this._glContext.activeTexture(this._glContext.TEXTURE0);
		this._glContext.bindTexture( this._glContext.TEXTURE_2D, this._texture );

		var filtering = this._glContext.LINEAR; // NEAREST for block quality, LINEAR for softer texture
  
		this._glContext.texParameteri(this._glContext.TEXTURE_2D, this._glContext.TEXTURE_MAG_FILTER, filtering);
		this._glContext.texParameteri(this._glContext.TEXTURE_2D, this._glContext.TEXTURE_MIN_FILTER, filtering);
		this._glContext.texParameteri(this._glContext.TEXTURE_2D, this._glContext.TEXTURE_WRAP_S, this._glContext.CLAMP_TO_EDGE);
		this._glContext.texParameteri(this._glContext.TEXTURE_2D, this._glContext.TEXTURE_WRAP_T, this._glContext.CLAMP_TO_EDGE);
	};
	
	FillableTexture.prototype.fill = function( x, y, width, height, array ) {
	
		this._glContext.texSubImage2D( this._glContext.TEXTURE_2D, 0, x, y, width, height, this._glContext.RGBA, this._glContext.UNSIGNED_BYTE, array );
	};
	
	
	
	var OrthoCamera = function( glContext ) {
	
		this._glContext = glContext;
		this._mvMatrix = mat4.create();
		this._pMatrix = mat4.create();
	};
	
	OrthoCamera.prototype.setup = function( width, height ) {

		mat4.ortho(this._pMatrix, 0, width, 0, height, 0.1, 100);
		mat4.identity(this._mvMatrix);
		mat4.translate(this._mvMatrix, this._mvMatrix, [0.0, 0.0, -0.1]);
	};
	
	OrthoCamera.prototype.getMVPMatrix = function() {
		var combined = mat4.create();
		mat4.multiply( combined, this._pMatrix, this._mvMatrix );
		return combined;
	};
	
	
	WebGl.OrthoCamera = OrthoCamera;
	WebGl.FillableTexture = FillableTexture;
	WebGl.ShaderProgram = ShaderProgram;
	WebGl.VertexBuffer = VertexBuffer;
	WebGl.IndexBuffer = IndexBuffer;
	
	
	WebGl.webGlSupported = function() {
		try {
			var canvas = document.createElement('canvas');
			var ctx = getGlContext( canvas );
			return ctx !== null;
		}
		catch (e) {
			return false;
		}
	};
	
	WebGl.getGlContext = getGlContext;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
		
	var CanvasRenderSurface = function( canvasParent ) {
	
		this._clearArray = new Uint32Array( SCREEN_WIDTH * SCREEN_HEIGHT );
		this._clearArrayColour = this._clearArray[0];

		this._bufferIndexArray = new Int32Array( SCREEN_WIDTH * SCREEN_HEIGHT );
	
		this._offscreenElement = document.createElement('canvas');
		this._offscreenElement.width = SCREEN_WIDTH;
		this._offscreenElement.height = SCREEN_HEIGHT;
		this._offscreenCanvas = this._offscreenElement.getContext( "2d" );
		//this._offscreenCanvas.imageSmoothingEnabled = false;
		this._offscreenData = this._offscreenCanvas.getImageData( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT );
		
		if ( !this._offscreenData.data.buffer ) {
			throw new Error( "Browser does not support canvas image buffers. Cannot run emulator" );
		}
		// Chrome & Firefox support passing the underlying image data buffer to Uint32Array(). IE does not.
		this._offscreen32BitView = new Uint32Array( this._offscreenData.data.buffer );
		if ( this._offscreen32BitView.length !== this._clearArray.length ) {
			throw new Error( "Unexpected canvas buffer size (actual=" + this._offscreen32BitView.length + ")" );
		}

		this._element = canvasParent.getCanvasElement();
		this._canvas = this._element.getContext("2d");
		//this._canvas.imageSmoothingEnabled = false;
	};
	
	
	CanvasRenderSurface.prototype.writeToBuffer = function( bufferIndex, insertIndex, colour ) {

		//if ( baseIndex < 0 || baseIndex >= this._offscreen32BitView.length ) { throw new Error( "CanvasRenderSurface.prototype.writeToBuffer: Invalid bounds" ); }
		var existingIndex =  this._bufferIndexArray[ insertIndex ];
		if ( existingIndex <= bufferIndex ) {
			 this._offscreen32BitView[ insertIndex] =  0xFF000000 | colour ;
			 this._bufferIndexArray[ insertIndex] =  bufferIndex ;
		}
	};
	
	
	CanvasRenderSurface.prototype.getRenderBufferHash = function() {
	
		var rusha = new Rusha();
		return rusha.digestFromArrayBuffer( this._offscreen32BitView ).toUpperCase();
	};
	
	
	CanvasRenderSurface.prototype.clearBuffers = function( backgroundColour ) {
	
		var i=0;
		// update clear array if background colour changes
		if ( backgroundColour !== this._clearArrayColour ) {
			for ( i=0; i<this._clearArray.length; ++i ) {
				this._clearArray[ i ] = 0xFF000000 | backgroundColour;
			}
			this._clearArrayColour = backgroundColour;
		}
		
		// set background colour
		this._offscreen32BitView.set( this._clearArray );
		
		// Nes.ClearScreenArray is a quicker way of clearing this array
		this._bufferIndexArray.set( g_ClearScreenArray );
		
		// for ( var i=0; i<this._bufferIndexArray.length; ++i ) {
			// this._bufferIndexArray[i] = 0;
			// this._offscreen32BitView[i] = backgroundColour;
		// }
	};
	
	
	CanvasRenderSurface.prototype.render = function( mainboard ) {

		this._offscreenCanvas.putImageData( this._offscreenData, 0, 0 );
		// Draw offscreen canvas onto front buffer, resizing it in the process
		this._canvas.drawImage( this._offscreenElement, 0, 0, this._element.clientWidth, this._element.clientHeight );
	};
		
	
	CanvasRenderSurface.prototype.screenshotToFile = function() {

		this._offscreenElement.toBlob( function( blob ) {
			saveAs( blob, "screenshot.png" );
		});
	};
	
	
	CanvasRenderSurface.prototype.screenshotToString = function() {

		return this._offscreenElement.toDataURL("image/png");
	};
	
	
	Gui.CanvasRenderSurface = CanvasRenderSurface;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};
this.WebGl = this.WebGl || {};

(function(){
	"use strict";
	
	// Must be power of 2
	var TEXTURE_WIDTH = 256;
	var TEXTURE_HEIGHT = 256;
	
	
	var WebGlRenderSurface = function( canvasParent ) {
	
		var that = this;
		this._ready = false;

		this._clearArray = new Uint32Array( SCREEN_WIDTH * SCREEN_HEIGHT );
		this._clearArrayColour = this._clearArray[0];

		this._bufferIndexArray = new Int32Array( SCREEN_WIDTH * SCREEN_HEIGHT );
		this._offscreen32BitView = new Uint32Array( TEXTURE_WIDTH * TEXTURE_HEIGHT );
		this._offscreen8BitView = new Uint8Array( this._offscreen32BitView.buffer );

		this._element = canvasParent.getCanvasElement();
		this._glContext = WebGl.getGlContext( this._element );

		this._camera = new WebGl.OrthoCamera( this._glContext );
		this._camera.setup( SCREEN_WIDTH, SCREEN_HEIGHT );

		this._initBuffers();
			
		this._texture = new WebGl.FillableTexture( this._glContext, TEXTURE_WIDTH, TEXTURE_HEIGHT );
			
		canvasParent.connect( 'resize', function() { that._onResize(); } );

		this._inputSizeShaderArray = new Float32Array( [ SCREEN_WIDTH, SCREEN_HEIGHT ] );
		this._outputSizeShaderArray = new Float32Array( [ SCREEN_WIDTH, SCREEN_HEIGHT ] );
		this._textureSizeShaderArray = new Float32Array( [ TEXTURE_WIDTH, TEXTURE_HEIGHT ] );
		
		this._shader = new WebGl.ShaderProgram( this._glContext );
		
		this.loadShader( null, function() {
			that._ready = true;
		} );
	};
	
	
	WebGlRenderSurface.prototype.loadShader = function( shaderFilename, callback ) {
	
		var that = this;
		this._shader.loadAndLink( shaderFilename, function() {
			that._shader.use();

			that._glContext.uniform2fv(that._shader.getUniformLocation("rubyInputSize"), that._inputSizeShaderArray );
			that._glContext.uniform2fv(that._shader.getUniformLocation("rubyOutputSize"), that._outputSizeShaderArray );
			that._glContext.uniform2fv(that._shader.getUniformLocation("rubyTextureSize"), that._textureSizeShaderArray );

			that._glContext.uniformMatrix4fv( that._shader.getUniformLocation("aModelViewProjectionMatrix"), false, that._camera.getMVPMatrix() );

			that._vertexBuffer.bind( that._shader.getAttrib( "aVertexPosition" ) );
			that._textureCoordBuffer.bind( that._shader.getAttrib( "aTextureCoord" ) );
			that._indexBuffer.bind();
			that._texture.bind();

			that._glContext.uniform1i(that._shader.getUniformLocation("rubyTexture"), 0); //Texture unit 0 is for base images.
			
			callback();
		}  );
	};

	
	WebGlRenderSurface.prototype._initBuffers = function() {
		var t = SCREEN_WIDTH / TEXTURE_WIDTH;
		var u = SCREEN_HEIGHT / TEXTURE_HEIGHT;
		
		var vertices = new Float32Array( [
				0, 0,							0.0, 1.0,
				SCREEN_WIDTH,	0,				0.0, 1.0,
				SCREEN_WIDTH,	SCREEN_HEIGHT,	0.0, 1.0,
				0,				SCREEN_HEIGHT,	0.0, 1.0
			] );
		var texCoords = new Float32Array( [
				0.0,	0.0,
				t,		0.0,
				t,		u,
				0.0,	u
			] );
		var indices = new Uint16Array( [ 0, 1, 2,	0, 2, 3 ] );
	
		this._vertexBuffer = new WebGl.VertexBuffer( this._glContext );
		this._vertexBuffer.setData( vertices, 4, 4 );

		this._textureCoordBuffer = new WebGl.VertexBuffer( this._glContext );
		this._textureCoordBuffer.setData( texCoords, 2, 4 );

		this._indexBuffer = new WebGl.IndexBuffer( this._glContext );
		this._indexBuffer.setData( indices, 6 );
	};
	

	WebGlRenderSurface.prototype._onResize = function() {
		this._glContext.viewport(0, 0, this._element.width, this._element.height);
		this._glContext.clearColor(0.0, 0.0, 0.0, 1.0);
	};
	
	
	WebGlRenderSurface.prototype.writeToBuffer = function( bufferIndex, insertIndex, colour ) {

		//if ( baseIndex < 0 || baseIndex >= this._offscreen32BitView.length ) { throw new Error( "WebGlRenderSurface.prototype.writeToBuffer: Invalid bounds" ); }
		var existingIndex =  this._bufferIndexArray[ insertIndex ];
		if ( existingIndex <= bufferIndex ) {
			 this._offscreen32BitView[ insertIndex] =  0xFF000000 | colour ;
			 this._bufferIndexArray[ insertIndex] =  bufferIndex ;
		}
	};
	
	
	WebGlRenderSurface.prototype.getRenderBufferHash = function() {
	
		var rusha = new Rusha();
		return rusha.digestFromArrayBuffer( this._offscreen32BitView ).toUpperCase();
	};
	
	
	WebGlRenderSurface.prototype.clearBuffers = function( backgroundColour ) {
	
		// update clear array if background colour changes
		if ( backgroundColour !== this._clearArrayColour ) {
			for ( var i=0; i<this._clearArray.length; ++i ) {
				this._clearArray[ i ] = 0xFF000000 | backgroundColour;
			}
			this._clearArrayColour = backgroundColour;
		}
		
		// set background colour
		this._offscreen32BitView.set( this._clearArray );
		
		// Nes.ClearScreenArray is a quicker way of clearing this array
		this._bufferIndexArray.set( g_ClearScreenArray );
	};
	
	
	WebGlRenderSurface.prototype.render = function( mainboard ) {

		if ( !this._ready ) {
			return;
		}
		this._glContext.clear(this._glContext.COLOR_BUFFER_BIT);
		this._texture.fill( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, this._offscreen8BitView );
		this._glContext.uniform1i(this._shader.getUniformLocation("rubyFrameCount"), mainboard.ppu.frameCounter );
		this._indexBuffer.draw();
	};
	
	
	WebGlRenderSurface.prototype._createCanvasWithScreenshotOn = function() {
	
		// create copy of offscreen buffer into a new canvas element
		var element = document.createElement('canvas');
		element.width = SCREEN_WIDTH;
		element.height = SCREEN_HEIGHT;
		var canvas = element.getContext( "2d" );
		var imgData = canvas.getImageData( 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT );
		imgData.data.set( this._offscreen8BitView.subarray( 0, SCREEN_WIDTH * SCREEN_HEIGHT * 4 ) );
		canvas.putImageData( imgData, 0, 0 );
		return element;
	};
		
	
	WebGlRenderSurface.prototype.screenshotToFile = function() {
	
		var element = this._createCanvasWithScreenshotOn();
		element.toBlob( function( blob ) {
			saveAs( blob, "screenshot.png" );
		});
	};
	
	
	WebGlRenderSurface.prototype.screenshotToString = function() {
		
		var element = this._createCanvasWithScreenshotOn();
		return element.toDataURL("image/png");
	};
	
	
	WebGlRenderSurface.prototype.loadShaderFromUrl = function( url ) {
	
		this.loadShader( url, function() {} );
	};

	
	Gui.WebGlRenderSurface = WebGlRenderSurface;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	
	
	var hookDragDropEvents = function( fileDropCallback ) {

		if (typeof window.FileReader !== 'function') {
			//alert("The file API isn't supported on this browser yet.");
			return;
		}

		function handleFileSelect(evt) {
			evt.stopPropagation();
			evt.preventDefault();
			var files = evt.dataTransfer.files; // FileList object.

			if ( files.length > 0 )
			{
				var fr = new FileReader();
				fr.onload = function() {
					if ( fileDropCallback ) {
						fileDropCallback( files[0].name, new Uint8Array( fr.result ) );
					}
				};
				fr.readAsArrayBuffer( files[0] );
			}
		}

		function handleDragOver(evt) {
			evt.stopPropagation();
			evt.preventDefault();
			evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
		}

		// Setup the dnd listeners.
		var dropZone = document.getElementById('body');
		dropZone.addEventListener('dragover', handleDragOver, false);
		dropZone.addEventListener('drop', handleFileSelect, false);
	};
	
	Gui.hookDragDropEvents = hookDragDropEvents;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/


this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	var gamepad_consts = {
		top1:	0, // Top button 1 ("A" on the Xbox 360 controller; cross on the PS3 controller)
		top2:	1, // Top button 2 ("B" on the Xbox 360 controller; circle on the PS3 controller)
		bottom3: 2, // gp_face3	Top button 3 ("X" on the Xbox 360 controller; square on the PS3 controller)
		bottom4: 3, // gp_face4	Top button 4 ("Y" on the Xbox 360 controller; triangle on the PS3 controller)
		shoulderLeft:	4, // gp_shoulderlb	Left shoulder button (digital)
		shoulderRight: 5, // gp_shoulderrb	Right shoulder button (digital)
		shoulderLeftTrigger:	6, // gp_shoulderl	Left shoulder trigger (analogue)
		shoulderRightTrigger:	7, // gp_shoulderr	Right shoulder trigger (analogue)
		select: 8, // gp_select	The select button on PlayStation 3 and the back button on Xbox 360
		start: 9, // gp_start	The start button
		leftStickButton: 10, // gp_stickl	The left stick pressed (as a button)
		rightStickButton: 11, // gp_stickr	The right stick pressed (as a button)
		dpadUp: 12, // gp_padu	D-pad up (digital)
		dpadDown:	13, // gp_padd	D-pad down (digital)
		dpadLeft:	14, // gp_padl	D-pad left (digital)
		dpadRight: 15, // gp_padr	D-pad right (digital)
		leftStickHoriz: 0, // gp_axislh	Left stick horizontal axis (analogue)
		leftStickVert: 1, // gp_axislv	Left stick vertical axis (analogue)
		rightStickHoriz: 2, // gp_axisrh	Right stick horizontal axis (analogue)
		rightStickVert: 3 // gp_axisrv	Right stick vertical axis (analogue)
	};
	
	
	
	var GamePad = function( rawPad ) {
		
		this._axisThreshold = 0.5;
		this._buttonStates = new Int32Array( rawPad['buttons'].length );
		this._axesStates = new Int32Array( rawPad['axes'].length );
	};
	
	
	GamePad.prototype.getButtonCount = function() {
		return this._buttonStates.length;
	};
	
	
	// Returns 0 for not changed, 1 for pressed, 2 for not pressed
	GamePad.prototype.getButtonState = function( rawPad, buttonIndex ) {
		
		var isPressed = rawPad['buttons'][ buttonIndex ]['pressed'];
		var intState = ( isPressed ? 1 : 0 );
		if ( this._buttonStates[ buttonIndex ] !== intState ) {
			this._buttonStates[ buttonIndex ] = intState;
			return isPressed ? 1 : 2;
		}
		return 0;
	};
	
	
	GamePad.prototype.getAxisCount = function() {
		return this._axesStates.length;
	};
	
	
	// Returns 0 for not changed, 1 for pressed, 2 for not pressed
	GamePad.prototype.getAxisState = function( rawPad, axisIndex ) {
		
		var isPressed = rawPad['axes'][ axisIndex ] >= this._axisThreshold || rawPad['axes'][ axisIndex ] <= -this._axisThreshold;
		var intState = ( isPressed ? 1 : 0 );
		if ( this._axesStates[ axisIndex ] !== intState ) {
			this._axesStates[ axisIndex ] = intState;
			return isPressed ? 1 : 2;
		}
		return 0;
	};	
	
	
	///////////////////////////////////////////////////////////////////////////////////////////////
	
	
	var Input = function( mainboard ) {
	
		this._mainboard = mainboard;
		this._pads = [];
		
		this._loadKeyBindingsFromLocalStorage();

		// these values are guessed - need testing
		this._gamepadButtonMap = {
			'UP': [ gamepad_consts.dpadUp ],
			'DOWN': [ gamepad_consts.dpadDown ],
			'LEFT': [ gamepad_consts.dpadLeft ],
			'RIGHT': [ gamepad_consts.dpadRight ],
			'A': [ gamepad_consts.top1, gamepad_consts.top2, gamepad_consts.shoulderLeft ],
			'B': [ gamepad_consts.bottom3, gamepad_consts.bottom4, gamepad_consts.shoulderRight ],
			'SELECT': [ gamepad_consts.select ],
			'START': [ gamepad_consts.start ]
		};
		
		this._gamepadAxisMap = {
			'UP': [ { axis: gamepad_consts.leftStickVert, type: 'positive' }, { axis: gamepad_consts.rightStickVert, type: 'positive' } ],
			'DOWN': [ { axis: gamepad_consts.leftStickVert, type: 'negative' }, { axis: gamepad_consts.rightStickVert, type: 'negative' } ],
			'LEFT': [ { axis: gamepad_consts.leftStickHoriz, type: 'negative' }, { axis: gamepad_consts.rightStickHoriz, type: 'negative' } ],
			'RIGHT': [ { axis: gamepad_consts.leftStickHoriz, type: 'positive' }, { axis: gamepad_consts.rightStickHoriz, type: 'positive' } ],
			'A': [ { axis: gamepad_consts.shoulderLeftTrigger, type: 'positive' } ],
			'B': [ { axis: gamepad_consts.shoulderRightTrigger, type: 'positive' } ]
		};
		
		var that = this;
		
		// keyboard support
		window.addEventListener( 'keydown', function( event ) { if ( that._doKeyboardButtonPress( Number( event.keyCode ), true ) ) { event.preventDefault(); } }, false );
		window.addEventListener( 'keyup', function( event ) { if ( that._doKeyboardButtonPress( Number( event.keyCode ), false ) ) { event.preventDefault(); } }, false );
		
		this._gamepadsSupported = navigator['getGamepads'] !== undefined;
		
		if ( this._gamepadsSupported ) {
			this._populateGamepads();
			
			$( window ).on( "gamepadconnected", function() { that._populateGamepads(); } );
			$( window ).on( "gamepaddisconnected", function() { that._populateGamepads(); } );
		}
	};
	
	
	Input.prototype._populateGamepads = function() {
	
		this._pads.length = 0;
		if ( this._gamepadsSupported ) {
			var gamepads = navigator['getGamepads']();
			for (var i = 0; i < gamepads.length; ++i) {
				if ( gamepads[i] ) {
					var pad = gamepads[i];
					this._pads.push( new GamePad( pad ) );
				}
			}
		}
	};
	
	
	Input.prototype.poll = function() {
	
		if ( this._gamepadsSupported ) {
			this._pollGamepads();
		}
	};
	
	
	Input.prototype._pollGamepads = function() {
	
		var pads = navigator['getGamepads']();
		for ( var i=0; i<this._pads.length; ++i ) {
			var pad = this._pads[i];
			
			// do buttons
			for ( var buttonIndex=0; buttonIndex<pad.getButtonCount(); ++buttonIndex ) {
				var buttonState = pad.getButtonState( pads[ i ], buttonIndex );
				if ( buttonState > 0 ) {
					//console.log( "Pressed button " + buttonIndex );
					this._doGamepadButton( i, buttonIndex, buttonState === 1 );
				}
			}
			
			// do axes
			for ( var axisIndex=0; axisIndex<pad.getAxisCount(); ++axisIndex ) {
				var axisState = pad.getAxisState( pads[ i ], axisIndex );
				if ( axisState > 0 ) {
//					this._doGamepadAxis( i, axisIndex, axisState === 1, pads[ i ].axes[ axisIndex ] > 0 ? 'positive' : 'negative' );
				}
			}
		}
	};
	
	
	Input.prototype._doGamepadAxis = function( gamepadIndex, axisIndex, isPressed, axisType ) {
	
		var joypad = this._mainboard.inputdevicebus.getJoypad( gamepadIndex );

		if ( joypad ) {
			for ( var buttonName in this._gamepadButtonMap ) {
				if ( this._gamepadButtonMap.hasOwnProperty( buttonName ) ) {

					var buttonArray = this._gamepadButtonMap[ buttonName ];
					for ( var i=0; i<buttonArray.length; ++i ) {
						
						var but = buttonArray[ i ];
						if ( but.axis === axisIndex && but.type === axisType ) {
							joypad.pressButton( Number( JOYPAD_NAME_TO_ID( buttonName ) ), isPressed );
						}
					}
				}
			}
		}
	};
	
	
	Input.prototype._doGamepadButton = function( gamepadIndex, buttonIndex, isPressed ) {
	
		var joypad = this._mainboard.inputdevicebus.getJoypad( gamepadIndex );

		if ( joypad ) {
			for ( var buttonName in this._gamepadButtonMap ) {
				if ( this._gamepadButtonMap.hasOwnProperty( buttonName ) ) {
					var buttonArray = this._gamepadButtonMap[ buttonName ];
					for ( var i=0; i<buttonArray.length; ++i ) {
						if ( buttonIndex === buttonArray[ i ] ) {
							joypad.pressButton( Number( JOYPAD_NAME_TO_ID( buttonName ) ), isPressed );
						}
					}
				}
			}
		}
	};
	
	
	Input.prototype._doKeyboardButtonPress = function( keyCode, pressed ) {
	
		var len = Math.min( 2, this._playerKeyboardMaps.length );
		var wasPressed = false;
		
		for ( var playerIndex = 0; playerIndex < len; ++playerIndex ) {
		
			var joypad = this._mainboard.inputdevicebus.getJoypad( playerIndex );
			var map = this._playerKeyboardMaps[ playerIndex ];
			
			if ( map && joypad ) {
				for ( var buttonIndex=0; buttonIndex<map.length; ++buttonIndex ) {	
					var buttonArray = map[ buttonIndex ];
					for ( var i=0; i<buttonArray.length; ++i ) {
						if ( buttonArray[ i ] === keyCode ) {
							joypad.pressButton( buttonIndex, pressed );
							wasPressed = true;
						}
					}
				}
			}
		}
		return wasPressed;
	};
	
	
	Input.prototype.saveKeyBindings = function( playerId, key, keysAssigned ) {
		
		this._playerKeyboardMaps[ playerId ][ key ] = keysAssigned.slice( 0 );
		this._saveKeyBindingsToLocalStorage();
	};
		
		
	Input.prototype.getKeyBindings = function( playerId, key ) {
		
		return this._playerKeyboardMaps[ playerId ][ key ].slice( 0 );
	};
	
	
	Input.prototype._loadKeyBindingsFromLocalStorage = function() {
		this._playerKeyboardMaps = Gui.loadFromLocalStorage( "webnes_keybindings" );
				
		// Load defaults if no local storage found
		if ( !this._playerKeyboardMaps ) {
			this._playerKeyboardMaps = [
				[
					// defaults for player 1
					[ 90 ], // Z // var JOYPAD_A = 0;
					[ 88 ], // X // var JOYPAD_B = 1;
					[ 16, 160, 161, 67 ], // shift, left shift, right shift, C // var JOYPAD_SELECT = 2;
					[ 13, 32, 86 ], // enter, space, V // var JOYPAD_START = 3;
					[ 38, 87, 104 ], // up, W, numpad 8 // var JOYPAD_UP = 4;
					[ 40, 83, 101, 98 ], // down, S, numpad 5, numpad 2 // var JOYPAD_DOWN = 5;
					[ 37, 65, 100 ], // left, A, numpad 4 // var JOYPAD_LEFT = 6;
					[ 39, 68, 102 ] // right, D, numpad 6 // var JOYPAD_RIGHT = 7;
				],
				[
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				],
				[
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				],
				[
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				]
			];
		}
	};
	
	
	Input.prototype._saveKeyBindingsToLocalStorage = function() {
		Gui.saveToLocalStorage( "webnes_keybindings", this._playerKeyboardMaps );
	};
	

	Gui.Input = Input;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	var compress = function( rawString ) {
	
		var compressed;
		// LZString is way too slow and gives pretty much the same result, use jz.algos instead
		//compressed = LZString.compress( raw );
		var int32Array = Nes.stringToUintArray( rawString );
		compressed = Nes.uintArrayToString( new Int32Array( jz.algos.deflate( new Uint8Array( int32Array ) ) ) );
		return compressed;
	};
	
	
	var decompress = function( rawString ) {
		var decompressed;
		//decompressed = LZString.decompress( compressed );
		var int32Array = Nes.stringToUintArray( rawString );
		decompressed = Nes.uintArrayToString( new Int32Array( jz.algos.inflate( new Uint8Array( int32Array ) ) ) );
		return decompressed;
	};
	
	
	var getCartName = function( slotName, cartName ) {
		return slotName + ":" + cartName;
	};
	
	
	var getMetaName = function( cartName ) {
		return "meta:" + cartName;
	};
	
	
	var getMetaObject = function( cartName ) {
		var obj = loadFromLocalStorage( getMetaName( cartName ) );
		if ( !obj ) {
			obj = { slots: {} };
		}
		return obj;
	};
	
	
	var setMetaObject = function( cartName, obj ) {
		saveToLocalStorage( getMetaName( cartName ), obj );
	};
	
	
	var saveState = function( slotName, cartName, data, screenData ) {
		
		if ( localStorage ) {
			// save state data as it's own local storage object
			saveToLocalStorage( getCartName( slotName, cartName ), data );

			// add to meta data object
			var meta = getMetaObject( cartName );
			var slotMeta = {};
			if ( screenData ) {
				slotMeta.screen = compress( screenData );
				console.log( "Saved screenshot size: " + slotMeta.screen.length + " (uncompressed: " + screenData.length + ")" );
			}
			slotMeta.date = Date.now();
			meta.slots[ slotName ] = slotMeta;
			setMetaObject( cartName, meta );
		}
	};
	
	
	var loadState = function( slotName, cartName ) {
	
		if ( localStorage ) {
			var compressed = localStorage.getItem( getCartName( slotName, cartName ) );
			if ( compressed ) {
				var compressedLength = compressed.length;
				var decompressed = decompress( compressed );
				var obj = JSON.parse( decompressed );
				console.log( "Loaded data size: " + compressedLength + " (uncompressed: " + decompressed.length + ")" );
				return obj;
			}
		} else {
			//( 'Browser does not support local storage' );
		}
		return null;
	};
	
	
	var getStateMetaData = function( cartName, decompressScreenData ) {
		var meta = getMetaObject( cartName );
		// decompress all image data before passing it back
		if ( decompressScreenData ) {
			var keyNames = Object.keys( meta.slots );
			for ( var keyIndex=0; keyIndex<keyNames.length; ++keyIndex ) {
				var slotName = keyNames[ keyIndex ];
				var slot = meta.slots[ slotName ];
				if ( slot.screen ) {
					slot.screen = decompress( slot.screen );
				}
			}
		}
		return meta;
	};
	
	
	var renameState = function( meta, slotName, newSlotName, cartName ) {
		
		// rename data object
		var itemName = getCartName( slotName, cartName );
		var data = localStorage.getItem( itemName );
		if ( data ) {
			localStorage.removeItem( itemName );
			
			if ( newSlotName ) {
				var newItemName = getCartName( newSlotName, cartName );
				localStorage.setItem( newItemName, data );
			}
		
			// rename it in meta object
			if ( newSlotName ) {
				meta.slots[ newSlotName ] = meta.slots[ slotName ];
			}
			delete meta.slots[ slotName ];
		}
	};
	
	
	var renameQuickSaveStates = function( slotName, cartName, limitCount ) {

		var meta = getMetaObject( cartName );
		
		// remove last quicksave.
		renameState( meta, slotName + ZERO_PAD( limitCount-1, 2, 0 ), null, cartName );
		
		// rename any others, moving each one down. We go backwards so we don't overwrite 
		for ( var i=limitCount-2; i>0; --i ) {
			renameState( meta, slotName + ZERO_PAD( i, 2, 0 ), slotName + ZERO_PAD( i+1, 2, 0 ), cartName );
		}
		
		// rename main 'quicksave' slot
		renameState( meta, slotName, slotName + ZERO_PAD( 1, 2, 0 ), cartName );
		
		setMetaObject( cartName, meta );
	};
	
	
	var saveStateSupported = function() {
	
		return !!localStorage;
	};
		
	
	var saveToLocalStorage = function( name, data ) {
		if ( localStorage ) {
			var raw = JSON.stringify( data );
			var compressed = compress( raw );
			localStorage.setItem( name, compressed );
		}
	};
	
	
	var loadFromLocalStorage = function( name ) {
		if ( localStorage ) {
			var compressed = localStorage.getItem( name );
			if ( compressed ) {
				var compressedLength = compressed.length;
				var decompressed = decompress( compressed );
				var obj = JSON.parse( decompressed );
				return obj;
			}
		}
		return null;
	};
	
	
	Gui.saveState = saveState;
	Gui.loadState = loadState;
	Gui.getStateMetaData = getStateMetaData;
	Gui.renameQuickSaveStates = renameQuickSaveStates;
	Gui.saveStateSupported = saveStateSupported;
	Gui.saveToLocalStorage = saveToLocalStorage;
	Gui.loadFromLocalStorage = loadFromLocalStorage;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

(function(){
	"use strict";
	
	Nes.trace_cpu = 0;
	Nes.trace_cpuInstructions = 1;
	Nes.trace_ppu = 2;
	Nes.trace_mapper = 3;
	Nes.trace_apu = 4;
	Nes.trace_all = 5;
	
		
	var Trace = function( ) {

		this._lines = [];
		this._running = false;
		this._enabledTypes = new Array( Nes.trace_all + 1 );
		for ( var i=0; i<this._enabledTypes.length; ++i ) {
			this._enabledTypes[ i ] = 0;
		}
	};
	
	
	Trace.prototype.enabled = function() {
	
		return this._running;
	};
	
	
	Trace.prototype.enableType = function( traceType, checked ) {
		
		this._enabledTypes[ traceType ] = checked ? 1 : 0;
	};
	
	
	Trace.prototype.writeLine = function( traceType, line ) {

		if ( this._running ) {
			if ( this._enabledTypes[ traceType ] === 1 ) {
				this._lines.push( line + '\r\n' );
			}
		}
	};
	
	
	Trace.prototype.start = function() {
	
		this._running = true;
	};
	
	
	Trace.prototype.stop = function() {
	
		this._running = false;
		
		// save to file
		if ( this._lines.length > 0 ) {
			var blob = new Blob( this._lines, {type: "text/plain;charset=utf-8"} );
			saveAs( blob, "trace.txt" );
			this._lines.length = 0;
		}
	};
	
	
	Nes.Trace = new Trace();
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

"use strict";


var WebAudioBuffer = function( audioContext, masterVolNode, size ) {

	this._locked = false;
	this.audioContext = audioContext;

	this.audioNode = null;
	this._gainNode = this.audioContext['createGain']();
	this._gainNode['connect']( masterVolNode );
	
	this.audioBuffer = this.audioContext['createBuffer']( 1, size, this.audioContext['sampleRate'] );

};


WebAudioBuffer.prototype.lockBuffer = function() {

	this._locked = true;
	return this.audioBuffer['getChannelData']( 0 );
};


WebAudioBuffer.prototype.unlockBuffer = function() {

	this._locked = false;
	
	// Alternative method using audio node buffer instead of onaudioprocess
	if ( this.audioNode ) {
		 this.audioNode['disconnect']();
		 this.audioNode = null;
	}
	this.audioNode = this.audioContext['createBufferSource']();
	this.audioNode['buffer'] = this.audioBuffer;
	
	this.audioNode['connect'](this._gainNode);
	this.audioNode['start'](0);
};


////////////////////////////////////////////////////////////////////////////////////////


var WebAudioRenderer = function( bufferSize, sampleRate ) {

	window.AudioContext = window.AudioContext || window.webkitAudioContext;
	if ( window.AudioContext === undefined ) {
		throw new Error( "WebAudio not supported in this browser" );
	}
	this.audioContext = new window.AudioContext();
	this._gainNode = this.audioContext['createGain']();
	this._gainNode['connect']( this.audioContext['destination'] );
};


WebAudioRenderer.prototype.setVolume = function( val ) {
	if ( this._gainNode ) {
		this._gainNode['gain']['value'] = val / 100;
	}
};


WebAudioRenderer.prototype.getSampleRate = function() {
	return this.audioContext['sampleRate'];
};


WebAudioRenderer.prototype.createBuffer = function( size ) {
	return new WebAudioBuffer( this.audioContext, this._gainNode, size );
};


Gui.WebAudioRenderer = WebAudioRenderer;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	
	var CanvasParent = function( renderSurface ) {
	
		var that = this;

		this._eventBus = new Nes.EventBus();
		this._parent = $( "#content" );
		this._element = $( "#canvasWrapper" );
		
		this._canvasElement = document.createElement('canvas');
		this._element[0].appendChild( this._canvasElement );
		
		this._setSize();
		
		$(window).resize(function(){
			that._setSize();
			that._setPosition();
		});
		this._setPosition();
	};
	
	
	CanvasParent.prototype.connect = function( name, cb ) {
		
		this._eventBus.connect( name, cb );
	};
	
	
	CanvasParent.prototype.getCanvasElement = function() {
		return this._canvasElement;
	};
	
	
	CanvasParent.prototype._setSize = function() {
	
		var parentWidth = this._parent.width();
		var parentHeight = this._parent.height();
		
		var resizeType = 'keepAspectRatio';
		
		if ( resizeType === 'keepAspectRatio' ) {
		
			var aspectRatio = SCREEN_WIDTH / SCREEN_HEIGHT;
			var newWidth = aspectRatio * parentHeight;
		
			this._canvasElement.width = Math.floor( newWidth );
			this._canvasElement.height = parentHeight;

			this._eventBus.invoke( 'resize' );
		}
	};
	
	
	CanvasParent.prototype._setPosition = function() {
		this._element.position( { 'of': this._parent, 'my': "center center", 'at': "center center" } );
	};
	
	
	Gui.CanvasParent = CanvasParent;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	
	var isClickWithinElementBounds = function( element, clickX, clickY ) {
		// look for a click outside the menu, then close the menu if it's outside of the menu's bounds
		var margin = 40;
		var pos = element.offset();
		var width = element.width();
		var height = element.height();
		var inBounds = ( pos.left - margin <= clickX && pos.left + width + margin >= clickX && pos.top - margin <= clickY && pos.top + height + margin >= clickY );
		return inBounds;
	};
	

	var ControlBarButton = function( mainboard, jqId, options ) {
		
		var that = this;
		this._options = options;
		this._toggleState = false;
		this._button = $( "#" + jqId ).button( { 'text': false, 'label': this._options.primary.label, 'icons': { 'primary': this._options.primary.icon } } );
		
		if ( this._options.toggleIcon || this._options.click ) {
			this._button.click( function() { var ret = that._onClick(); return ret === undefined ? true : ret; } );
		}
		
		if ( this._options.enabledWhenRomIsLoaded ) {
			this.enable( false );
			mainboard.connect( 'romLoaded', function( cart ) { that._onRomLoaded( cart ); } );
		}
	};
	
	
	ControlBarButton.prototype._onClick = function() {

		if ( this._options.click ) {
			return this._options.click();
		}
		return true;
	};
	

	ControlBarButton.prototype._onRomLoaded = function( cart ) {
		
		if ( this._options.enabledWhenRomIsLoaded ) {
			this.enable( true );
		}
	};
	
	
	ControlBarButton.prototype.toggleIcon = function( forceToggle ) {
		
		if ( forceToggle === undefined ) {
			this._toggleState = !this._toggleState;
		} else {
			this._toggleState = forceToggle;
		}
		if ( this._options.toggle ) {
			var opts;
			if ( this._toggleState ) {
				opts = { 'label': ( this._options.toggle.label || this._options.primary.label ), 'icons': { 'primary': ( this._options.toggle.icon || this._options.primary.icon ) } };
			} else {
				opts = { 'label': this._options.primary.label, 'icons': { 'primary': this._options.primary.icon } };
			}
			this._button.button( "option", opts );
		}
	};
	
	
	ControlBarButton.prototype.highlight = function( hl ) {
			
		if ( hl === true || hl === undefined ) {
			this._button.addClass( 'ui-state-highlight' );
		} else {
			this._button.removeClass( 'ui-state-highlight' );
		}
	};
	
	
	ControlBarButton.prototype.alert = function( hl ) {
			
		if ( hl === true || hl === undefined ) {
			this._button.addClass( 'ui-state-error' );
		} else {
			this._button.removeClass( 'ui-state-error' );
		}
	};
	
	
	ControlBarButton.prototype.enable = function( enable ) {
		var txt = ( enable === undefined || enable ) ? 'enable' : 'disable';
		this._button.button( txt );
	};
	
	
	
	var ControlBarMenu = function( menuJqId, buttonObject, options ) {
	
		var that = this;
		
		this._buttonObject = buttonObject;
		this._options = options || {};
		this._menu = $( "#" + menuJqId ).menu();
		this._menu.hide();
		
		$( document ).on( "click", function( e ) {
			that._onDocClick( e );
		});
		
		// Connect checkbox change events
		if ( this._options.checkBoxes && Array.isArray( this._options.checkBoxes ) ) {
			for ( var i=0; i<this._options.checkBoxes.length; ++i ) {
				var obj = this._options.checkBoxes[i];
				if ( obj.change ) {
					obj.checkBoxSelector.change( obj.change );
				}
			}
		}
	};
	
	
	ControlBarMenu.prototype._onDocClick = function( e ) {
		// hide menu when clicked somewhere else
		// HACK: cx and cy will be zero on a forced (manual) click event invoked by .click(). So we ignore these
		if ( e.clientX === 0 && e.clientY === 0 ) {
			return;
		}
		if ( this.isVisible() ) {
			if ( !isClickWithinElementBounds( this._menu, e.clientX, e.clientY ) ) {
				this.hide();
			} else {
				// click was inside the menu. check the options object for specified behaviour
				if ( this._options.checkBoxes && Array.isArray( this._options.checkBoxes ) ) {
					for ( var i=0; i<this._options.checkBoxes.length; ++i ) {
						var obj = this._options.checkBoxes[i];
						// if we clicked on the li element, check the checkbox (this way user doesnt have to click checkbox exactly)
						if ( e.target.id === obj.parentId ) {
							obj.checkBoxSelector.click();
						}
					}
				}
			}
		}
	};
	
	
	ControlBarMenu.prototype.toggleShow = function() {
	
		if ( this.isVisible() ) {
			this.hide();
		} else {
			this.show();
		}
	};
	
	
	ControlBarMenu.prototype.show = function() {
		this._menu.show().position( {
				'my': "left bottom",
				'at': "left top",
				'of': this._buttonObject._button
			});
	};
	
	
	ControlBarMenu.prototype.hide = function() {
		if ( this._menu.is(':visible') ) {
			this._menu.hide();
		}
	};
	
	
	ControlBarMenu.prototype.isVisible = function() {
		return this._menu.is(':visible');
	};
	
	
	
	
	var ControlBarSlider = function( jqId, buttonObject, options ) {
	
		var that = this;
		this._buttonObject = buttonObject;
		this._options = options;
		this._options.defaultValueIndex = this._options.defaultValueIndex === undefined ? 0 : this._options.defaultValueIndex;
		this._currentIndex = this._options.defaultValueIndex;
		this._tooltipCreated = false;
		
		this._dialog = $( "#" + jqId ).dialog({
				'dialogClass': "no-close controlBarSlider",
				'draggable': false,
				'autoOpen': false,
				'height': 130,
				'minHeight': 130,
				'width': 40,
				'minWidth': 40,
				'modal': false,
				'resizable': false,
				'buttons': {
				},
				'close': function() {
				}
			} );
			
		var sliderElement = document.createElement( 'div' );
		this._dialog[0].appendChild( sliderElement );
		
		var isRangeSlider = this._options.values === undefined;
		
		if ( isRangeSlider ) {
			this._slider = $( sliderElement ).slider( {
				'value': this._options.defaultValueIndex,
				'min': this._options.minValue,
				'max': this._options.maxValue,
				'orientation': "vertical",
				'change': function( event, ui ) {
					that._updateTooltip( ui.handle, ui.value );
				}
			} );
		} else {
			this._slider = $( sliderElement ).slider( {
				'value': this._options.defaultValueIndex,
				'min': 0,
				'max': this._options.values.length-1,
				'step': 1,
				'orientation': "vertical",
				'slide': function( event, ui ) {
					that._updateTooltip( ui.handle, ui.value );
				},
				'change': function( event, ui ) {
					that._updateTooltip( ui.handle, ui.value );
				}
			} );
		}
		this._slider.addClass( 'controlBarSliderContents' );
		this._createTooltip();

		$( document ).on( "click", function( e ) {
			that._onDocClick( e );
		});
	};
	
	
	ControlBarSlider.prototype._getTooltipText = function( val ) {
		if ( this._options.values && val >= 0 && val < this._options.values.length ) {
			return this._options.values[ val ].text;
		} else {
			return val.toString();
		}
	};
	
	
	ControlBarSlider.prototype._createTooltip = function() {
		var handleElement = $('.ui-slider-handle', this._slider);
		handleElement.qtip( {
			'content': this._getTooltipText( this._options.defaultValueIndex ),
			'position': {
				'corner':{'target':'leftMiddle','tooltip':'rightMiddle'}, //instead of corner:{target:'rightMiddle',tooltip:'leftMiddle'},
				'adjust':{'screen':true, 'resize':true}
			},
			'hide': {
				'delay': 100
			}
		} );
	};
	
	
	ControlBarSlider.prototype._updateTooltip = function( handle, val ) {
		if ( this._currentIndex !== val ) {
			this._currentIndex = val;
			$(handle).qtip( "option", 'content.text', this._getTooltipText( val ) );
			if ( this._options.change ) {
				this._options.change( this._options.values ? this._options.values[ this._currentIndex ].value : val );
			}
		}
	};
	
	
	ControlBarSlider.prototype._onDocClick = function( e ) {
		// HACK: cx and cy will be zero on a forced (manual) click event invoked by .click(). So we ignore these
		if ( e.clientX === 0 && e.clientY === 0 ) {
			return;
		}
		// hide menu when clicked somewhere else
		if ( this.isVisible() ) {
			if ( !isClickWithinElementBounds( this._dialog, e.clientX, e.clientY ) ) {
				this.hide();
			}
		}
	};
	
	
	ControlBarSlider.prototype.show = function() {
		this._dialog.dialog( "option", "position", {
				'my': "left bottom",
				'at': "left top",
				'of': this._buttonObject._button
			} );
		this._dialog.dialog( "open" );
	};
	
	
	ControlBarSlider.prototype.hide = function() {
		if ( this._dialog.is(':visible') ) {
			this._dialog.dialog( "close" );
		}
	};
	
	
	ControlBarSlider.prototype.isVisible = function() {
		return this._dialog.is(':visible');
	};
	
	
	
	
	
	var ControlBarMessage = function( jqId, buttonObject, options ) {
	
		var that = this;
		this._buttonObject = buttonObject;
		this._options = options;
		this._allowAutoHide = false;

		this._dialog = $( "#" + jqId ).dialog({
				'dialogClass': "no-close controlBarSlider",
				'draggable': false,
				'autoOpen': false,
				'height': 'auto',
				'minHeight': 50,
				'width': 'auto',
				'minWidth': 100,
				'modal': false,
				'resizable': false,
				'buttons': {
				},
				'close': function() {
				}
			} );
			
		this._textElement = document.createElement( 'div' );
		this._dialog[0].appendChild( this._textElement );
		
		$( document ).on( "click", function( e ) {
			that._onDocClick( e );
		});
	};
	
	
	ControlBarMessage.prototype.setText = function( text ) {
		
		this._textElement.innerHTML = '<p>' + text + '</p>';
	};
	
	
	ControlBarMessage.prototype._onDocClick = function( e ) {
		// HACK: cx and cy will be zero on a forced (manual) click event invoked by .click(). So we ignore these
		if ( e.clientX === 0 && e.clientY === 0 ) {
			return;
		}
		// hide menu when clicked somewhere else
		if ( this.isVisible() ) {
			if ( !isClickWithinElementBounds( this._dialog, e.clientX, e.clientY ) ) {
				if ( this._allowAutoHide ) {
					this.hide();
				}
			}
		}
	};
	
	
	ControlBarMessage.prototype.show = function() {
		var that = this;
		this._dialog.dialog( "option", "position", {
				'my': "right top",
				'at': "right bottom",
				'of': this._buttonObject._button
			} );
		this._dialog.dialog( "open" );
		this._buttonObject.alert( true );
		this._allowAutoHide = false;
		setTimeout( function() {
			that._allowAutoHide = true;
		}, 300 );
	};
	
	
	ControlBarMessage.prototype.hide = function() {
		if ( this._dialog.is(':visible') ) {
			this._dialog.dialog( "close" );
		}
		this._buttonObject.alert( false );
	};
	
	
	ControlBarMessage.prototype.isVisible = function() {
		return this._dialog.is(':visible');
	};
	
	
	
	
	
	Gui.ControlBarButton = ControlBarButton;
	Gui.ControlBarMenu = ControlBarMenu;
	Gui.ControlBarSlider = ControlBarSlider;
	Gui.ControlBarMessage = ControlBarMessage;
}());




/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";

	
	var ControlBar = function( app ) {
	
		var that = this;
		this._debugEnabled = false;
		this._isLimitOn = true;
		this._traceRunning = false;
		this._isPaused = false;
		this._encodingIgnoreNextClick = false;
		this._app = app;
		this._eventBus = new Nes.EventBus();
		
		this._app.connect( 'cartLoaded', function( cart ) { that._onCartLoaded( cart ); } );
		this._app._mainboard.connect( 'soundEnabled', function( enabled, supported ) { that._onSoundEnabled( enabled, supported ); } );
		this._app.connect( 'traceRunning', function( on ) { that._onTraceRunning( on ); } );
		this._app.connect( 'frameLimit', function( on ) { that._onFrameLimitSet( on ); } );
		this._app.connect( 'isPausedChange', function( on ) { that._onPauseChange( on ); } );
		this._app.connect( 'romLoadFailure', function( reason ) { that._onRomLoadFailure( reason ); } );
		
		this._element = $( "#controlBar" );
		
		this._debugBar = $( "#debugBar" );
		this._debugBar.hide();
		
		this._buttons = [];
		
		// primary buttons
		this._addButton( "controlBar_loadRomButton", { primary: { label: "Open ROM", icon: "ui-icon-folder-open" }, click: function() { that._loadRomButtonClick(); } } );
		this._addButton( "controlBar_resetButton", { enabledWhenRomIsLoaded: true, primary: { label: "Reset", icon: "ui-icon-refresh" }, click: function() { that._onResetButtonClick(); } } );
		this._playButton = this._addButton( "controlBar_playButton", { primary: { label: "Pause", icon: "ui-icon-pause" }, toggle: { label: "Play", icon: 'ui-icon-play' }, click: function() { that._onPlayButtonClick(); } } );
		this._gameGenieButton = this._addButton( "controlBar_gameGenieButton", { enabledWhenRomIsLoaded: true, primary: { label: "Game Genie", icon: "ui-icon-star" }, click: function() { that._onGameGenieButtonClick(); } } );
		this._addButton( "controlBar_quickSaveButton", { enabledWhenRomIsLoaded: true, primary: { label: "Quick save", icon: "ui-icon-disk" }, click: function() { that._onSaveButtonClick(); } } );
		this._addButton( "controlBar_quickLoadButton", { enabledWhenRomIsLoaded: true, primary: { label: "Quick load", icon: "ui-icon-folder-collapsed" }, click: function() { that._onLoadButtonClick(); } } );
		this._addButton( "controlBar_screenshotButton", { enabledWhenRomIsLoaded: true, primary: { label: "Screenshot", icon: "ui-icon-image" }, click: function() { that._onScreenshotButtonClick(); } } );
		this._debugButton = this._addButton( "controlBar_debugButton", { primary: { label: "Debug panel", icon: "ui-icon-wrench" }, click: function() { that._onDebugButtonClick(); } } );
		this._keyboardRemapperButton = this._addButton( "controlBar_keyboardRemap", { primary: { label: "Remap controls", icon: "ui-icon-calculator" }, click: function() { that._onKeyboardRemapButtonClick(); } } );
		
		this._soundButton = this._addButton( "controlBar_soundButton", { primary: { label: "Volume", icon: "ui-icon-volume-on" }, toggle: { label: "Volume", icon: 'ui-icon-volume-off' }, click: function() { that._onSoundButtonClick(); return false; } } );
		this._soundSlider = new Gui.ControlBarSlider( "controlBar_volumeSlider", this._soundButton, {
				minValue: 0,
				maxValue: 100,
				defaultValueIndex: 100,
				change: function( val ) {
					that._onVolumeSliderChange( val );
				}
			} );
		this._errorDisplayButton = this._addButton( "controlBar_errorDisplay", { primary: { label: "Alerts", icon: "ui-icon-alert" }, click: function() { that._errorDisplayButtonClick(); } } );
		this._errorDisplayMessage = new Gui.ControlBarMessage( "controlBar_alertMessage", this._errorDisplayButton );
		
		// debug buttons
		this._addButton( "debugControlBar_playOneFrameButton", { primary: { label: "Play one frame", icon: "ui-icon-seek-next" }, click: function() { that._onPlayOneFrameButtonClick(); } } );
		this._gameSpeedButton = this._addButton( "debugControlBar_gameSpeedButton", { primary: { label: "Game Speed", icon: "ui-icon-transferthick-e-w" }, click: function() { that._onGameSpeedClick(); return false; } } );
		this._addButton( "debugControlBar_getFrameHashButton", { primary: { label: "Display frame information", icon: "ui-icon-locked" }, click: function() { that._getFrameHashButtonClick(); } } );
		this._traceButton = this._addButton( "debugControlBar_traceButton", { primary: { label: "Start Trace", icon: "ui-icon-arrowthickstop-1-s" }, toggle: { label: "Stop Trace", icon: "ui-icon-stop" }, click: function() { that._startTrace(); } } );

		// NTSC / PAL encoding selection
		this._encodingSelection = $( "#debugControlBar_encoding" ).buttonset();
		this._encodingNTSC = $( "#debugControlBar_encodingNTSC" ).click( function() { return that._encodingClick( "NTSC" ); } );
		this._encodingPAL = $( "#debugControlBar_encodingPAL" ).click( function() { return that._encodingClick( "PAL" ); } );
		
		// trace menu
		this._selectTraceButton = this._addButton( "debugControlBar_selectTraceButton", { primary: { label: "Trace Options..", icon: "ui-icon-triangle-1-n" }, click: function() { that._traceMenu.toggleShow(); return false; } } );
		this._traceMenu = new Gui.ControlBarMenu( "debugControlBar_traceMenu", this._selectTraceButton,
				{ checkBoxes: [
					{ parentId: 'controlBar_cpuTraceParent', 				checkBoxSelector: $( "#controlBar_cpuTraceButton" ), 				change: function( event ) { that._onTraceOption( Nes.trace_cpu, event ); } },
					{ parentId: 'controlBar_cpuInstructionsTraceParent', 	checkBoxSelector: $( "#controlBar_cpuInstructionsTraceButton" ), 	change: function( event ) { that._onTraceOption( Nes.trace_cpuInstructions, event ); } },
					{ parentId: 'controlBar_ppuTraceParent', 				checkBoxSelector: $( "#controlBar_ppuTraceButton" ), 				change: function( event ) { that._onTraceOption( Nes.trace_ppu, event ); } },
					{ parentId: 'controlBar_mapperTraceParent', 			checkBoxSelector: $( "#controlBar_mapperTraceButton" ), 			change: function( event ) { that._onTraceOption( Nes.trace_mapper, event ); } },
					{ parentId: 'controlBar_allTraceParent', 				checkBoxSelector: $( "#controlBar_allTraceButton" ), 				change: function( event ) { that._onTraceOption( Nes.trace_all, event ); } }
				] }
			);
			
		// game speed slider
		this._gameSpeedSlider = new Gui.ControlBarSlider( "debugControlBar_gameSpeedSlider", this._gameSpeedButton, {
				values: [
					{ text: '25% Speed', value: 25 },
					{ text: '50% Speed', value: 50 },
					{ text: '75% Speed', value: 75 },
					{ text: '100% Speed', value: 100 },
					{ text: '125% Speed', value: 125 },
					{ text: '150% Speed', value: 150 },
					{ text: '175% Speed', value: 175 },
					{ text: '200% Speed', value: 200 },
					{ text: 'Unlimited', value: -1 }
				],
				defaultValueIndex: 3,
				change: function( speedVal ) {
					that._onGameSpeedSliderChange( speedVal );
				}
			} );
		
		this._element.css( 'visibility', 'visible' );
		$(window).resize(function(){
			that._setPosition();
		});
		this._setPosition();
	};
	
	
	ControlBar.prototype._onKeyboardRemapButtonClick = function() {
		
		this._app._keyboardRemapDialog.show();
	};
	
	
	ControlBar.prototype._errorDisplayButtonClick = function() {
		this._errorDisplayButton.alert( false );
	};
	
	
	ControlBar.prototype._onRomLoadFailure = function( reason ) {

		this._errorDisplayMessage.setText( reason );
		this._errorDisplayMessage.show();
	};
	
	
	ControlBar.prototype._onTraceOption = function( traceType, event ) {

		this._app.setTraceOption( traceType, event.currentTarget.checked );
	};
	
	
	ControlBar.prototype._onGameSpeedSliderChange = function( speedVal ) {
		
		this._app.setGameSpeed( speedVal );
	};
	
	
	ControlBar.prototype._onVolumeSliderChange = function( val ) {
		
		var muted = val === 0;
		if ( this._app.soundSupported() ) {
			this._soundButton.toggleIcon( muted );
			this._app.enableSound( !muted );
			this._app.setVolume( val );
		}
	};
	
	
	ControlBar.prototype._addButton = function( jqId, options ) {
	
		var but = new Gui.ControlBarButton( this._app._mainboard, jqId, options );
		this._buttons.push( but );
		return but;
	};
	
	
	ControlBar.prototype.connect = function( name, cb ) {

		this._eventBus.connect( name, cb );
	};
	
	
	ControlBar.prototype._encodingClick = function( encodingType ) {
		if ( this._encodingIgnoreNextClick ) {
			this._encodingIgnoreNextClick = false;
			return true;
		}
		this._app.setColourEncodingType( encodingType );
	//	this._onEncodingChanged( encodingType );
		return true;
	};
		
	
	ControlBar.prototype._onEncodingChanged = function( encodingType ) {
	
		this._encodingIgnoreNextClick = true;
		if ( encodingType === "PAL" ) {
			this._encodingPAL.click();
		} else {
			this._encodingNTSC.click();
		}
	};
	
	
	ControlBar.prototype._onPauseChange = function( isPaused ) {

		this._playButton.toggleIcon( isPaused );
	};
	
	
	ControlBar.prototype._onTraceRunning = function( on ) {
		this._traceRunning = on;
		this._traceButton.highlight( this._traceRunning );
		this._traceButton.toggleIcon( this._traceRunning );
	};
	
	
	ControlBar.prototype._startTrace = function() {
		
		if ( !this._traceRunning ) {
			this._app.startTrace();
		} else {
			this._app.stopTrace();
		}
	};
	
	
	ControlBar.prototype._onScreenshotButtonClick = function() {
		
		this._app.screenshot();
	};
	
	
	ControlBar.prototype._onCartLoaded = function( cart ) {
	
		this._gameGenieButton.highlight( cart.areGameGenieCodesAvailable() );
		this._onEncodingChanged( cart._colourEncodingType );
		// if ( !this._element.is(":visible") ) {
			// this._element.show( "slide", { direction: "down" }, 1000 );
		// }
	};
	
	
	ControlBar.prototype._onSoundEnabled = function( enabled, supported ) {

		if ( supported ) {
			this._soundButton.enable( true );
			this._soundButton.toggleIcon( !enabled );
		} else {
			this._soundButton.enable( false );
			this._soundButton.toggleIcon( true );
		}
	};
	
	
	ControlBar.prototype._onSaveButtonClick = function() {
	
		this._app._saveStateManager.quickSaveState();
	};
	
	
	ControlBar.prototype._onLoadButtonClick = function() {
	
		//this._app._saveStateManager.quickLoadState();
		this._app._saveStateManager.showLoadStateDialog();
	};
	
	
	ControlBar.prototype._getFrameHashButtonClick = function() {

		console.log( "{ frame: " + this._app._mainboard.ppu.frameCounter + ', expectedHash: "' + this._app._renderSurface.getRenderBufferHash() + '" }' );
	};
	
	
	ControlBar.prototype._onDebugButtonClick = function() {
		
		this._debugEnabled = !this._debugEnabled;
		this._debugButton.highlight( this._debugEnabled );
		if ( this._debugEnabled ) {
			this._debugBar.show();
			this._app.showFpsMeter( true );
		} else {
			this._debugBar.hide(); 
			this._app.showFpsMeter( false );
		}
	};
	
	
	ControlBar.prototype._onPlayOneFrameButtonClick = function() {
	
		this._app.playOneFrame();
	};
	
	
	ControlBar.prototype._onResetButtonClick = function() {
	
		this._app.reset();
	};
	

	ControlBar.prototype._loadRomButtonClick = function() {
	
		var that = this;
	
		var handleFileSelect = function( evt ) {

			var file = evt.target.files[0];
			var reader = new FileReader();

			// If we use onloadend, we need to check the readyState.
			reader.onloadend = function( loadEvent ) {
				if ( loadEvent.target.readyState === FileReader.DONE ) {
					that._eventBus.invoke( 'romLoaded', file.name, new Uint8Array( loadEvent.target.result ) );
				}
			};

			reader.readAsArrayBuffer( file );
		};

		var input = $( document.createElement( 'input' ) );
		input.attr( "type", "file" );
		input.on( 'change', handleFileSelect );
		input.trigger( 'click' ); // open dialog
	};
	
	
	ControlBar.prototype._onGameSpeedClick = function() {

		if ( this._gameSpeedSlider.isVisible() ) {
			this._gameSpeedSlider.hide();
		} else {
			this._gameSpeedSlider.show();
		}
	};
	
	
	ControlBar.prototype._onFrameLimitSet = function( limitOn ) {

		this._isLimitOn = limitOn;
	//	this._frameLimitButton.toggleIcon( !this._isLimitOn );
	};
	
	
	ControlBar.prototype._onPlayButtonClick = function() {
	
		this._isPaused = !this._isPaused;
		this._app.pause( this._isPaused );
	};
	
	
	ControlBar.prototype._onSoundButtonClick = function() {

		if ( this._soundSlider.isVisible() ) {
			this._soundSlider.hide();
		} else {
			this._soundSlider.show();
		}
	};
	
	
	ControlBar.prototype._onGameGenieButtonClick = function() {
	
		if ( this._app._mainboard.cart ) {
			this._app._ggDialog.show();
		}
	};
	
	
	ControlBar.prototype._setPosition = function() {
		this._element.position( { 'of': $( window ), 'my': "bottom", 'at': "bottom" } );
	};
	
	
	Gui.ControlBar = ControlBar;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	var _open = null;
	
	
	var LoadStateDialog = function( app ) {
	
		var that = this;
		this._app = app;
		this._contentsDiv = $( "#loadStateDialog_contents" );

		this._dialog = $( "#loadStateDialog" ).dialog({
			'autoOpen': false,
			'height': 400,
			'width': 900,
			'modal': true,
			'buttons': {
				'Close': function() {
					that._dialog.dialog( "close" );
				}
			},
			'close': function() {
				that._onClose();
			}
		});
	};
	
	
	LoadStateDialog.prototype._onClose = function() {
	
		this._app.pause( false );
	};
	
	
	LoadStateDialog.prototype.show = function( cartName, meta ) {
	
		_open = this;
	
		function formatDate( date ) {
			return ( new Date( date ) ).toLocaleString();
		};
	
		// load all images saved for the currently loaded game
		var html = '';
		var keyNames = Object.keys( meta.slots );
		
		// sort so most recent is first
		keyNames = keyNames.sort( function( lhs, rhs ) {
			var slhs = meta.slots[ lhs ];
			var srhs = meta.slots[ rhs ];
			return srhs.date - slhs.date;
		} );
		
		for ( var keyIndex=0; keyIndex<keyNames.length; ++keyIndex ) {
			var slotName = keyNames[ keyIndex ];
			var slot = meta.slots[ slotName ];
			html += "<div class='loadSaveDiv'>";
			html += "<button type='button' onclick='Gui.loadSaveDialog_onclick( \"" + slotName + "\" );'>";
			if ( slot.screen ) {
				html += "<img src='" + slot.screen + "' width='" + SCREEN_WIDTH + "' height='" + SCREEN_HEIGHT + "'/><br/>";
			//	html += "<img src='" + slot.screen + "'/><br/>";
			}
			html += "<span>" + slotName + "</span><br/>";
			html += "<span>" + formatDate( slot.date ) + "</span>";
			html += "</button>";
			html += "</div>";
		}
		this._contentsDiv[0].innerHTML = html;
		this._app.pause( true );
		this._dialog.dialog( "open" );
	};
	
	
	var loadSaveDialog_onclick = function( saveName ) {
	
		if ( _open ) {
			_open._app._saveStateManager.loadState( saveName );
			_open._dialog.dialog( "close" );
		}
	};
	
	
	Gui.LoadStateDialog = LoadStateDialog;
	Gui['loadSaveDialog_onclick'] = loadSaveDialog_onclick;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	var _open = null;
	
	
	var GameGenieDialog = function( app ) {
	
		var that = this;
		this._app = app;
		this._contentsDiv = $( "#gameGenieDialog_contents" );
		
		this._app.connect( 'cartLoaded', function( cart ) { that._onCartLoaded( cart ); } );

		this._dialog = $( "#gameGenieDialog" ).dialog({
			'autoOpen': false,
			'title': 'Game Genie Codes',
			'height': 400,
			'width': 900,
			'modal': true,
			'buttons': {
				'Close': function() {
					that._dialog.dialog( "close" );
				}
			},
			'close': function() {
				that._onClose();
			}
		});
	};


	GameGenieDialog.prototype.show = function() {
	
		_open = this;
		this._app.pause( true );
		this._dialog.dialog( "open" );
	};
	
	
	GameGenieDialog.prototype._onClose = function() {
	
		this._app.pause( false );
	};
	
	
	GameGenieDialog.prototype._onCartLoaded = function( cart ) {
	
		var html = '';
		var that = this;
		if ( cart && cart._dbData && cart._dbData['gameGenieCodes'] ) {
			var codesArray = cart._dbData['gameGenieCodes'];

			for ( var i=0; i<codesArray.length; ++i ) {
			
				var gg = codesArray[i];
				var checkboxId = "gg_cb_" + i;
				
				html += '<div id="gg_' + i + '">';
				html += "<input type='checkbox' id='" + checkboxId + "' value='" + i + "' onclick='Gui.gameGenieDialog_onclick( " + i + " );'><span>" + gg.name + "</span>";
				html += '</div>';
			}
		}
		
		this._contentsDiv[0].innerHTML = html;
	};
	
	
	
	var gameGenieDialog_onclick = function( gameCodeId ) {
	
		if ( _open ) {
			var cart = _open._app._mainboard.cart;
			var codesArray = cart._dbData['gameGenieCodes'];
			
			var jqElement = $( "#gg_cb_" + gameCodeId );
			var isChecked = jqElement[0].checked;
			var code = codesArray[ gameCodeId ];
			//console.log( "Checked " + jqElement.id + " = " + isChecked );
			var selectedSubCodeIndex = 0;
			for ( var j=0; j<code['codes'][ selectedSubCodeIndex ].length; ++j ) {
				Nes.processGameGenieCode( _open._app._mainboard, code['codes'][ selectedSubCodeIndex ][j], isChecked );
			}
		}
	};
	
	
	Gui.GameGenieDialog = GameGenieDialog;
	Gui['gameGenieDialog_onclick'] = gameGenieDialog_onclick;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	var spriteWidth = 8;
	var spriteHeight = 8;
	var canvasWidth = spriteWidth * 8;
	var canvasHeight = spriteHeight * 8;
	var displayMultiplier = 4;
	
	var SpriteDisplayWindow = function( mainboard, divElement ) {
	
		this._mainboard = mainboard;
		
		// add canvas for rendering all sprites on
		this._offscreenElement = document.createElement('canvas');
		this._offscreenElement.width = canvasWidth;
		this._offscreenElement.height = canvasHeight;
		this._offscreenCanvas = this._offscreenElement.getContext( "2d" );
		this._offscreenCanvas.imageSmoothingEnabled = false;
		this._offscreenData = this._offscreenCanvas.getImageData( 0, 0, canvasWidth, canvasHeight );
		this._offscreen32BitView = new Uint32Array( this._offscreenData.data.buffer );
		
		this._element = document.createElement('canvas');
		this._element.width = canvasWidth * displayMultiplier;
		this._element.height = canvasHeight * displayMultiplier;
		this._canvas = this._element.getContext("2d");
		this._canvas.imageSmoothingEnabled = false;
		
		divElement.appendChild( this._element );
		
		this._infoElement = document.createElement( 'p' );
		
		divElement.appendChild( this._infoElement );
		
		this._loadSpriteData();
	};
	
	
	SpriteDisplayWindow.prototype._loadSpriteData = function() {
	
		// copy of renderSprite function in ppu.js
		// TODO: tidy up
		if ( this._mainboard.cart ) {
			
			var innerHtmlText = '';
			var spriteMemory = this._mainboard.ppu.spriteMemory;

			for ( var spriteIndex=0; spriteIndex<64; ++spriteIndex ) {
			
				var memIndex = spriteIndex * 4;
			
				var sy = spriteMemory[ memIndex + 0 ] + 1;
				var patternnum = spriteMemory[ memIndex + 1 ];
				var attribs = spriteMemory[ memIndex + 2 ];
				var sx = spriteMemory[ memIndex + 3 ];
				
		//		innerHtmlText += spriteIndex + ": " + sx + "x" + sy + "</br>";
				
				var flipHorz = ( attribs & 0x40 ) > 0;
				var flipVert = ( attribs & 0x80 ) > 0;

				for ( var y=0; y<8; ++y ) {
					var ppuAddress = 0;

					if ( ( this._mainboard.ppu.control1 & 0x20 ) === 0 /*!ppuControl1.spriteSize*/ )
					{
						ppuAddress = ( patternnum * 16 ) + ( ( flipVert ? 7 - y : y ) & 0x7 ) + ( ( this._mainboard.ppu.control1 & 0x8 ) > 0 /*ppuControl1.spritePatternTableAddress*/ ? 0x1000 : 0 );
					}
					else // big sprites - if sprite num is even, use 0x0 else use 0x1000
					{
						ppuAddress = ((patternnum & 0xFE) * 16) + ((patternnum & 0x01) * 0x1000);

						// var topsprite = IS_INT_BETWEEN( scanline, sy, sy + 8 );

						// if ( !topsprite )
						// { // on flipped, put top sprite on bottom & vis versa
							// if ( flipVert )
								// ppuAddress += 15 - y;
							// else
								// ppuAddress += 8 + y;
						// }
						// else
						// {
							// if ( flipVert )
								// ppuAddress += 23 - y;
							// else
								// ppuAddress += y;
						// }
					}

					var firstByte = this._mainboard.ppu.read8( ppuAddress );
					var secondByte = this._mainboard.ppu.read8( ppuAddress + 8 );
					var paletteMergeByte = (attribs & 3) << 2;

					for ( var x=0; x<8; ++x )
					{
						var mask = 0x80 >> ( flipHorz ? 7 - x : x );
							
						// get 2 lower bits from the pattern table for the colour index
						var paletteindex = ( firstByte & mask ) > 0 ? 1 : 0; // first bit
						paletteindex |= ( secondByte & mask ) > 0 ? 2 : 0; // second bit

						var colour;
						// add 2 upper bits
						if ( paletteindex > 0 ) {
							paletteindex |= paletteMergeByte;
							var paletteIndex = this._mainboard.ppu.paletteTables[ 1 ][ paletteindex ];
							colour = this._mainboard.renderBuffer.defaultPalette32BitVals[ paletteIndex || 0 ] || 0;
						} else {
							var paletteIndex = this._mainboard.ppu.paletteTables[ 1 ][ 0 ];
							colour = this._mainboard.renderBuffer.defaultPalette32BitVals[ paletteIndex ];
						}
						
						var screenIndex = ( ( spriteIndex % 8 ) * 8 + y ) * 64 + ( Math.floor( spriteIndex / 8 ) * 8 ) + x
						this._offscreen32BitView[ screenIndex ] = colour;
					}
				}
			}
			
			this._infoElement.innerHTML = innerHtmlText;
		}
		
		this._updateCanvas();
		var that = this;
		setTimeout( function() { that._loadSpriteData(); }, 1000 );
	};
	
	
	SpriteDisplayWindow.prototype._updateCanvas = function() {
	
		this._offscreenCanvas.putImageData( this._offscreenData, 0, 0 );
		// Draw offscreen canvas onto front buffer, resizing it in the process
		this._canvas.drawImage( this._offscreenElement, 0, 0, this._element.clientWidth, this._element.clientHeight );
	};
	
	
	Gui.SpriteDisplayWindow = SpriteDisplayWindow;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	var pixelColoursAcross = 16;
	var pixelColoursDown = 2;
	
	var pixelColourWidth = 30;
	var pixelColourHeight = 30;
	
	var canvasWidth = pixelColourWidth * pixelColoursAcross;
	var canvasHeight = pixelColoursDown * pixelColourHeight;
	
	
	var PaletteDisplayWindow = function( mainboard, divElement ) {
	
		this._mainboard = mainboard;
		
		// add canvas for rendering all sprites on
		this._offscreenElement = document.createElement('canvas');
		this._offscreenElement.width = pixelColoursAcross;
		this._offscreenElement.height = pixelColoursDown;
		this._offscreenCanvas = this._offscreenElement.getContext( "2d" );
		this._offscreenCanvas.imageSmoothingEnabled = false;
		this._offscreenData = this._offscreenCanvas.getImageData( 0, 0, pixelColoursAcross, pixelColoursDown );
		this._offscreen32BitView = new Uint32Array( this._offscreenData.data.buffer );
		
		this._element = document.createElement('canvas');
		this._element.width = canvasWidth;
		this._element.height = canvasHeight;
		this._canvas = this._element.getContext("2d");
		this._canvas.imageSmoothingEnabled = false;
		
		divElement.appendChild( this._element );
		
		this._infoElement = document.createElement('p');
		divElement.appendChild( this._infoElement );
		
		this._loadPaletteData();
	};
	
	
	PaletteDisplayWindow.prototype._loadPaletteData = function() {
	
		if ( this._mainboard.cart ) {
		
			var info = '';
		
			for ( var index=0; index<32; ++index ) {
				var paletteIndex = this._mainboard.ppu.paletteTables[ Math.floor( index / 16 ) ][ index % 16 ];
				var colour = this._mainboard.renderBuffer.defaultPalette32BitVals[ paletteIndex || 0 ] || 0;
				this._offscreen32BitView[ index ] = colour;
				
		//		info += ( 0x3F00 + index ).toString(16) + "=" + paletteIndex.toString( 16 ) + "</br>";
			}
			
			this._infoElement.innerHTML = info;
		}
		
		this._updateCanvas();
		var that = this;
		setTimeout( function() { that._loadPaletteData(); }, 1000 );
	};
	
	
	PaletteDisplayWindow.prototype._updateCanvas = function() {
	
		this._offscreenCanvas.putImageData( this._offscreenData, 0, 0 );
		// Draw offscreen canvas onto front buffer, resizing it in the process
		this._canvas.drawImage( this._offscreenElement, 0, 0, this._element.clientWidth, this._element.clientHeight );
	};
	
	
	Gui.PaletteDisplayWindow = PaletteDisplayWindow;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

(function(){
	"use strict";
	
	// var CpuInstructionsWindow = function( mainboard, divElement ) {
	
		// var that = this;
		// this._strArray = [];
		// this._dataArray = [];
		// this._element = document.createElement('textarea');
		// this._element.rows = 10;
		// this._element.cols = 40;
		// divElement.appendChild( this._element );
		// this._mainboard = mainboard;
		// this._mainboard.connect( 'reset', function() { that._reset(); } );
		// this._mainboard.cpu.setExecuteCallback( function( programCounter, instruction, instructionBytes, addressingModeArgs ) {
			// that._onCpuExecute( programCounter, instruction, instructionBytes, addressingModeArgs );
		// } );
	// };
	
	
	// CpuInstructionsWindow.prototype._reset = function() {
	
		// // run decompiler, display current position in window
		
	// };
	
	
	// CpuInstructionsWindow.prototype._onCpuExecute = function( programCounter, instruction, instructionBytes, addressingModeArgs ) {

		// // get next instruction details
		// var currentProgramCounter = this._mainboard.cpu.programCounter;
		// var nextOpCode = this._mainboard.memory.read8( currentProgramCounter );
		// var nextInstruction = Nes.getInstructionByOpcode( nextOpCode );
		
		// // is next instruction break pointed?
		// if ( this._mainboard.cpu.isRunning ) {
			// this._mainboard.cpu.breakPoint( false );
		// }
	
	// //	this._addData( [ programCounter, instruction, instructionBytes, addressingModeArgs ] );

		// //if ( !instruction.legal ) {
		// //	this._onTextRefresh( true );
		// //	debugger;
		// //}
		
		// // if ( instruction.name === "BRK" ) {
		// // //	this._onTextRefresh( true );
			// // debugger;
		// // }
	// };
	
	
	// Nes.CpuInstructionsWindow = CpuInstructionsWindow;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

(function(){
	"use strict";
	
	// Keyboard key map taken from http://stackoverflow.com/questions/1772179/get-character-value-from-keycode-in-javascript-then-trim
	var keyboardMap = ["","","","CANCEL","","","HELP","","BACK_SPACE","TAB","","","CLEAR","ENTER","RETURN","","SHIFT","CONTROL","ALT","PAUSE","CAPS_LOCK","KANA","EISU","JUNJA","FINAL","HANJA","","ESCAPE","CONVERT","NONCONVERT","ACCEPT","MODECHANGE","SPACE","PAGE_UP","PAGE_DOWN","END","HOME","LEFT","UP","RIGHT","DOWN","SELECT","PRINT","EXECUTE","PRINTSCREEN","INSERT","DELETE","","0","1","2","3","4","5","6","7","8","9","COLON","SEMICOLON","LESS_THAN","EQUALS","GREATER_THAN","QUESTION_MARK","AT","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","WIN","","CONTEXT_MENU","","SLEEP","NUMPAD0","NUMPAD1","NUMPAD2","NUMPAD3","NUMPAD4","NUMPAD5","NUMPAD6","NUMPAD7","NUMPAD8","NUMPAD9","MULTIPLY","ADD","SEPARATOR","SUBTRACT","DECIMAL","DIVIDE","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","F13","F14","F15","F16","F17","F18","F19","F20","F21","F22","F23","F24","","","","","","","","","NUM_LOCK","SCROLL_LOCK","WIN_OEM_FJ_JISHO","WIN_OEM_FJ_MASSHOU","WIN_OEM_FJ_TOUROKU","WIN_OEM_FJ_LOYA","WIN_OEM_FJ_ROYA","","","","","","","","","","CIRCUMFLEX","EXCLAMATION","DOUBLE_QUOTE","HASH","DOLLAR","PERCENT","AMPERSAND","UNDERSCORE","OPEN_PAREN","CLOSE_PAREN","ASTERISK","PLUS","PIPE","HYPHEN_MINUS","OPEN_CURLY_BRACKET","CLOSE_CURLY_BRACKET","TILDE","","","","","VOLUME_MUTE","VOLUME_DOWN","VOLUME_UP","","","SEMICOLON","EQUALS","COMMA","MINUS","PERIOD","SLASH","BACK_QUOTE","","","","","","","","","","","","","","","","","","","","","","","","","","","OPEN_BRACKET","BACK_SLASH","CLOSE_BRACKET","QUOTE","","META","ALTGR","","WIN_ICO_HELP","WIN_ICO_00","","WIN_ICO_CLEAR","","","WIN_OEM_RESET","WIN_OEM_JUMP","WIN_OEM_PA1","WIN_OEM_PA2","WIN_OEM_PA3","WIN_OEM_WSCTRL","WIN_OEM_CUSEL","WIN_OEM_ATTN","WIN_OEM_FINISH","WIN_OEM_COPY","WIN_OEM_AUTO","WIN_OEM_ENLW","WIN_OEM_BACKTAB","ATTN","CRSEL","EXSEL","EREOF","PLAY","ZOOM","","PA1","WIN_OEM_CLEAR",""];
	var _open = null;
	
	
	var keyCodeToName = function( kc ) {
		if ( kc < keyboardMap.length ) {
			return keyboardMap[ kc ];
		}
		return '';
	};
	
	
	var KeyboardRemapper = function( app ) {

		var that = this;
		this._app = app;
		this._keysAssigned = [];
		this._waitingPress = false;
		this._waitingPlayerId = 0;
		this._waitingPressKey = '';
		this._contentsDiv = $( "#keyboardRemapperDialog_contents" );
		this._existingKeysContents = $( "#keyboardRemapperSetKeyDialog_existingKeysContents" );
		
		this._dialog = $( "#keyboardRemapperDialog" ).dialog({
			'autoOpen': false,
			'title': 'Control mapping',
			'height': 450,
			'width': 325,
			'modal': true,
			'buttons': {
				'Close': function() {
					that._dialog.dialog( "close" );
				}
			},
			'close': function() {
				that._onClose();
			}
		});
		
		this._setKeyDialog = $( "#keyboardRemapperSetKeyDialog" ).dialog({
			'dialogClass': "no-close",
			'draggable': false,
			'autoOpen': false,
			'height': 200,
			'minHeight': 200,
			'width': 400,
			'minWidth': 400,
			'modal': true,
			'resizable': false,
			'buttons': {
				'OK': function() {
					that._onKeySetApplyClick();
				},
				'Close': function() {
					that._setKeyDialog.dialog( "close" );
				}
			},
			'close': function() {
				that._waitingPress = false;
			}
		});
		
		this._setKeyDialogContents = $( "#keyboardRemapperSetKeyDialog_contents" );

		$('.keyboardMap')['maphilight']();

		window.addEventListener( 'keydown', function( event ) { that._onDocumentKeypress( event, true ); }, false );
		window.addEventListener( 'keyup', function( event ) { that._onDocumentKeypress( event, false ); }, false );
	};
	
	KeyboardRemapper.prototype._keyArrayToHtml = function( keysArray ) {
	
		var str = keysArray.map( function( kc ) { return keyCodeToName( kc ); } ).join( ' ' );
		if ( str.length === 0 ) {
			str = '&lt;NONE&gt;';
		}
		return str;
	};
	
	
	KeyboardRemapper.prototype._onDocumentKeypress = function( event, pressed ) {
		
		if ( this._waitingPress ) {
			if ( pressed ) {
				var kc = Number( event.keyCode );
				if ( this._keysAssigned.indexOf( kc ) < 0 ) {
					this._keysAssigned.push( kc );
					this._setKeyDialogContents[0].innerHTML = '<p>New keys: ' + this._keyArrayToHtml( this._keysAssigned ) + '</p>';
				}
			}
		}
	};
	
	
	KeyboardRemapper.prototype._keyCodeToString = function( keyCode ) {
		return keyCode.toString();
	};
	
	
	KeyboardRemapper.prototype.show = function() {
	
		_open = this;
		this._app.pause( true );
		this._dialog.dialog( "open" );
	};
	
	
	KeyboardRemapper.prototype._onClose = function() {
	
		this._app.pause( false );
	};
	
	
	KeyboardRemapper.prototype._onSetKeyClick = function( playerId, keyName ) {
		
		var id = JOYPAD_NAME_TO_ID( keyName );
		this._waitingPressKey = id;
		this._waitingPress = true;
		this._waitingPlayerId = playerId;
		this._keysAssigned.length = 0;
		this._setKeyDialogContents[0].innerHTML = '<p>New keys:</p>';
		var existingKeys = this._app._input.getKeyBindings( playerId, id );
		
		this._existingKeysContents[0].innerHTML = '<p>Current keys: ' + this._keyArrayToHtml( existingKeys ) + '</p>';
		this._setKeyDialog.dialog('option', 'title', 'Player ' + ( playerId + 1 ) + ': Press keys to assign to ' + keyName );
		this._setKeyDialog.dialog( "open" );
	};
	
	
	KeyboardRemapper.prototype._onKeySetApplyClick = function() {
		
		this._app._input.saveKeyBindings( this._waitingPlayerId, this._waitingPressKey, this._keysAssigned );
		this._setKeyDialog.dialog( "close" );
	};
	
	
	var keyboardRemapperDialog_onsetkeyclick = function( playerId, keyName ) {

		_open._onSetKeyClick( playerId, keyName );
	};


	
	Gui.KeyboardRemapper = KeyboardRemapper;
	Gui[ 'keyboardRemapperDialog_onsetkeyclick' ] = keyboardRemapperDialog_onsetkeyclick;

}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

var PPU_TICKS_PER_SCANLINE = 341;
var MASTER_CYCLES_PER_PPU = 5;
var MASTER_CYCLES_PER_SCANLINE = PPU_TICKS_PER_SCANLINE * MASTER_CYCLES_PER_PPU;

var CPU_RESET_ADDRESS = 0xFFFC;
var CPU_IRQ_ADDRESS = 0xFFFE;
var CPU_NMI_ADDRESS = 0xFFFA;

var SCREEN_WIDTH = 256;
var SCREEN_HEIGHT = 240;

	
var IS_INT_BETWEEN = function( offset, min, max ) {
	return min <= offset && offset < max;
};


var ZERO_PAD = function(n, width, z) {
	z = z || '0';
	n = n + '';
	return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
};


var ZERO_PAD_HEX = function(n, width, z) {
	return ZERO_PAD( n.toString( 16 ), width, z );
};

var g_DefaultColourEncoding = 'NTSC';

var COLOUR_ENCODING_NAME = "";
var COLOUR_ENCODING_REFRESHRATE = 0.0;
var COLOUR_ENCODING_MTC_PER_CPU = 0;
var COLOUR_ENCODING_VBLANK_SCANLINES = 0;
var COLOUR_ENCODING_FRAME_SCANLINES = 0;
var COLOUR_ENCODING_VBLANK_MTC = 0;
var COLOUR_ENCODING_FRAME_MTC = 0;


var setColourEncodingType = function( name ) {

	if ( name === 'PAL' ) {
		COLOUR_ENCODING_NAME = "PAL";
		COLOUR_ENCODING_REFRESHRATE = 50.0;
		COLOUR_ENCODING_MTC_PER_CPU = 16;
		COLOUR_ENCODING_VBLANK_SCANLINES = 70;
		COLOUR_ENCODING_FRAME_SCANLINES = 312;
	} else {
		COLOUR_ENCODING_NAME = "NTSC";
		COLOUR_ENCODING_REFRESHRATE = 60.1;
		COLOUR_ENCODING_MTC_PER_CPU = 15;
		COLOUR_ENCODING_VBLANK_SCANLINES = 20;
		COLOUR_ENCODING_FRAME_SCANLINES = 262;
	}
	
	COLOUR_ENCODING_VBLANK_MTC = COLOUR_ENCODING_VBLANK_SCANLINES * MASTER_CYCLES_PER_SCANLINE;
	COLOUR_ENCODING_FRAME_MTC = COLOUR_ENCODING_FRAME_SCANLINES * MASTER_CYCLES_PER_SCANLINE;
};


setColourEncodingType( g_DefaultColourEncoding );

var PPU_MIRRORING_HORIZONTAL = 0;
var PPU_MIRRORING_VERTICAL = 1;
var PPU_MIRRORING_FOURSCREEN = 2;
var PPU_MIRRORING_SINGLESCREEN_NT0 = 3;
var PPU_MIRRORING_SINGLESCREEN_NT1 = 4;


Nes.mirroringMethodToString = function( method ) {
	switch ( method ) {
		case PPU_MIRRORING_HORIZONTAL: // default
			return 'horizontal';
		case PPU_MIRRORING_VERTICAL:
			return 'vertical';
		case PPU_MIRRORING_FOURSCREEN:
			return 'fourscreen';
		case PPU_MIRRORING_SINGLESCREEN_NT0:
			return 'singlescreen 0';
		case PPU_MIRRORING_SINGLESCREEN_NT1:
			return 'singlescreen 1';
	}
	return '';
};


var JOYPAD_A = 0;
var JOYPAD_B = 1;
var JOYPAD_SELECT = 2;
var JOYPAD_START = 3;
var JOYPAD_UP = 4;
var JOYPAD_DOWN = 5;
var JOYPAD_LEFT = 6;
var JOYPAD_RIGHT = 7;

var JOYPAD_NAME_TO_ID = function( name ) {
	if ( name === 'UP' ) { return JOYPAD_UP; }
	else if ( name === 'DOWN' ) { return JOYPAD_DOWN; }
	else if ( name === 'LEFT' ) { return JOYPAD_LEFT; }
	else if ( name === 'RIGHT' ) { return JOYPAD_RIGHT; }
	else if ( name === 'A' ) { return JOYPAD_A; }
	else if ( name === 'B' ) { return JOYPAD_B; }
	else if ( name === 'SELECT' ) { return JOYPAD_SELECT; }
	else if ( name === 'START' ) { return JOYPAD_START; }
	else { throw new Error( "JOYPAD_NAME_TO_ID: Invalid parameter" ); }
};


var JOYPAD_ID_TO_NAME = function( id ) {
	if ( id === JOYPAD_UP ) { return 'UP'; }
	else if ( id === JOYPAD_DOWN ) { return 'DOWN'; }
	else if ( id === JOYPAD_LEFT ) { return 'LEFT'; }
	else if ( id === JOYPAD_RIGHT ) { return 'RIGHT'; }
	else if ( id === JOYPAD_A ) { return 'A'; }
	else if ( id === JOYPAD_B ) { return 'B'; }
	else if ( id === JOYPAD_SELECT ) { return 'SELECT'; }
	else if ( id === JOYPAD_START ) { return 'START'; }
	else { throw new Error( "JOYPAD_ID_TO_NAME: Invalid parameter " + id ); }
};



/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

var syncEvent = function( name, tickCount, callback ) {
	this.name = name;
	this.tickCount = tickCount;
	this.callback = callback;
};


var synchroniser = function( mainboard ) {
	var that = this;
	this.mainboard = mainboard;
	this.mainboard.connect( 'reset', function( cold ) { that.reset( cold ); } );
	this.cpu = mainboard.cpu;
	this.cpuMtc = 0;
	this._lastSynchronisedMtc = 0;
	this._isSynchronising = false;
	this._newEventInserted = false;
	this._eventBus = new Nes.EventBus();
	this._cpuMTCatEndOfInstruction = new Int32Array( 8 ); // Array of ppu MTC counts which the last X instructions have ended on.
	this._cpuMTCatEndOfInstructionIndex = 0; // This is for determining if an NMI trigger should delay by an instruction or not.
	
	this._events = [];
	this._objects = [];
};


synchroniser.prototype.reset = function( cold ) {
	this.cpuMtc = 0;
	this._lastSynchronisedMtc = 0;
	this._cpuMTCatEndOfInstructionIndex = 0;
	this._isSynchronising = false;
	this._newEventInserted = false;
};


synchroniser.prototype.connect = function( name, callback ) {
	this._eventBus.connect( name, callback );
};


synchroniser.prototype.changeEventTime = function( eventId, tickCount ) {

	var obj = this._getEvent( eventId );
	obj.tickCount = tickCount;
	this._executeCallbackIfSynchronising( obj );
	this._newEventInserted = true;
};


synchroniser.prototype._removeEvent = function( name ) {

	for ( var i=0; i<this._events.length; ++i ) {
		var ev = this._events[i];
		if ( ev.name === name ) {
			return this._events.splice( i, 1 )[0];
		}
	}
	return null;
};


synchroniser.prototype._getEvent = function( eventId ) {

	return this._events[ eventId ];
};


synchroniser.prototype.addEvent = function( name, tickCount, callback ) {

	this._removeEvent( name );
	var obj = new syncEvent( name, tickCount, callback );
	this._executeCallbackIfSynchronising( obj );
	this._events.push( obj );
	this._newEventInserted = true;
	return this._events.length - 1;
};


synchroniser.prototype._executeCallbackIfSynchronising = function( event ) {
	if ( this._isSynchronising && event.tickCount >= 0 ) {
		// if a new event has been added during synchronisation, execute it immediately if it is due
		if ( this._lastSynchronisedMtc < event.tickCount && this._currentSyncValue >= event.tickCount ) {
			event.callback( event.tickCount );
		}
	}
};


synchroniser.prototype.addObject = function( name, obj ) {

	this._objects.push( { name: name, object: obj, lastSynchronisedTickCount: 0 } );
};


synchroniser.prototype.synchronise = function() {

	var frameEnd = COLOUR_ENCODING_FRAME_MTC;
	
	if ( this._isSynchronising ) {
		//debugger;
		throw new Error( "Cannot call synchroniser.prototype.synchronise when in synchronisation phase" );
	}

	var syncTo = this.getCpuMTC();

	// work out when the next scheduled event is to occur. Then synchronise all objects to that event, then execute the event.
	// Then move onto the next one.
	var objIndex = 0;
	var keepRunning = true;
	while ( keepRunning ) {
		var nextEventTime = this.getNextEventTime();
		if ( nextEventTime <= syncTo && nextEventTime < frameEnd ) {
			syncTo = nextEventTime;
		} else {
			keepRunning = false; // no more events until requested syncTo value: we can finish the sync loop
			syncTo = Math.min( syncTo, frameEnd );
		}

		if ( this._lastSynchronisedMtc >= syncTo ) {
			return;
		}

		this._isSynchronising = true;
		this._currentSyncValue = syncTo;
		
		for ( objIndex=0; objIndex<this._objects.length; ++objIndex ) {
			// TODO: Objects should be forbidden from calling synchroniser.synchronise() whilst in the synchronise phase - if they
			// want to force a synchronise they should do so using an event
			var obj = this._objects[ objIndex ];
			if ( obj.lastSynchronisedTickCount < syncTo ) {
				obj.object.synchronise( obj.lastSynchronisedTickCount, syncTo );
				obj.lastSynchronisedTickCount = syncTo;
			}
		}
		this._isSynchronising = false;
	
		this._executeEvents( this._lastSynchronisedMtc, syncTo );
		this._lastSynchronisedMtc = syncTo;

		// TODO: this should be an event: do end frame stuff if that time has come
		if ( syncTo >= frameEnd ) {
			for ( objIndex=0; objIndex<this._objects.length; ++objIndex ) {
				this._objects[ objIndex ].object.onEndFrame( syncTo );
				this._objects[ objIndex ].lastSynchronisedTickCount = 0;
			}

			this.cpuMtc -= frameEnd;
			this._lastSynchronisedMtc = 0;
			this._eventBus.invoke( 'frameEnd' );
		}
	}
};


synchroniser.prototype.getNextEventTime = function( currentTime ) {

	var frameEnd = COLOUR_ENCODING_FRAME_MTC;
	currentTime = currentTime || this._lastSynchronisedMtc;
	var closestObj = null;
	for ( var eventIndex=0; eventIndex<this._events.length; ++eventIndex ) {
		var ev = this._events[ eventIndex ];
		if ( ev.tickCount >= 0 && ev.tickCount > currentTime ) {
			if ( closestObj === null || ev.tickCount < closestObj.tickCount ) {
				closestObj = ev;
			}
		}
	}
	return closestObj !== null ? closestObj.tickCount : frameEnd;
};


synchroniser.prototype._executeEvents = function( startTime, endTime ) {

	for ( var eventIndex=0; eventIndex<this._events.length; ++eventIndex ) {
		var ev = this._events[ eventIndex ];
		if ( ev.tickCount >= 0 && ev.tickCount > startTime && ev.tickCount <= endTime ) {
			ev.callback( ev.tickCount );
		}
	}
};


synchroniser.prototype.runCycle = function() {
	
	var nextEventTime = this.getNextEventTime();

	// run cpu
	while ( this.cpuMtc < nextEventTime ) {
		var cpuTicks = this.cpu.handlePendingInterrupts();
		if ( cpuTicks === 0 ) {
			cpuTicks = this.cpu.execute();
		}
		this.mainboard.ppu.handleSpriteTransfer();
		this.cpuMtc += cpuTicks * COLOUR_ENCODING_MTC_PER_CPU;
		 this._cpuMTCatEndOfInstruction[ this._cpuMTCatEndOfInstructionIndex] =  this.cpuMtc ;
		this._cpuMTCatEndOfInstructionIndex = ( this._cpuMTCatEndOfInstructionIndex + 1 ) & 0x7;
		
		if ( this._newEventInserted ) {
			this._newEventInserted = false;
			nextEventTime = this.getNextEventTime();
		}
	}

	// run all other components to the cpu mtc
	this.synchronise( this.cpuMtc );
};


synchroniser.prototype.isPpuTickOnLastCycleOfCpuInstruction = function( ppuCount ) {
	
	for ( var i=0; i<this._cpuMTCatEndOfInstruction.length; ++i ) {
		var cpuCount = this._cpuMTCatEndOfInstruction[ i ];
		if ( cpuCount - COLOUR_ENCODING_MTC_PER_CPU <= ppuCount && cpuCount + MASTER_CYCLES_PER_PPU >= ppuCount ) {
			return true;
		}
	}
	return false;
};


synchroniser.prototype.advanceCpuMTC = function( advance ) {
	this.cpuMtc += advance;
};


synchroniser.prototype.getCpuMTC = function() {
	return ( this.cpuMtc + this.cpu.getSubCycle() * COLOUR_ENCODING_MTC_PER_CPU ) | 0;
};


synchroniser.prototype.saveState = function() {
	// TODO: save event data in state, maybe not necessary as save state is done on the end of a frame?
	var data = {};
	data.cpuMtc = this.cpuMtc;
	data._lastSynchronisedMtc = this._lastSynchronisedMtc;
	return data;
};


synchroniser.prototype.loadState = function( state ) {
	this.cpuMtc = state.cpuMtc;
	this._lastSynchronisedMtc = state._lastSynchronisedMtc;
};


Nes.synchroniser = synchroniser;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

////////////////////

var joypad = function() {
	this._currentState = 0;
	this._strobedState = 0;
	this._strobeByte = 0;
	this._readCount = 0;
};


joypad.prototype.writeToRegister = function( offset, data ) {

	var firstBit = data & 1;
	if ( this._strobeByte === 1 || firstBit === 1 ) {
		this._strobeByte = firstBit | 0;
		this._strobedState = this._currentState;
		this._readCount = 0;
	}
};


joypad.prototype.readFromRegister = function( offset ) {

	var ret = 0;
	if ( this._strobeByte === 1 ) {
		this._strobedState = this._currentState;
		this._readCount = 0;
		ret = ( this._strobedState & 1 ) | 0;
	} else {
		ret = ( ( this._strobedState >> this._readCount ) & 1 ) | 0;
		this._readCount++;
		ret |= 0x40;
	}
	return ret | 0;
};


joypad.prototype._getDuplicateMask = function( buttonIndex ) {

	// disallow pressing up+down and left+right at the same time - always keep the button that is already pressed
	switch ( buttonIndex ) {
		case 4: // UP
			return 0xDF; // ~( 0x20 );
		case 5: // DOWN
			return 0xEF; // ~( 0x10 );
		case 6: // LEFT
			return 0x7F; // ~( 0x80 );
		case 7: // RIGHT
			return 0xBF; // ~( 0x40 );
	}
	return 0xFF;
};


joypad.prototype.pressButton = function( buttonIndex, pressed ) {

	if ( pressed ) {
		this._currentState |= ( 1 << buttonIndex );
		this._currentState &= this._getDuplicateMask( buttonIndex ); // this prevents up+down and left+right being pressed
	} else {
		this._currentState &= 0xFF ^ ( 1 << buttonIndex );
	}
};


joypad.prototype.saveState = function() {
	var data = {};
	data._currentState = this._currentState;
	data._strobedState = this._strobedState;
	data._strobeByte = this._strobeByte;
	data._readCount = this._readCount;
	return data;
};


joypad.prototype.loadState = function( state ) {
	this._currentState = state._currentState;
	this._strobedState = state._strobedState;
	this._readCount = state._readCount;
	this._strobeByte = state._strobeByte;
};

Nes.joypad = joypad;






var inputdevicebus = function() {
	//this.devices = new Array( 2 );
	
	this.j1 = new Nes.joypad();
	this.j2 = new Nes.joypad();
};


inputdevicebus.prototype.getJoypad = function( index ) {
	
	switch ( index ) {
	case 0:
		return this.j1;
	case 1:
		return this.j2;
	default:
		return null;
	}
};


inputdevicebus.prototype.writeToRegister = function( offset, data ) {
	switch ( offset )
	{
	case 0x4016:
		this.j1.writeToRegister( offset, data );
		break;
	case 0x4017:
		this.j2.writeToRegister( offset, data );
		break;
	}
};


inputdevicebus.prototype.readFromRegister = function( offset ) {
	var ret = 0;
	switch ( offset )
	{
	case 0x4016:
		ret = this.j1.readFromRegister( offset ) | 0;
		break;
	case 0x4017:
		ret = this.j2.readFromRegister( offset ) | 0;
		break;
	}
	return ret;
};


Nes.inputdevicebus = inputdevicebus;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

var gppu;
var gmapper;
var ginput;
var gapu;

var memory = function( mainboard ) {
	
	var that = this;
	this.mainboard = mainboard;
	this.mainboard.connect( 'reset', function( cold ) { that.reset( cold ); } );
	this.ramPage = new Int32Array( 0x800 );
};


memory.prototype.reset = function( cold ) {
	if ( cold ) {
		// these memory locations are set to various values on power-up
		for ( var i=0; i<this.ramPage.length; ++i )
			this.ramPage[ i ] = 0xFF;
		this.ramPage[0x0008] = 0xF7;
		this.ramPage[0x0009] = 0xEF;
		this.ramPage[0x000a] = 0xDF;
		this.ramPage[0x000f] = 0xBF;
	}
	gppu = window.ppu;
	gmapper = this.mainboard.cart.memoryMapper;
	ginput = this.mainboard.inputdevicebus;
	gapu = this.mainboard.apu;
};
	

memory.prototype.read8 = function( offset ) {
	//ASSERT_NUMBER( offset );
	return this._properRead8( offset & 0xFFFF ) & 0xFF;
};


memory.prototype._readRegister4000 = function( offset ) {
	var offset4000 = offset & 0x1FE0;
	if ( offset4000 === 0 ) { // testing top 11 bits - if it's zero it's between 4000 -> 4020
		if ( offset === 0x4016 || offset === 0x4017 ) {
//				return 0;
			return ginput.readFromRegister( offset );
		} else {
			return 0;
//			return gapu.readFromRegister( offset ) | 0;
		}
	} else {
		return gmapper.read8EXRam( offset );
//			return 0;
	}
	return 0;
};


memory.prototype._properRead8 = function( offset ) {
	// Faster: Top 3 bits are equal to 0x2000 for inbetween 2000 -> 4000, equal to 0 for < 2000 and so on
	var topbits = offset & 0xE000;
	var bot3 = offset & 0x7;
	var rampageOffset = offset & 0x7FF;
	switch ( topbits ) {
		case 0: // address is within RAM boundaries, account for 4x mirroring
			return  this.ramPage[ rampageOffset ];
		case 0x2000: // IS_INT_BETWEEN( offset, 0x2000, 0x4000 )
			return gppu.readFromRegister( bot3 );
		case 0x4000:
			return this._readRegister4000( offset );
		case 0x6000: // IS_INT_BETWEEN( offset, 0x6000, 0x8000 )
			return gmapper.read8SRam( offset );
		default: // IS_INT_BETWEEN( offset, 0x8000, 0x10000 )
			return gmapper.read8PrgRom( offset );
	}
	return 0;
};


memory.prototype.read16NoZeroPageWrap = function( offset ) {

	return this.read8( offset ) | ( this.read8( offset + 1 ) << 8 );
};

	
memory.prototype.write8 = function( offset, data ) {

	switch ( offset & 0xE000 ) {
		case 0: // IS_INT_BETWEEN( offset, 0, 0x2000 ) address is within RAM boundaries, account for 4x mirroring
			 this.ramPage[ offset & 0x7FF] =  data ;
			break;
		case 0x2000: // IS_INT_BETWEEN( offset, 0x2000, 0x4000 )
			this.mainboard.ppu.writeToRegister( ( offset & 0x07 ), data );
			break;
		case 0x4000:
			{
				if ( ( offset & 0x1FE0 ) === 0 ) { // testing top 11 bits - if it's zero it's between 4000 -> 4020
					switch ( offset )
					{
						case 0x4014: // sprite DMA access
							this.mainboard.ppu.writeToSpriteDMARegister( data );
							break;
						case 0x4016: // input
						case 0x4017:
							this.mainboard.inputdevicebus.writeToRegister( offset, data );
							break;
					}
					// APU (write input 4016 + 4017 to APU as well) <-- is that right??
					this.mainboard.apu.writeToRegister( offset, data );
				} else { // IS_INT_BETWEEN( offset, 0x4020, 0x6000 )
					this.mainboard.cart.memoryMapper.write8EXRam( offset, data );
				}
			}
			break;
		case 0x6000: // IS_INT_BETWEEN( offset, 0x6000, 0x8000 )
			this.mainboard.cart.memoryMapper.write8SRam( offset, data );
			break;
		default:
		case 0x8000: // IS_INT_BETWEEN( offset, 0x8000, 0x10000 )
			this.mainboard.cart.memoryMapper.write8PrgRom( offset, data );
			break;
	}
};


memory.prototype.saveState = function() {
	return { ramPage: Nes.uintArrayToString( this.ramPage ) };
};


memory.prototype.loadState = function( state ) {

	this.ramPage = Nes.stringToUintArray( state.ramPage );
};



Nes.memory = memory;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

// This file has been automatically generated by the cpuCoreBuilder.js tool

"use strict";

var instructions = [];

function BRK_NONE_0( cpu, memory ) {
	var cyclesTaken = 7;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	// dummy read of opcode after brk
	memory.read8( cpu.getPC() );
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( cpu.getPC() >> 8 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (cpu.programCounter) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( cpu.statusRegToByte() | 0x30 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.setPC( cpu.read16FromMemNoWrap( CPU_IRQ_ADDRESS ) );
	cpu.setInterrupt( true );
	return cyclesTaken;
};
instructions[ 0 ] = BRK_NONE_0;
function ORA_INDIRECTX_1( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 1 ] = ORA_INDIRECTX_1;
function HLT_NONE_2( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 2 ] = HLT_NONE_2;
function ASO_INDIRECTX_3( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 3 ] = ASO_INDIRECTX_3;
function SKB_ZEROPAGE_4( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 4 ] = SKB_ZEROPAGE_4;
function ORA_ZEROPAGE_5( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 5 ] = ORA_ZEROPAGE_5;
function ASL_ZEROPAGE_6( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 6 ] = ASL_ZEROPAGE_6;
function ASO_ZEROPAGE_7( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 7 ] = ASO_ZEROPAGE_7;
function PHP_NONE_8( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( cpu.statusRegToByte() | 0x10 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	return cyclesTaken;
};
instructions[ 8 ] = PHP_NONE_8;
function ORA_IMMEDIATE_9( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA |= readInValue & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 9 ] = ORA_IMMEDIATE_9;
function ASL_ACCUMULATOR_10( cpu, memory ) {
	var cyclesTaken = 2;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry( ( readInValue & 0x80 ) > 0 );
	var result = ( ( readInValue & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions[ 10 ] = ASL_ACCUMULATOR_10;
function ANC_IMMEDIATE_11( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.setCarry( cpu.getSign() );
	return cyclesTaken;
};
instructions[ 11 ] = ANC_IMMEDIATE_11;
function SKW_ABSOLUTE_12( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 12 ] = SKW_ABSOLUTE_12;
function ORA_ABSOLUTE_13( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 13 ] = ORA_ABSOLUTE_13;
function ASL_ABSOLUTE_14( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 14 ] = ASL_ABSOLUTE_14;
function ASO_ABSOLUTE_15( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 15 ] = ASO_ABSOLUTE_15;
function BPL_RELATIVE_16( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = !cpu.getSign();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 16 ] = BPL_RELATIVE_16;
function ORA_INDIRECTY_17( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 17 ] = ORA_INDIRECTY_17;
function HLT_NONE_18( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 18 ] = HLT_NONE_18;
function ASO_INDIRECTY_19( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 19 ] = ASO_INDIRECTY_19;
function SKB_ZEROPAGEX_20( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 20 ] = SKB_ZEROPAGEX_20;
function ORA_ZEROPAGEX_21( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 21 ] = ORA_ZEROPAGEX_21;
function ASL_ZEROPAGEX_22( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 22 ] = ASL_ZEROPAGEX_22;
function ASO_ZEROPAGEX_23( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 23 ] = ASO_ZEROPAGEX_23;
function CLC_NONE_24( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry( false );
	return cyclesTaken;
};
instructions[ 24 ] = CLC_NONE_24;
function ORA_ABSOLUTEY_25( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 25 ] = ORA_ABSOLUTEY_25;
function NOP_NONE_26( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions[ 26 ] = NOP_NONE_26;
function ASO_ABSOLUTEY_27( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 27 ] = ASO_ABSOLUTEY_27;
function SKW_ABSOLUTEX_28( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 28 ] = SKW_ABSOLUTEX_28;
function ORA_ABSOLUTEX_29( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 29 ] = ORA_ABSOLUTEX_29;
function ASL_ABSOLUTEX_30( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 30 ] = ASL_ABSOLUTEX_30;
function ASO_ABSOLUTEX_31( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 31 ] = ASO_ABSOLUTEX_31;
function JSR_IMMEDIATE16_32( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.getPC() - 1;
	if ( result < 0 )
		result = 0xFFFF;
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( result >> 8 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (result) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	cpu.setPC( ( readInValue ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 32 ] = JSR_IMMEDIATE16_32;
function AND_INDIRECTX_33( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 33 ] = AND_INDIRECTX_33;
function HLT_NONE_34( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 34 ] = HLT_NONE_34;
function RLA_INDIRECTX_35( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 35 ] = RLA_INDIRECTX_35;
function BIT_ZEROPAGE_36( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	if ( ( readInValue & 0xE007 ) === 0x2002 ) { cpu.mainboard.ppu.bitOperationHappening(); } // BIT 2002 optimisation
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.setSign( ( ( operationModeData& 0xFF ) & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & ( operationModeData & 0xFF ) & 0xFF ) === 0 );
	cpu.setOverflow( ( operationModeData & 0x40) > 0 );	// Copy bit 6 to OVERFLOW flag.
	return cyclesTaken;
};
instructions[ 36 ] = BIT_ZEROPAGE_36;
function AND_ZEROPAGE_37( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 37 ] = AND_ZEROPAGE_37;
function ROL_ZEROPAGE_38( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 38 ] = ROL_ZEROPAGE_38;
function RLA_ZEROPAGE_39( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 39 ] = RLA_ZEROPAGE_39;
function PLP_NONE_40( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === true;
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	var temp = memory.read8( 0x100 + cpu.regS );
	cpu.statusRegFromByte( temp );
	cpu.setBreak( true ); // TODO: this was true before in original port, put it back for some reason?
	cpu.setUnused( true );
	if ( cpu.waitOneInstructionAfterCli )
		cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === false;
	return cyclesTaken;
};
instructions[ 40 ] = PLP_NONE_40;
function AND_IMMEDIATE_41( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= ( readInValue & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 41 ] = AND_IMMEDIATE_41;
function ROL_ACCUMULATOR_42( cpu, memory ) {
	var cyclesTaken = 2;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var result = ( (readInValue & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions[ 42 ] = ROL_ACCUMULATOR_42;
function ANC_IMMEDIATE_43( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.setCarry( cpu.getSign() );
	return cyclesTaken;
};
instructions[ 43 ] = ANC_IMMEDIATE_43;
function BIT_ABSOLUTE_44( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	if ( ( readInValue & 0xE007 ) === 0x2002 ) { cpu.mainboard.ppu.bitOperationHappening(); } // BIT 2002 optimisation
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.setSign( ( ( operationModeData& 0xFF ) & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & ( operationModeData & 0xFF ) & 0xFF ) === 0 );
	cpu.setOverflow( ( operationModeData & 0x40) > 0 );	// Copy bit 6 to OVERFLOW flag.
	return cyclesTaken;
};
instructions[ 44 ] = BIT_ABSOLUTE_44;
function AND_ABSOLUTE_45( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 45 ] = AND_ABSOLUTE_45;
function ROL_ABSOLUTE_46( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 46 ] = ROL_ABSOLUTE_46;
function RLA_ABSOLUTE_47( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 47 ] = RLA_ABSOLUTE_47;
function BMI_RELATIVE_48( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = cpu.getSign();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 48 ] = BMI_RELATIVE_48;
function AND_INDIRECTY_49( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 49 ] = AND_INDIRECTY_49;
function HLT_NONE_50( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 50 ] = HLT_NONE_50;
function RLA_INDIRECTY_51( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 51 ] = RLA_INDIRECTY_51;
function SKB_ZEROPAGEX_52( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 52 ] = SKB_ZEROPAGEX_52;
function AND_ZEROPAGEX_53( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 53 ] = AND_ZEROPAGEX_53;
function ROL_ZEROPAGEX_54( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 54 ] = ROL_ZEROPAGEX_54;
function RLA_ZEROPAGEX_55( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 55 ] = RLA_ZEROPAGEX_55;
function SEC_NONE_56( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry( true );
	return cyclesTaken;
};
instructions[ 56 ] = SEC_NONE_56;
function AND_ABSOLUTEY_57( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 57 ] = AND_ABSOLUTEY_57;
function NOP_NONE_58( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions[ 58 ] = NOP_NONE_58;
function RLA_ABSOLUTEY_59( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 59 ] = RLA_ABSOLUTEY_59;
function SKW_ABSOLUTEX_60( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 60 ] = SKW_ABSOLUTEX_60;
function AND_ABSOLUTEX_61( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 61 ] = AND_ABSOLUTEX_61;
function ROL_ABSOLUTEX_62( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 62 ] = ROL_ABSOLUTEX_62;
function RLA_ABSOLUTEX_63( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 63 ] = RLA_ABSOLUTEX_63;
function RTI_NONE_64( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	// dummy read
	cpu.incrementSubcycle();
	memory.read8( cpu.getPC() );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	var temp = memory.read8( 0x100 + cpu.regS );
	cpu.statusRegFromByte( temp );
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	cpu.programCounter = memory.read8( 0x100 + cpu.regS );
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	temp = memory.read8( 0x100 + cpu.regS );
	cpu.programCounter |= ( temp & 0xFF ) << 8;
	cpu.setBreak( true );
	cpu.setUnused( true );
	return cyclesTaken;
};
instructions[ 64 ] = RTI_NONE_64;
function EOR_INDIRECTX_65( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 65 ] = EOR_INDIRECTX_65;
function HLT_NONE_66( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 66 ] = HLT_NONE_66;
function LSE_INDIRECTX_67( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 67 ] = LSE_INDIRECTX_67;
function SKB_ZEROPAGE_68( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 68 ] = SKB_ZEROPAGE_68;
function EOR_ZEROPAGE_69( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 69 ] = EOR_ZEROPAGE_69;
function LSR_ZEROPAGE_70( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 70 ] = LSR_ZEROPAGE_70;
function LSE_ZEROPAGE_71( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 71 ] = LSE_ZEROPAGE_71;
function PHA_NONE_72( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (cpu.regA) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	return cyclesTaken;
};
instructions[ 72 ] = PHA_NONE_72;
function EOR_IMMEDIATE_73( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA = ( cpu.regA ^ ( readInValue & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 73 ] = EOR_IMMEDIATE_73;
function LSR_ACCUMULATOR_74( cpu, memory ) {
	var cyclesTaken = 2;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry((readInValue & 0x01) > 0);
	var result = ( readInValue & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions[ 74 ] = LSR_ACCUMULATOR_74;
function ALR_IMMEDIATE_75( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue;
	cpu.setCarry((cpu.regA & 0x01) > 0);
	cpu.regA = ( cpu.regA >> 1 ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 75 ] = ALR_IMMEDIATE_75;
function JMP_IMMEDIATE16_76( cpu, memory ) {
	var cyclesTaken = 3;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.setPC( ( readInValue ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 76 ] = JMP_IMMEDIATE16_76;
function EOR_ABSOLUTE_77( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 77 ] = EOR_ABSOLUTE_77;
function LSR_ABSOLUTE_78( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 78 ] = LSR_ABSOLUTE_78;
function LSE_ABSOLUTE_79( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 79 ] = LSE_ABSOLUTE_79;
function BVC_RELATIVE_80( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = !cpu.getOverflow();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 80 ] = BVC_RELATIVE_80;
function EOR_INDIRECTY_81( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 81 ] = EOR_INDIRECTY_81;
function HLT_NONE_82( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 82 ] = HLT_NONE_82;
function LSE_INDIRECTY_83( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 83 ] = LSE_INDIRECTY_83;
function SKB_ZEROPAGEX_84( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 84 ] = SKB_ZEROPAGEX_84;
function EOR_ZEROPAGEX_85( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 85 ] = EOR_ZEROPAGEX_85;
function LSR_ZEROPAGEX_86( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 86 ] = LSR_ZEROPAGEX_86;
function LSE_ZEROPAGEX_87( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 87 ] = LSE_ZEROPAGEX_87;
function CLI_NONE_88( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === true;
	cpu.setInterrupt( false );
	return cyclesTaken;
};
instructions[ 88 ] = CLI_NONE_88;
function EOR_ABSOLUTEY_89( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 89 ] = EOR_ABSOLUTEY_89;
function NOP_NONE_90( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions[ 90 ] = NOP_NONE_90;
function LSE_ABSOLUTEY_91( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 91 ] = LSE_ABSOLUTEY_91;
function SKW_ABSOLUTEX_92( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 92 ] = SKW_ABSOLUTEX_92;
function EOR_ABSOLUTEX_93( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 93 ] = EOR_ABSOLUTEX_93;
function LSR_ABSOLUTEX_94( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 94 ] = LSR_ABSOLUTEX_94;
function LSE_ABSOLUTEX_95( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 95 ] = LSE_ABSOLUTEX_95;
function RTS_NONE_96( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	// dummy read
	cpu.incrementSubcycle();
	memory.read8( cpu.getPC() );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	cpu.programCounter = memory.read8( 0x100 + cpu.regS );
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	var temp = memory.read8( 0x100 + cpu.regS );
	cpu.programCounter |= ( temp & 0xFF ) << 8;
	cpu.incrementSubcycle();
	cpu.programCounter = ( cpu.getPC() + 1 ) & 0xFFFF;
	return cyclesTaken;
};
instructions[ 96 ] = RTS_NONE_96;
function ADC_INDIRECTX_97( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 97 ] = ADC_INDIRECTX_97;
function HLT_NONE_98( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 98 ] = HLT_NONE_98;
function RRA_INDIRECTX_99( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 99 ] = RRA_INDIRECTX_99;
function SKB_ZEROPAGE_100( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 100 ] = SKB_ZEROPAGE_100;
function ADC_ZEROPAGE_101( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 101 ] = ADC_ZEROPAGE_101;
function ROR_ZEROPAGE_102( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 102 ] = ROR_ZEROPAGE_102;
function RRA_ZEROPAGE_103( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 103 ] = RRA_ZEROPAGE_103;
function PLA_NONE_104( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	cpu.regA = memory.read8( 0x100 + cpu.regS );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 104 ] = PLA_NONE_104;
function ADC_IMMEDIATE_105( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = ( readInValue & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( readInValue ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 105 ] = ADC_IMMEDIATE_105;
function ROR_ACCUMULATOR_106( cpu, memory ) {
	var cyclesTaken = 2;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var result = ( (readInValue & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( readInValue & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions[ 106 ] = ROR_ACCUMULATOR_106;
function ARR_IMMEDIATE_107( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue & 0xFF;
	cpu.regA = ( ( cpu.regA >> 1 ) & 0xFF ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( cpu.regA & 0x1 ) > 0 );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.setOverflow( false );
	cpu.setCarry( false )
	switch ( cpu.regA & 0x60 )
	{
	case 0x20: cpu.setOverflow( true ); break;
	case 0x40: cpu.setOverflow( true );
	cpu.setCarry( true ); break;
	case 0x60: cpu.setCarry( true ); break;
	}
	return cyclesTaken;
};
instructions[ 107 ] = ARR_IMMEDIATE_107;
function JMP_INDIRECT_108( cpu, memory ) {
	var cyclesTaken = 5;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.setPC( ( readInValue ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 108 ] = JMP_INDIRECT_108;
function ADC_ABSOLUTE_109( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 109 ] = ADC_ABSOLUTE_109;
function ROR_ABSOLUTE_110( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 110 ] = ROR_ABSOLUTE_110;
function RRA_ABSOLUTE_111( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 111 ] = RRA_ABSOLUTE_111;
function BVS_RELATIVE_112( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = cpu.getOverflow();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 112 ] = BVS_RELATIVE_112;
function ADC_INDIRECTY_113( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 113 ] = ADC_INDIRECTY_113;
function HLT_NONE_114( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 114 ] = HLT_NONE_114;
function RRA_INDIRECTY_115( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 115 ] = RRA_INDIRECTY_115;
function SKB_ZEROPAGEX_116( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 116 ] = SKB_ZEROPAGEX_116;
function ADC_ZEROPAGEX_117( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 117 ] = ADC_ZEROPAGEX_117;
function ROR_ZEROPAGEX_118( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 118 ] = ROR_ZEROPAGEX_118;
function RRA_ZEROPAGEX_119( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 119 ] = RRA_ZEROPAGEX_119;
function SEI_NONE_120( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setInterrupt( true );
	return cyclesTaken;
};
instructions[ 120 ] = SEI_NONE_120;
function ADC_ABSOLUTEY_121( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 121 ] = ADC_ABSOLUTEY_121;
function NOP_NONE_122( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions[ 122 ] = NOP_NONE_122;
function RRA_ABSOLUTEY_123( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 123 ] = RRA_ABSOLUTEY_123;
function SKW_ABSOLUTEX_124( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 124 ] = SKW_ABSOLUTEX_124;
function ADC_ABSOLUTEX_125( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions[ 125 ] = ADC_ABSOLUTEX_125;
function ROR_ABSOLUTEX_126( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 126 ] = ROR_ABSOLUTEX_126;
function RRA_ABSOLUTEX_127( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 127 ] = RRA_ABSOLUTEX_127;
function SKB_IMMEDIATE_128( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 128 ] = SKB_IMMEDIATE_128;
function STA_INDIRECTX_129( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 129 ] = STA_INDIRECTX_129;
function SKB_IMMEDIATE_130( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 130 ] = SKB_IMMEDIATE_130;
function AXS_INDIRECTX_131( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 131 ] = AXS_INDIRECTX_131;
function STY_ZEROPAGE_132( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regY;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 132 ] = STY_ZEROPAGE_132;
function STA_ZEROPAGE_133( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 133 ] = STA_ZEROPAGE_133;
function STX_ZEROPAGE_134( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 134 ] = STX_ZEROPAGE_134;
function AXS_ZEROPAGE_135( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 135 ] = AXS_ZEROPAGE_135;
function DEY_NONE_136( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regY--;
	if ( cpu.regY < 0 )
		cpu.regY = 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 136 ] = DEY_NONE_136;
function SKB_IMMEDIATE_137( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 137 ] = SKB_IMMEDIATE_137;
function TXA_NONE_138( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regA = cpu.regX;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 138 ] = TXA_NONE_138;
function XAA_IMMEDIATE_139( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA = cpu.regX & readInValue;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 139 ] = XAA_IMMEDIATE_139;
function STY_ABSOLUTE_140( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regY;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 140 ] = STY_ABSOLUTE_140;
function STA_ABSOLUTE_141( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 141 ] = STA_ABSOLUTE_141;
function STX_ABSOLUTE_142( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 142 ] = STX_ABSOLUTE_142;
function AXS_ABSOLUTE_143( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 143 ] = AXS_ABSOLUTE_143;
function BCC_RELATIVE_144( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = !cpu.getCarry();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 144 ] = BCC_RELATIVE_144;
function STA_INDIRECTY_145( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 145 ] = STA_INDIRECTY_145;
function HLT_NONE_146( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 146 ] = HLT_NONE_146;
function AXA_INDIRECTY_147( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = ( cpu.regX & cpu.regA ) & 0x7;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 147 ] = AXA_INDIRECTY_147;
function STY_ZEROPAGEX_148( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regY;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 148 ] = STY_ZEROPAGEX_148;
function STA_ZEROPAGEX_149( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 149 ] = STA_ZEROPAGEX_149;
function STX_ZEROPAGEY_150( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 150 ] = STX_ZEROPAGEY_150;
function AXS_ZEROPAGEY_151( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 151 ] = AXS_ZEROPAGEY_151;
function TYA_NONE_152( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regA = cpu.regY;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 152 ] = TYA_NONE_152;
function STA_ABSOLUTEY_153( cpu, memory ) {
	var cyclesTaken = 5;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 153 ] = STA_ABSOLUTEY_153;
function TXS_NONE_154( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regS = cpu.regX;
	return cyclesTaken;
};
instructions[ 154 ] = TXS_NONE_154;
function TAS_ABSOLUTEY_155( cpu, memory ) {
	var cyclesTaken = 5;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.regS = cpu.regX & cpu.regA;
	return cyclesTaken;
};
instructions[ 155 ] = TAS_ABSOLUTEY_155;
function SAY_SAY_156( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.SAYHighByte = memory.read8( ( cpu.getPC() + 2 ) & 0xFFFF );
	address |= ( cpu.SAYHighByte ) << 8;
	var readInValue = ( address + cpu.regX ) & 0xFFFF; // SAY writes to absolute X but needs the high byte of the address to operate on
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = cpu.regY & ( ( cpu.SAYHighByte + 1 ) & 0xFF );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 156 ] = SAY_SAY_156;
function STA_ABSOLUTEX_157( cpu, memory ) {
	var cyclesTaken = 5;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 157 ] = STA_ABSOLUTEX_157;
function XAS_ABSOLUTEY_158( cpu, memory ) {
	var cyclesTaken = 5;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction XAS not implemented");
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions[ 158 ] = XAS_ABSOLUTEY_158;
function AXA_ABSOLUTEY_159( cpu, memory ) {
	var cyclesTaken = 5;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( cpu.regX & cpu.regA ) & 0x7;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 159 ] = AXA_ABSOLUTEY_159;
function LDY_IMMEDIATE_160( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regY = readInValue & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 160 ] = LDY_IMMEDIATE_160;
function LDA_INDIRECTX_161( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 161 ] = LDA_INDIRECTX_161;
function LDX_IMMEDIATE_162( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regX = readInValue & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 162 ] = LDX_IMMEDIATE_162;
function LAX_INDIRECTX_163( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 163 ] = LAX_INDIRECTX_163;
function LDY_ZEROPAGE_164( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 164 ] = LDY_ZEROPAGE_164;
function LDA_ZEROPAGE_165( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 165 ] = LDA_ZEROPAGE_165;
function LDX_ZEROPAGE_166( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 166 ] = LDX_ZEROPAGE_166;
function LAX_ZEROPAGE_167( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 167 ] = LAX_ZEROPAGE_167;
function TAY_NONE_168( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regY = cpu.regA;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 168 ] = TAY_NONE_168;
function LDA_IMMEDIATE_169( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA = readInValue & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 169 ] = LDA_IMMEDIATE_169;
function TAX_NONE_170( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX = cpu.regA;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 170 ] = TAX_NONE_170;
function OAL_IMMEDIATE_171( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regX = cpu.regA = readInValue & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 171 ] = OAL_IMMEDIATE_171;
function LDY_ABSOLUTE_172( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 172 ] = LDY_ABSOLUTE_172;
function LDA_ABSOLUTE_173( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 173 ] = LDA_ABSOLUTE_173;
function LDX_ABSOLUTE_174( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 174 ] = LDX_ABSOLUTE_174;
function LAX_ABSOLUTE_175( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 175 ] = LAX_ABSOLUTE_175;
function BCS_RELATIVE_176( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = cpu.getCarry();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 176 ] = BCS_RELATIVE_176;
function LDA_INDIRECTY_177( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 177 ] = LDA_INDIRECTY_177;
function HLT_NONE_178( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 178 ] = HLT_NONE_178;
function LAX_INDIRECTY_179( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 179 ] = LAX_INDIRECTY_179;
function LDY_ZEROPAGEX_180( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 180 ] = LDY_ZEROPAGEX_180;
function LDA_ZEROPAGEX_181( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 181 ] = LDA_ZEROPAGEX_181;
function LDX_ZEROPAGEY_182( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 182 ] = LDX_ZEROPAGEY_182;
function LAX_ZEROPAGEY_183( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 183 ] = LAX_ZEROPAGEY_183;
function CLV_NONE_184( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setOverflow( false );
	return cyclesTaken;
};
instructions[ 184 ] = CLV_NONE_184;
function LDA_ABSOLUTEY_185( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 185 ] = LDA_ABSOLUTEY_185;
function TSX_NONE_186( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX = cpu.regS & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 186 ] = TSX_NONE_186;
function LAS_ABSOLUTEY_187( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var result = 0
	console.log("illegal instruction LAS not implemented");
	return cyclesTaken;
};
instructions[ 187 ] = LAS_ABSOLUTEY_187;
function LDY_ABSOLUTEX_188( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 188 ] = LDY_ABSOLUTEX_188;
function LDA_ABSOLUTEX_189( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 189 ] = LDA_ABSOLUTEX_189;
function LDX_ABSOLUTEY_190( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 190 ] = LDX_ABSOLUTEY_190;
function LAX_ABSOLUTEY_191( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 191 ] = LAX_ABSOLUTEY_191;
function CPY_IMMEDIATE_192( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regY - readInValue; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 192 ] = CPY_IMMEDIATE_192;
function CMP_INDIRECTX_193( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 193 ] = CMP_INDIRECTX_193;
function SKB_IMMEDIATE_194( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 194 ] = SKB_IMMEDIATE_194;
function DCM_INDIRECTX_195( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 195 ] = DCM_INDIRECTX_195;
function CPY_ZEROPAGE_196( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regY - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 196 ] = CPY_ZEROPAGE_196;
function CMP_ZEROPAGE_197( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 197 ] = CMP_ZEROPAGE_197;
function DEC_ZEROPAGE_198( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 198 ] = DEC_ZEROPAGE_198;
function DCM_ZEROPAGE_199( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 199 ] = DCM_ZEROPAGE_199;
function INY_NONE_200( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regY++;
	if ( cpu.regY > 0xFF )
		cpu.regY = 0;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 200 ] = INY_NONE_200;
function CMP_IMMEDIATE_201( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regA - readInValue;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 201 ] = CMP_IMMEDIATE_201;
function DEX_NONE_202( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX--;
	if ( cpu.regX < 0 )
		cpu.regX = 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 202 ] = DEX_NONE_202;
function SAX_IMMEDIATE_203( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = ( cpu.regA & cpu.regX ) - readInValue;
	cpu.regX = temp & 0xFF;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 203 ] = SAX_IMMEDIATE_203;
function CPY_ABSOLUTE_204( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regY - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 204 ] = CPY_ABSOLUTE_204;
function CMP_ABSOLUTE_205( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 205 ] = CMP_ABSOLUTE_205;
function DEC_ABSOLUTE_206( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 206 ] = DEC_ABSOLUTE_206;
function DCM_ABSOLUTE_207( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 207 ] = DCM_ABSOLUTE_207;
function BNE_RELATIVE_208( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = !cpu.getZero();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 208 ] = BNE_RELATIVE_208;
function CMP_INDIRECTY_209( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 209 ] = CMP_INDIRECTY_209;
function HLT_NONE_210( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 210 ] = HLT_NONE_210;
function DCM_INDIRECTY_211( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 211 ] = DCM_INDIRECTY_211;
function SKB_ZEROPAGEX_212( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 212 ] = SKB_ZEROPAGEX_212;
function CMP_ZEROPAGEX_213( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 213 ] = CMP_ZEROPAGEX_213;
function DEC_ZEROPAGEX_214( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 214 ] = DEC_ZEROPAGEX_214;
function DCM_ZEROPAGEX_215( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 215 ] = DCM_ZEROPAGEX_215;
function CLD_NONE_216( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setDecimal( false );
	return cyclesTaken;
};
instructions[ 216 ] = CLD_NONE_216;
function CMP_ABSOLUTEY_217( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 217 ] = CMP_ABSOLUTEY_217;
function NOP_NONE_218( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions[ 218 ] = NOP_NONE_218;
function DCM_ABSOLUTEY_219( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 219 ] = DCM_ABSOLUTEY_219;
function SKW_ABSOLUTEX_220( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 220 ] = SKW_ABSOLUTEX_220;
function CMP_ABSOLUTEX_221( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 221 ] = CMP_ABSOLUTEX_221;
function DEC_ABSOLUTEX_222( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 222 ] = DEC_ABSOLUTEX_222;
function DCM_ABSOLUTEX_223( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 223 ] = DCM_ABSOLUTEX_223;
function CPX_IMMEDIATE_224( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regX - readInValue; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 224 ] = CPX_IMMEDIATE_224;
function SBC_INDIRECTX_225( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 225 ] = SBC_INDIRECTX_225;
function SKB_IMMEDIATE_226( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions[ 226 ] = SKB_IMMEDIATE_226;
function INS_INDIRECTX_227( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 227 ] = INS_INDIRECTX_227;
function CPX_ZEROPAGE_228( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regX - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 228 ] = CPX_ZEROPAGE_228;
function SBC_ZEROPAGE_229( cpu, memory ) {
	var cyclesTaken = 3;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 229 ] = SBC_ZEROPAGE_229;
function INC_ZEROPAGE_230( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 230 ] = INC_ZEROPAGE_230;
function INS_ZEROPAGE_231( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 231 ] = INS_ZEROPAGE_231;
function INX_NONE_232( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX++;
	if ( cpu.regX > 0xFF )
		cpu.regX = 0;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 232 ] = INX_NONE_232;
function SBC_IMMEDIATE_233( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regA - readInValue - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ readInValue ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 233 ] = SBC_IMMEDIATE_233;
function NOP_NONE_234( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions[ 234 ] = NOP_NONE_234;
function SBC_IMMEDIATE_235( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regA - readInValue - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ readInValue ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 235 ] = SBC_IMMEDIATE_235;
function CPX_ABSOLUTE_236( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regX - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions[ 236 ] = CPX_ABSOLUTE_236;
function SBC_ABSOLUTE_237( cpu, memory ) {
	var cyclesTaken = 4;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 237 ] = SBC_ABSOLUTE_237;
function INC_ABSOLUTE_238( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 238 ] = INC_ABSOLUTE_238;
function INS_ABSOLUTE_239( cpu, memory ) {
	var cyclesTaken = 6;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 239 ] = INS_ABSOLUTE_239;
function BEQ_RELATIVE_240( cpu, memory ) {
	var cyclesTaken = 2;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	var branchTaken = cpu.getZero();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions[ 240 ] = BEQ_RELATIVE_240;
function SBC_INDIRECTY_241( cpu, memory ) {
	var cyclesTaken = 5;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 241 ] = SBC_INDIRECTY_241;
function HLT_NONE_242( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions[ 242 ] = HLT_NONE_242;
function INS_INDIRECTY_243( cpu, memory ) {
	var cyclesTaken = 8;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 243 ] = INS_INDIRECTY_243;
function SKB_ZEROPAGEX_244( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 244 ] = SKB_ZEROPAGEX_244;
function SBC_ZEROPAGEX_245( cpu, memory ) {
	var cyclesTaken = 4;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 245 ] = SBC_ZEROPAGEX_245;
function INC_ZEROPAGEX_246( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 246 ] = INC_ZEROPAGEX_246;
function INS_ZEROPAGEX_247( cpu, memory ) {
	var cyclesTaken = 6;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 247 ] = INS_ZEROPAGEX_247;
function SED_NONE_248( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setDecimal( true );
	return cyclesTaken;
};
instructions[ 248 ] = SED_NONE_248;
function SBC_ABSOLUTEY_249( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 249 ] = SBC_ABSOLUTEY_249;
function NOP_NONE_250( cpu, memory ) {
	var cyclesTaken = 2;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions[ 250 ] = NOP_NONE_250;
function INS_ABSOLUTEY_251( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 251 ] = INS_ABSOLUTEY_251;
function SKW_ABSOLUTEX_252( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	return cyclesTaken;
};
instructions[ 252 ] = SKW_ABSOLUTEX_252;
function SBC_ABSOLUTEX_253( cpu, memory ) {
	var cyclesTaken = 4;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions[ 253 ] = SBC_ABSOLUTEX_253;
function INC_ABSOLUTEX_254( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 254 ] = INC_ABSOLUTEX_254;
function INS_ABSOLUTEX_255( cpu, memory ) {
	var cyclesTaken = 7;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions[ 255 ] = INS_ABSOLUTEX_255;

Nes.cpuInstructions = instructions;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

// This file has been automatically generated by the cpuCoreBuilder.js tool

"use strict";

var executeCpuInstructionSwitch = function( opcode, cpu, memory ) {
	switch ( opcode ) {
	
	case 0: { // BRK NONE
		var cyclesTaken = 7;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		// dummy read of opcode after brk
		memory.read8( cpu.getPC() );
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		memory.write8( 0x100 + cpu.regS, (( cpu.getPC() >> 8 )) & 0xFF );
		if ( cpu.regS === 0 ) {
			cpu.regS = 0xFF;
		} else {
			cpu.regS--;
		}
		cpu.incrementSubcycle();
		memory.write8( 0x100 + cpu.regS, (cpu.programCounter) & 0xFF );
		if ( cpu.regS === 0 ) {
			cpu.regS = 0xFF;
		} else {
			cpu.regS--;
		}
		cpu.incrementSubcycle();
		memory.write8( 0x100 + cpu.regS, (( cpu.statusRegToByte() | 0x30 )) & 0xFF );
		if ( cpu.regS === 0 ) {
			cpu.regS = 0xFF;
		} else {
			cpu.regS--;
		}
		cpu.setPC( cpu.read16FromMemNoWrap( CPU_IRQ_ADDRESS ) );
		cpu.setInterrupt( true );
		return cyclesTaken;
	};
	break;
	case 1: { // ORA INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA |= operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 2: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 3: { // ASO INDIRECTX
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( operationModeData << 1 ) & 0xFF;
		cpu.regA |= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 4: { // SKB ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 5: { // ORA ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA |= operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 6: { // ASL ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 7: { // ASO ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( operationModeData << 1 ) & 0xFF;
		cpu.regA |= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 8: { // PHP NONE
		var cyclesTaken = 3;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		memory.write8( 0x100 + cpu.regS, (( cpu.statusRegToByte() | 0x10 )) & 0xFF );
		if ( cpu.regS === 0 ) {
			cpu.regS = 0xFF;
		} else {
			cpu.regS--;
		}
		return cyclesTaken;
	};
	break;
	case 9: { // ORA IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA |= readInValue & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 10: { // ASL ACCUMULATOR
		var cyclesTaken = 2;
		var readInValue = cpu.regA;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setCarry( ( readInValue & 0x80 ) > 0 );
		var result = ( ( readInValue & 0xFF ) << 1 ) & 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.regA = result & 0xFF;
		return cyclesTaken;
	};
	break;
	case 11: { // ANC IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA &= readInValue;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.setCarry( cpu.getSign() );
		return cyclesTaken;
	};
	break;
	case 12: { // SKW ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 13: { // ORA ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA |= operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 14: { // ASL ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 15: { // ASO ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( operationModeData << 1 ) & 0xFF;
		cpu.regA |= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 16: { // BPL RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = !cpu.getSign();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 17: { // ORA INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA |= operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 18: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 19: { // ASO INDIRECTY
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( operationModeData << 1 ) & 0xFF;
		cpu.regA |= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 20: { // SKB ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 21: { // ORA ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA |= operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 22: { // ASL ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 23: { // ASO ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( operationModeData << 1 ) & 0xFF;
		cpu.regA |= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 24: { // CLC NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setCarry( false );
		return cyclesTaken;
	};
	break;
	case 25: { // ORA ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA |= operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 26: { // NOP NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		return cyclesTaken;
	};
	break;
	case 27: { // ASO ABSOLUTEY
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( operationModeData << 1 ) & 0xFF;
		cpu.regA |= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 28: { // SKW ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 29: { // ORA ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA |= operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 30: { // ASL ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 31: { // ASO ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
		var result = ( operationModeData << 1 ) & 0xFF;
		cpu.regA |= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 32: { // JSR IMMEDIATE16
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = cpu.getPC() - 1;
		if ( result < 0 )
			result = 0xFFFF;
		cpu.incrementSubcycle();
		memory.write8( 0x100 + cpu.regS, (( result >> 8 )) & 0xFF );
		if ( cpu.regS === 0 ) {
			cpu.regS = 0xFF;
		} else {
			cpu.regS--;
		}
		cpu.incrementSubcycle();
		memory.write8( 0x100 + cpu.regS, (result) & 0xFF );
		if ( cpu.regS === 0 ) {
			cpu.regS = 0xFF;
		} else {
			cpu.regS--;
		}
		cpu.incrementSubcycle();
		cpu.setPC( ( readInValue ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 33: { // AND INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA &= ( operationModeData & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 34: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 35: { // RLA INDIRECTX
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.regA &= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 36: { // BIT ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		if ( ( readInValue & 0xE007 ) === 0x2002 ) { cpu.mainboard.ppu.bitOperationHappening(); } // BIT 2002 optimisation
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.setSign( ( ( operationModeData& 0xFF ) & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & ( operationModeData & 0xFF ) & 0xFF ) === 0 );
		cpu.setOverflow( ( operationModeData & 0x40) > 0 );	// Copy bit 6 to OVERFLOW flag.
		return cyclesTaken;
	};
	break;
	case 37: { // AND ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA &= ( operationModeData & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 38: { // ROL ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 39: { // RLA ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.regA &= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 40: { // PLP NONE
		var cyclesTaken = 4;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === true;
		cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		if ( cpu.regS === 0xFF ) {
			cpu.regS = 0;
		} else {
			cpu.regS++;
		}
		cpu.incrementSubcycle();
		var temp = memory.read8( 0x100 + cpu.regS );
		cpu.statusRegFromByte( temp );
		cpu.setBreak( true ); // TODO: this was true before in original port, put it back for some reason?
		cpu.setUnused( true );
		if ( cpu.waitOneInstructionAfterCli )
			cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === false;
		return cyclesTaken;
	};
	break;
	case 41: { // AND IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA &= ( readInValue & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 42: { // ROL ACCUMULATOR
		var cyclesTaken = 2;
		var readInValue = cpu.regA;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var result = ( (readInValue & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.regA = result & 0xFF;
		return cyclesTaken;
	};
	break;
	case 43: { // ANC IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA &= readInValue;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.setCarry( cpu.getSign() );
		return cyclesTaken;
	};
	break;
	case 44: { // BIT ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		if ( ( readInValue & 0xE007 ) === 0x2002 ) { cpu.mainboard.ppu.bitOperationHappening(); } // BIT 2002 optimisation
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.setSign( ( ( operationModeData& 0xFF ) & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & ( operationModeData & 0xFF ) & 0xFF ) === 0 );
		cpu.setOverflow( ( operationModeData & 0x40) > 0 );	// Copy bit 6 to OVERFLOW flag.
		return cyclesTaken;
	};
	break;
	case 45: { // AND ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA &= ( operationModeData & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 46: { // ROL ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 47: { // RLA ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.regA &= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 48: { // BMI RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = cpu.getSign();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 49: { // AND INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA &= ( operationModeData & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 50: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 51: { // RLA INDIRECTY
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.regA &= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 52: { // SKB ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 53: { // AND ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA &= ( operationModeData & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 54: { // ROL ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 55: { // RLA ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.regA &= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 56: { // SEC NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setCarry( true );
		return cyclesTaken;
	};
	break;
	case 57: { // AND ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA &= ( operationModeData & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 58: { // NOP NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		return cyclesTaken;
	};
	break;
	case 59: { // RLA ABSOLUTEY
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.regA &= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 60: { // SKW ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 61: { // AND ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA &= ( operationModeData & 0xFF );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 62: { // ROL ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 63: { // RLA ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
		cpu.setCarry( result > 0xFF );
		result &= 0xff;
		cpu.regA &= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 64: { // RTI NONE
		var cyclesTaken = 6;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		// dummy read
		cpu.incrementSubcycle();
		memory.read8( cpu.getPC() );
		cpu.incrementSubcycle();
		if ( cpu.regS === 0xFF ) {
			cpu.regS = 0;
		} else {
			cpu.regS++;
		}
		cpu.incrementSubcycle();
		var temp = memory.read8( 0x100 + cpu.regS );
		cpu.statusRegFromByte( temp );
		if ( cpu.regS === 0xFF ) {
			cpu.regS = 0;
		} else {
			cpu.regS++;
		}
		cpu.incrementSubcycle();
		cpu.programCounter = memory.read8( 0x100 + cpu.regS );
		if ( cpu.regS === 0xFF ) {
			cpu.regS = 0;
		} else {
			cpu.regS++;
		}
		cpu.incrementSubcycle();
		temp = memory.read8( 0x100 + cpu.regS );
		cpu.programCounter |= ( temp & 0xFF ) << 8;
		cpu.setBreak( true );
		cpu.setUnused( true );
		return cyclesTaken;
	};
	break;
	case 65: { // EOR INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 66: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 67: { // LSE INDIRECTX
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData >> 1 ) & 0xFF;
		cpu.regA ^= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 68: { // SKB ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 69: { // EOR ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 70: { // LSR ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData & 0xFF ) >> 1;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 71: { // LSE ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData >> 1 ) & 0xFF;
		cpu.regA ^= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 72: { // PHA NONE
		var cyclesTaken = 3;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		memory.write8( 0x100 + cpu.regS, (cpu.regA) & 0xFF );
		if ( cpu.regS === 0 ) {
			cpu.regS = 0xFF;
		} else {
			cpu.regS--;
		}
		return cyclesTaken;
	};
	break;
	case 73: { // EOR IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA = ( cpu.regA ^ ( readInValue & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 74: { // LSR ACCUMULATOR
		var cyclesTaken = 2;
		var readInValue = cpu.regA;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setCarry((readInValue & 0x01) > 0);
		var result = ( readInValue & 0xFF ) >> 1;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.regA = result & 0xFF;
		return cyclesTaken;
	};
	break;
	case 75: { // ALR IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA &= readInValue;
		cpu.setCarry((cpu.regA & 0x01) > 0);
		cpu.regA = ( cpu.regA >> 1 ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 76: { // JMP IMMEDIATE16
		var cyclesTaken = 3;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.setPC( ( readInValue ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 77: { // EOR ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 78: { // LSR ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData & 0xFF ) >> 1;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 79: { // LSE ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData >> 1 ) & 0xFF;
		cpu.regA ^= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 80: { // BVC RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = !cpu.getOverflow();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 81: { // EOR INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 82: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 83: { // LSE INDIRECTY
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData >> 1 ) & 0xFF;
		cpu.regA ^= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 84: { // SKB ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 85: { // EOR ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 86: { // LSR ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData & 0xFF ) >> 1;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 87: { // LSE ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData >> 1 ) & 0xFF;
		cpu.regA ^= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 88: { // CLI NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === true;
		cpu.setInterrupt( false );
		return cyclesTaken;
	};
	break;
	case 89: { // EOR ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 90: { // NOP NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		return cyclesTaken;
	};
	break;
	case 91: { // LSE ABSOLUTEY
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData >> 1 ) & 0xFF;
		cpu.regA ^= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 92: { // SKW ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 93: { // EOR ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 94: { // LSR ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData & 0xFF ) >> 1;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 95: { // LSE ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		cpu.setCarry((operationModeData & 0x01) > 0);
		var result = ( operationModeData >> 1 ) & 0xFF;
		cpu.regA ^= result;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 96: { // RTS NONE
		var cyclesTaken = 6;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		// dummy read
		cpu.incrementSubcycle();
		memory.read8( cpu.getPC() );
		cpu.incrementSubcycle();
		if ( cpu.regS === 0xFF ) {
			cpu.regS = 0;
		} else {
			cpu.regS++;
		}
		cpu.incrementSubcycle();
		cpu.programCounter = memory.read8( 0x100 + cpu.regS );
		if ( cpu.regS === 0xFF ) {
			cpu.regS = 0;
		} else {
			cpu.regS++;
		}
		cpu.incrementSubcycle();
		var temp = memory.read8( 0x100 + cpu.regS );
		cpu.programCounter |= ( temp & 0xFF ) << 8;
		cpu.incrementSubcycle();
		cpu.programCounter = ( cpu.getPC() + 1 ) & 0xFFFF;
		return cyclesTaken;
	};
	break;
	case 97: { // ADC INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 98: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 99: { // RRA INDIRECTX
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
		var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		result &= 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 100: { // SKB ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 101: { // ADC ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 102: { // ROR ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( operationModeData & 0x1 );
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 103: { // RRA ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
		var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		result &= 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 104: { // PLA NONE
		var cyclesTaken = 4;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		if ( cpu.regS === 0xFF ) {
			cpu.regS = 0;
		} else {
			cpu.regS++;
		}
		cpu.incrementSubcycle();
		cpu.regA = memory.read8( 0x100 + cpu.regS );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 105: { // ADC IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var temp = ( readInValue & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( readInValue ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 106: { // ROR ACCUMULATOR
		var cyclesTaken = 2;
		var readInValue = cpu.regA;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var result = ( (readInValue & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( readInValue & 0x1 );
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.regA = result & 0xFF;
		return cyclesTaken;
	};
	break;
	case 107: { // ARR IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA &= readInValue & 0xFF;
		cpu.regA = ( ( cpu.regA >> 1 ) & 0xFF ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( cpu.regA & 0x1 ) > 0 );
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		cpu.setOverflow( false );
		cpu.setCarry( false )
		switch ( cpu.regA & 0x60 )
		{
		case 0x20: cpu.setOverflow( true ); break;
		case 0x40: cpu.setOverflow( true );
		cpu.setCarry( true ); break;
		case 0x60: cpu.setCarry( true ); break;
		}
		return cyclesTaken;
	};
	break;
	case 108: { // JMP INDIRECT
		var cyclesTaken = 5;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.setPC( ( readInValue ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 109: { // ADC ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 110: { // ROR ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( operationModeData & 0x1 );
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 111: { // RRA ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
		var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		result &= 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 112: { // BVS RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = cpu.getOverflow();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 113: { // ADC INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 114: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 115: { // RRA INDIRECTY
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
		var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		result &= 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 116: { // SKB ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 117: { // ADC ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 118: { // ROR ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( operationModeData & 0x1 );
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 119: { // RRA ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
		var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		result &= 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 120: { // SEI NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setInterrupt( true );
		return cyclesTaken;
	};
	break;
	case 121: { // ADC ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 122: { // NOP NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		return cyclesTaken;
	};
	break;
	case 123: { // RRA ABSOLUTEY
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
		var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		result &= 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 124: { // SKW ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 125: { // ADC ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		return cyclesTaken;
	};
	break;
	case 126: { // ROR ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( operationModeData & 0x1 );
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 127: { // RRA ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
		cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
		var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
		cpu.setCarry( temp > 0xFF );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
		cpu.regA = temp & 0xFF;
		result &= 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 128: { // SKB IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 129: { // STA INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regA;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 130: { // SKB IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 131: { // AXS INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regA & cpu.regX;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 132: { // STY ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regY;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 133: { // STA ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regA;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 134: { // STX ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regX;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 135: { // AXS ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regA & cpu.regX;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 136: { // DEY NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regY--;
		if ( cpu.regY < 0 )
			cpu.regY = 0xFF;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 137: { // SKB IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 138: { // TXA NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regA = cpu.regX;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 139: { // XAA IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA = cpu.regX & readInValue;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 140: { // STY ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = cpu.regY;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 141: { // STA ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = cpu.regA;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 142: { // STX ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = cpu.regX;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 143: { // AXS ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = cpu.regA & cpu.regX;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 144: { // BCC RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = !cpu.getCarry();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 145: { // STA INDIRECTY
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regA;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 146: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 147: { // AXA INDIRECTY
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = ( cpu.regX & cpu.regA ) & 0x7;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 148: { // STY ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regY;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 149: { // STA ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regA;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 150: { // STX ZEROPAGEY
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regX;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 151: { // AXS ZEROPAGEY
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var result = cpu.regA & cpu.regX;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 152: { // TYA NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regA = cpu.regY;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 153: { // STA ABSOLUTEY
		var cyclesTaken = 5;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = cpu.regA;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 154: { // TXS NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regS = cpu.regX;
		return cyclesTaken;
	};
	break;
	case 155: { // TAS ABSOLUTEY
		var cyclesTaken = 5;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.regS = cpu.regX & cpu.regA;
		return cyclesTaken;
	};
	break;
	case 156: { // SAY SAY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.SAYHighByte = memory.read8( ( cpu.getPC() + 2 ) & 0xFFFF );
		address |= ( cpu.SAYHighByte ) << 8;
		var readInValue = ( address + cpu.regX ) & 0xFFFF; // SAY writes to absolute X but needs the high byte of the address to operate on
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = cpu.regY & ( ( cpu.SAYHighByte + 1 ) & 0xFF );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 157: { // STA ABSOLUTEX
		var cyclesTaken = 5;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = cpu.regA;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 158: { // XAS ABSOLUTEY
		var cyclesTaken = 5;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction XAS not implemented");
		cpu.incrementSubcycle();
		memory.write8( readInValue, result );
		return cyclesTaken;
	};
	break;
	case 159: { // AXA ABSOLUTEY
		var cyclesTaken = 5;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = ( cpu.regX & cpu.regA ) & 0x7;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 160: { // LDY IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regY = readInValue & 0xFF;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 161: { // LDA INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 162: { // LDX IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regX = readInValue & 0xFF;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 163: { // LAX INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData;
		cpu.regX = operationModeData;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 164: { // LDY ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regY = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 165: { // LDA ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 166: { // LDX ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regX = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 167: { // LAX ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData;
		cpu.regX = operationModeData;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 168: { // TAY NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regY = cpu.regA;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 169: { // LDA IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regA = readInValue & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 170: { // TAX NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regX = cpu.regA;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 171: { // OAL IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.regX = cpu.regA = readInValue & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 172: { // LDY ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regY = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 173: { // LDA ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 174: { // LDX ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regX = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 175: { // LAX ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData;
		cpu.regX = operationModeData;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 176: { // BCS RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = cpu.getCarry();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 177: { // LDA INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 178: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 179: { // LAX INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData;
		cpu.regX = operationModeData;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 180: { // LDY ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regY = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 181: { // LDA ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 182: { // LDX ZEROPAGEY
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regX = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 183: { // LAX ZEROPAGEY
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData;
		cpu.regX = operationModeData;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 184: { // CLV NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setOverflow( false );
		return cyclesTaken;
	};
	break;
	case 185: { // LDA ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 186: { // TSX NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regX = cpu.regS & 0xFF;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 187: { // LAS ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var result = 0
		console.log("illegal instruction LAS not implemented");
		return cyclesTaken;
	};
	break;
	case 188: { // LDY ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regY = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 189: { // LDA ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 190: { // LDX ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regX = operationModeData & 0xFF;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 191: { // LAX ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.regA = operationModeData;
		cpu.regX = operationModeData;
		cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 192: { // CPY IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var temp = cpu.regY - readInValue; // purposely not wrapped
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 193: { // CMP INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 194: { // SKB IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 195: { // DCM INDIRECTX
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		var temp = cpu.regA - result;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 196: { // CPY ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regY - operationModeData; // purposely not wrapped
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 197: { // CMP ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 198: { // DEC ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 199: { // DCM ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		var temp = cpu.regA - result;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 200: { // INY NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regY++;
		if ( cpu.regY > 0xFF )
			cpu.regY = 0;
		cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 201: { // CMP IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var temp = cpu.regA - readInValue;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 202: { // DEX NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regX--;
		if ( cpu.regX < 0 )
			cpu.regX = 0xFF;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 203: { // SAX IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var temp = ( cpu.regA & cpu.regX ) - readInValue;
		cpu.regX = temp & 0xFF;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 204: { // CPY ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regY - operationModeData; // purposely not wrapped
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 205: { // CMP ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 206: { // DEC ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 207: { // DCM ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		var temp = cpu.regA - result;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 208: { // BNE RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = !cpu.getZero();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 209: { // CMP INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 210: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 211: { // DCM INDIRECTY
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		var temp = cpu.regA - result;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 212: { // SKB ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 213: { // CMP ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 214: { // DEC ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 215: { // DCM ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		var temp = cpu.regA - result;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 216: { // CLD NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setDecimal( false );
		return cyclesTaken;
	};
	break;
	case 217: { // CMP ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 218: { // NOP NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		return cyclesTaken;
	};
	break;
	case 219: { // DCM ABSOLUTEY
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		var temp = cpu.regA - result;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 220: { // SKW ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 221: { // CMP ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 222: { // DEC ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 223: { // DCM ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData - 1;
		if ( result < 0 )
			result = 0xFF;
		var temp = cpu.regA - result;
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 224: { // CPX IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var temp = cpu.regX - readInValue; // purposely not wrapped
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 225: { // SBC INDIRECTX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 226: { // SKB IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		return cyclesTaken;
	};
	break;
	case 227: { // INS INDIRECTX
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		address = ( address + cpu.regX ) & 0xFF;
		var readInValue = cpu.read16FromMemWithWrap( address );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = temp & 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 228: { // CPX ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regX - operationModeData; // purposely not wrapped
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 229: { // SBC ZEROPAGE
		var cyclesTaken = 3;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 230: { // INC ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 231: { // INS ZEROPAGE
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = temp & 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 232: { // INX NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.regX++;
		if ( cpu.regX > 0xFF )
			cpu.regX = 0;
		cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
		cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 233: { // SBC IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var temp = cpu.regA - readInValue - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ readInValue ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 234: { // NOP NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		return cyclesTaken;
	};
	break;
	case 235: { // SBC IMMEDIATE
		var cyclesTaken = 2;
		cpu.incrementSubcycle();
		var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		var temp = cpu.regA - readInValue - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ readInValue ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 236: { // CPX ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regX - operationModeData; // purposely not wrapped
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		return cyclesTaken;
	};
	break;
	case 237: { // SBC ABSOLUTE
		var cyclesTaken = 4;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 238: { // INC ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 239: { // INS ABSOLUTE
		var cyclesTaken = 6;
		var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = temp & 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 240: { // BEQ RELATIVE
		var cyclesTaken = 2;
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
		var branchTaken = cpu.getZero();
		if ( branchTaken ) {
		cpu.incrementSubcycle();
			if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
				cyclesTaken += 1
		cpu.incrementSubcycle();
			}
			cyclesTaken += 1;
		cpu.incrementSubcycle();
			cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
		} else {
		cpu.incrementSubcycle();
			memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
			cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		}
		return cyclesTaken;
	};
	break;
	case 241: { // SBC INDIRECTY
		var cyclesTaken = 5;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 242: { // HLT NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		var result = 0
		console.log("illegal instruction HLT not implemented");
		return cyclesTaken;
	};
	break;
	case 243: { // INS INDIRECTY
		var cyclesTaken = 8;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		address = cpu.read16FromMemWithWrap( address );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = temp & 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 244: { // SKB ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 245: { // SBC ZEROPAGEX
		var cyclesTaken = 4;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 246: { // INC ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 247: { // INS ZEROPAGEX
		var cyclesTaken = 6;
		cpu.incrementSubcycle();
		var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = temp & 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 248: { // SED NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		cpu.setDecimal( true );
		return cyclesTaken;
	};
	break;
	case 249: { // SBC ABSOLUTEY
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 250: { // NOP NONE
		var cyclesTaken = 2;
		cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.incrementSubcycle();
		return cyclesTaken;
	};
	break;
	case 251: { // INS ABSOLUTEY
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regY ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = temp & 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 252: { // SKW ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		return cyclesTaken;
	};
	break;
	case 253: { // SBC ABSOLUTEX
		var cyclesTaken = 4;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
			cyclesTaken++
			cpu.incrementSubcycle();
			memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		}
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = ( temp & 0xFF );
		return cyclesTaken;
	};
	break;
	case 254: { // INC ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	case 255: { // INS ABSOLUTEX
		var cyclesTaken = 7;
		var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
		var readInValue = ( address + cpu.regX ) & 0xFFFF;
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
		cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
		cpu.incrementSubcycle();
		var operationModeData = memory.read8( readInValue );
		cpu.incrementSubcycle();
		memory.write8( readInValue, operationModeData );
		var result = operationModeData + 1;
		if ( result > 0xFF )
			result = 0;
		cpu.setSign( ( result & 0x80 ) > 0 );
		cpu.setZero( ( result & 0xFF ) === 0 );
		var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
		cpu.setSign( ( temp & 0x80 ) > 0 );
		cpu.setZero( ( temp & 0xFF ) === 0 );
		cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
		cpu.setCarry( temp >= 0 && temp < 0x100 );
		cpu.regA = temp & 0xFF;
		cpu.incrementSubcycle();
		memory.write8( readInValue, result & 0xFF );
		return cyclesTaken;
	};
	break;
	};
};

Nes.cpuInstructionsSwitch = executeCpuInstructionSwitch;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

// This file has been automatically generated by the cpuCoreBuilder.js tool

"use strict";

var instructions_TRACE = [];
var formatData = { programCounter: 0, opcode: 0, opcodeParam: 0, operationParam: 0, regs: {} };

function BRK_NONE_0_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 0;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	// dummy read of opcode after brk
	memory.read8( cpu.getPC() );
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( cpu.getPC() >> 8 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (cpu.programCounter) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( cpu.statusRegToByte() | 0x30 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.setPC( cpu.read16FromMemNoWrap( CPU_IRQ_ADDRESS ) );
	cpu.setInterrupt( true );
	return cyclesTaken;
};
instructions_TRACE[ 0 ] = BRK_NONE_0_TRACE;
function ORA_INDIRECTX_1_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 1;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 1 ] = ORA_INDIRECTX_1_TRACE;
function HLT_NONE_2_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 2;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 2 ] = HLT_NONE_2_TRACE;
function ASO_INDIRECTX_3_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 3;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 3 ] = ASO_INDIRECTX_3_TRACE;
function SKB_ZEROPAGE_4_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 4;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 4 ] = SKB_ZEROPAGE_4_TRACE;
function ORA_ZEROPAGE_5_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 5;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 5 ] = ORA_ZEROPAGE_5_TRACE;
function ASL_ZEROPAGE_6_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 6;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 6 ] = ASL_ZEROPAGE_6_TRACE;
function ASO_ZEROPAGE_7_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 7;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 7 ] = ASO_ZEROPAGE_7_TRACE;
function PHP_NONE_8_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 8;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( cpu.statusRegToByte() | 0x10 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	return cyclesTaken;
};
instructions_TRACE[ 8 ] = PHP_NONE_8_TRACE;
function ORA_IMMEDIATE_9_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 9;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA |= readInValue & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 9 ] = ORA_IMMEDIATE_9_TRACE;
function ASL_ACCUMULATOR_10_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 10;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry( ( readInValue & 0x80 ) > 0 );
	var result = ( ( readInValue & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 10 ] = ASL_ACCUMULATOR_10_TRACE;
function ANC_IMMEDIATE_11_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 11;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.setCarry( cpu.getSign() );
	return cyclesTaken;
};
instructions_TRACE[ 11 ] = ANC_IMMEDIATE_11_TRACE;
function SKW_ABSOLUTE_12_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 12;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 12 ] = SKW_ABSOLUTE_12_TRACE;
function ORA_ABSOLUTE_13_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 13;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 13 ] = ORA_ABSOLUTE_13_TRACE;
function ASL_ABSOLUTE_14_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 14;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 14 ] = ASL_ABSOLUTE_14_TRACE;
function ASO_ABSOLUTE_15_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 15;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 15 ] = ASO_ABSOLUTE_15_TRACE;
function BPL_RELATIVE_16_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 16;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = !cpu.getSign();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 16 ] = BPL_RELATIVE_16_TRACE;
function ORA_INDIRECTY_17_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 17;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 17 ] = ORA_INDIRECTY_17_TRACE;
function HLT_NONE_18_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 18;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 18 ] = HLT_NONE_18_TRACE;
function ASO_INDIRECTY_19_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 19;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 19 ] = ASO_INDIRECTY_19_TRACE;
function SKB_ZEROPAGEX_20_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 20;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 20 ] = SKB_ZEROPAGEX_20_TRACE;
function ORA_ZEROPAGEX_21_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 21;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 21 ] = ORA_ZEROPAGEX_21_TRACE;
function ASL_ZEROPAGEX_22_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 22;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 22 ] = ASL_ZEROPAGEX_22_TRACE;
function ASO_ZEROPAGEX_23_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 23;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 23 ] = ASO_ZEROPAGEX_23_TRACE;
function CLC_NONE_24_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 24;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry( false );
	return cyclesTaken;
};
instructions_TRACE[ 24 ] = CLC_NONE_24_TRACE;
function ORA_ABSOLUTEY_25_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 25;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 25 ] = ORA_ABSOLUTEY_25_TRACE;
function NOP_NONE_26_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 26;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions_TRACE[ 26 ] = NOP_NONE_26_TRACE;
function ASO_ABSOLUTEY_27_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 27;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 27 ] = ASO_ABSOLUTEY_27_TRACE;
function SKW_ABSOLUTEX_28_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 28;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 28 ] = SKW_ABSOLUTEX_28_TRACE;
function ORA_ABSOLUTEX_29_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 29;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA |= operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 29 ] = ORA_ABSOLUTEX_29_TRACE;
function ASL_ABSOLUTEX_30_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 30;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( ( operationModeData & 0xFF ) << 1 ) & 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 30 ] = ASL_ABSOLUTEX_30_TRACE;
function ASO_ABSOLUTEX_31_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 31;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry( ( operationModeData & 0x80 ) > 0 );
	var result = ( operationModeData << 1 ) & 0xFF;
	cpu.regA |= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 31 ] = ASO_ABSOLUTEX_31_TRACE;
function JSR_IMMEDIATE16_32_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 32;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.getPC() - 1;
	if ( result < 0 )
		result = 0xFFFF;
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (( result >> 8 )) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (result) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	cpu.incrementSubcycle();
	cpu.setPC( ( readInValue ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 32 ] = JSR_IMMEDIATE16_32_TRACE;
function AND_INDIRECTX_33_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 33;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 33 ] = AND_INDIRECTX_33_TRACE;
function HLT_NONE_34_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 34;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 34 ] = HLT_NONE_34_TRACE;
function RLA_INDIRECTX_35_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 35;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 35 ] = RLA_INDIRECTX_35_TRACE;
function BIT_ZEROPAGE_36_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 36;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	if ( ( readInValue & 0xE007 ) === 0x2002 ) { cpu.mainboard.ppu.bitOperationHappening(); } // BIT 2002 optimisation
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.setSign( ( ( operationModeData& 0xFF ) & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & ( operationModeData & 0xFF ) & 0xFF ) === 0 );
	cpu.setOverflow( ( operationModeData & 0x40) > 0 );	// Copy bit 6 to OVERFLOW flag.
	return cyclesTaken;
};
instructions_TRACE[ 36 ] = BIT_ZEROPAGE_36_TRACE;
function AND_ZEROPAGE_37_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 37;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 37 ] = AND_ZEROPAGE_37_TRACE;
function ROL_ZEROPAGE_38_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 38;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 38 ] = ROL_ZEROPAGE_38_TRACE;
function RLA_ZEROPAGE_39_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 39;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 39 ] = RLA_ZEROPAGE_39_TRACE;
function PLP_NONE_40_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 40;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === true;
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	var temp = memory.read8( 0x100 + cpu.regS );
	cpu.statusRegFromByte( temp );
	cpu.setBreak( true ); // TODO: this was true before in original port, put it back for some reason?
	cpu.setUnused( true );
	if ( cpu.waitOneInstructionAfterCli )
		cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === false;
	return cyclesTaken;
};
instructions_TRACE[ 40 ] = PLP_NONE_40_TRACE;
function AND_IMMEDIATE_41_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 41;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= ( readInValue & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 41 ] = AND_IMMEDIATE_41_TRACE;
function ROL_ACCUMULATOR_42_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 42;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var result = ( (readInValue & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 42 ] = ROL_ACCUMULATOR_42_TRACE;
function ANC_IMMEDIATE_43_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 43;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.setCarry( cpu.getSign() );
	return cyclesTaken;
};
instructions_TRACE[ 43 ] = ANC_IMMEDIATE_43_TRACE;
function BIT_ABSOLUTE_44_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 44;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	if ( ( readInValue & 0xE007 ) === 0x2002 ) { cpu.mainboard.ppu.bitOperationHappening(); } // BIT 2002 optimisation
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.setSign( ( ( operationModeData& 0xFF ) & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & ( operationModeData & 0xFF ) & 0xFF ) === 0 );
	cpu.setOverflow( ( operationModeData & 0x40) > 0 );	// Copy bit 6 to OVERFLOW flag.
	return cyclesTaken;
};
instructions_TRACE[ 44 ] = BIT_ABSOLUTE_44_TRACE;
function AND_ABSOLUTE_45_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 45;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 45 ] = AND_ABSOLUTE_45_TRACE;
function ROL_ABSOLUTE_46_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 46;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 46 ] = ROL_ABSOLUTE_46_TRACE;
function RLA_ABSOLUTE_47_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 47;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 47 ] = RLA_ABSOLUTE_47_TRACE;
function BMI_RELATIVE_48_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 48;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = cpu.getSign();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 48 ] = BMI_RELATIVE_48_TRACE;
function AND_INDIRECTY_49_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 49;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 49 ] = AND_INDIRECTY_49_TRACE;
function HLT_NONE_50_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 50;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 50 ] = HLT_NONE_50_TRACE;
function RLA_INDIRECTY_51_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 51;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 51 ] = RLA_INDIRECTY_51_TRACE;
function SKB_ZEROPAGEX_52_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 52;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 52 ] = SKB_ZEROPAGEX_52_TRACE;
function AND_ZEROPAGEX_53_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 53;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 53 ] = AND_ZEROPAGEX_53_TRACE;
function ROL_ZEROPAGEX_54_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 54;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 54 ] = ROL_ZEROPAGEX_54_TRACE;
function RLA_ZEROPAGEX_55_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 55;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 55 ] = RLA_ZEROPAGEX_55_TRACE;
function SEC_NONE_56_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 56;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry( true );
	return cyclesTaken;
};
instructions_TRACE[ 56 ] = SEC_NONE_56_TRACE;
function AND_ABSOLUTEY_57_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 57;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 57 ] = AND_ABSOLUTEY_57_TRACE;
function NOP_NONE_58_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 58;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions_TRACE[ 58 ] = NOP_NONE_58_TRACE;
function RLA_ABSOLUTEY_59_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 59;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 59 ] = RLA_ABSOLUTEY_59_TRACE;
function SKW_ABSOLUTEX_60_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 60;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 60 ] = SKW_ABSOLUTEX_60_TRACE;
function AND_ABSOLUTEX_61_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 61;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA &= ( operationModeData & 0xFF );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 61 ] = AND_ABSOLUTEX_61_TRACE;
function ROL_ABSOLUTEX_62_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 62;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 62 ] = ROL_ABSOLUTEX_62_TRACE;
function RLA_ABSOLUTEX_63_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 63;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData << 1 ) | ( cpu.getCarry() ? 1 : 0 );
	cpu.setCarry( result > 0xFF );
	result &= 0xff;
	cpu.regA &= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 63 ] = RLA_ABSOLUTEX_63_TRACE;
function RTI_NONE_64_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 64;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	// dummy read
	cpu.incrementSubcycle();
	memory.read8( cpu.getPC() );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	var temp = memory.read8( 0x100 + cpu.regS );
	cpu.statusRegFromByte( temp );
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	cpu.programCounter = memory.read8( 0x100 + cpu.regS );
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	temp = memory.read8( 0x100 + cpu.regS );
	cpu.programCounter |= ( temp & 0xFF ) << 8;
	cpu.setBreak( true );
	cpu.setUnused( true );
	return cyclesTaken;
};
instructions_TRACE[ 64 ] = RTI_NONE_64_TRACE;
function EOR_INDIRECTX_65_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 65;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 65 ] = EOR_INDIRECTX_65_TRACE;
function HLT_NONE_66_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 66;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 66 ] = HLT_NONE_66_TRACE;
function LSE_INDIRECTX_67_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 67;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 67 ] = LSE_INDIRECTX_67_TRACE;
function SKB_ZEROPAGE_68_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 68;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 68 ] = SKB_ZEROPAGE_68_TRACE;
function EOR_ZEROPAGE_69_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 69;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 69 ] = EOR_ZEROPAGE_69_TRACE;
function LSR_ZEROPAGE_70_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 70;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 70 ] = LSR_ZEROPAGE_70_TRACE;
function LSE_ZEROPAGE_71_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 71;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 71 ] = LSE_ZEROPAGE_71_TRACE;
function PHA_NONE_72_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 72;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.write8( 0x100 + cpu.regS, (cpu.regA) & 0xFF );
	if ( cpu.regS === 0 ) {
		cpu.regS = 0xFF;
	} else {
		cpu.regS--;
	}
	return cyclesTaken;
};
instructions_TRACE[ 72 ] = PHA_NONE_72_TRACE;
function EOR_IMMEDIATE_73_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 73;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA = ( cpu.regA ^ ( readInValue & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 73 ] = EOR_IMMEDIATE_73_TRACE;
function LSR_ACCUMULATOR_74_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 74;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setCarry((readInValue & 0x01) > 0);
	var result = ( readInValue & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 74 ] = LSR_ACCUMULATOR_74_TRACE;
function ALR_IMMEDIATE_75_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 75;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue;
	cpu.setCarry((cpu.regA & 0x01) > 0);
	cpu.regA = ( cpu.regA >> 1 ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 75 ] = ALR_IMMEDIATE_75_TRACE;
function JMP_IMMEDIATE16_76_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 76;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.setPC( ( readInValue ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 76 ] = JMP_IMMEDIATE16_76_TRACE;
function EOR_ABSOLUTE_77_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 77;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 77 ] = EOR_ABSOLUTE_77_TRACE;
function LSR_ABSOLUTE_78_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 78;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 78 ] = LSR_ABSOLUTE_78_TRACE;
function LSE_ABSOLUTE_79_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 79;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 79 ] = LSE_ABSOLUTE_79_TRACE;
function BVC_RELATIVE_80_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 80;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = !cpu.getOverflow();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 80 ] = BVC_RELATIVE_80_TRACE;
function EOR_INDIRECTY_81_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 81;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 81 ] = EOR_INDIRECTY_81_TRACE;
function HLT_NONE_82_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 82;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 82 ] = HLT_NONE_82_TRACE;
function LSE_INDIRECTY_83_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 83;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 83 ] = LSE_INDIRECTY_83_TRACE;
function SKB_ZEROPAGEX_84_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 84;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 84 ] = SKB_ZEROPAGEX_84_TRACE;
function EOR_ZEROPAGEX_85_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 85;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 85 ] = EOR_ZEROPAGEX_85_TRACE;
function LSR_ZEROPAGEX_86_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 86;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 86 ] = LSR_ZEROPAGEX_86_TRACE;
function LSE_ZEROPAGEX_87_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 87;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 87 ] = LSE_ZEROPAGEX_87_TRACE;
function CLI_NONE_88_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 88;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.waitOneInstructionAfterCli = cpu.getInterrupt() === true;
	cpu.setInterrupt( false );
	return cyclesTaken;
};
instructions_TRACE[ 88 ] = CLI_NONE_88_TRACE;
function EOR_ABSOLUTEY_89_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 89;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 89 ] = EOR_ABSOLUTEY_89_TRACE;
function NOP_NONE_90_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 90;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions_TRACE[ 90 ] = NOP_NONE_90_TRACE;
function LSE_ABSOLUTEY_91_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 91;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 91 ] = LSE_ABSOLUTEY_91_TRACE;
function SKW_ABSOLUTEX_92_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 92;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 92 ] = SKW_ABSOLUTEX_92_TRACE;
function EOR_ABSOLUTEX_93_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 93;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = ( cpu.regA ^ ( operationModeData & 0xFF ) ) & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 93 ] = EOR_ABSOLUTEX_93_TRACE;
function LSR_ABSOLUTEX_94_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 94;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData & 0xFF ) >> 1;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 94 ] = LSR_ABSOLUTEX_94_TRACE;
function LSE_ABSOLUTEX_95_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 95;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	cpu.setCarry((operationModeData & 0x01) > 0);
	var result = ( operationModeData >> 1 ) & 0xFF;
	cpu.regA ^= result;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 95 ] = LSE_ABSOLUTEX_95_TRACE;
function RTS_NONE_96_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 96;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	// dummy read
	cpu.incrementSubcycle();
	memory.read8( cpu.getPC() );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	cpu.programCounter = memory.read8( 0x100 + cpu.regS );
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	var temp = memory.read8( 0x100 + cpu.regS );
	cpu.programCounter |= ( temp & 0xFF ) << 8;
	cpu.incrementSubcycle();
	cpu.programCounter = ( cpu.getPC() + 1 ) & 0xFFFF;
	return cyclesTaken;
};
instructions_TRACE[ 96 ] = RTS_NONE_96_TRACE;
function ADC_INDIRECTX_97_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 97;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 97 ] = ADC_INDIRECTX_97_TRACE;
function HLT_NONE_98_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 98;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 98 ] = HLT_NONE_98_TRACE;
function RRA_INDIRECTX_99_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 99;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 99 ] = RRA_INDIRECTX_99_TRACE;
function SKB_ZEROPAGE_100_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 100;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 100 ] = SKB_ZEROPAGE_100_TRACE;
function ADC_ZEROPAGE_101_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 101;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 101 ] = ADC_ZEROPAGE_101_TRACE;
function ROR_ZEROPAGE_102_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 102;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 102 ] = ROR_ZEROPAGE_102_TRACE;
function RRA_ZEROPAGE_103_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 103;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 103 ] = RRA_ZEROPAGE_103_TRACE;
function PLA_NONE_104_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 104;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	if ( cpu.regS === 0xFF ) {
		cpu.regS = 0;
	} else {
		cpu.regS++;
	}
	cpu.incrementSubcycle();
	cpu.regA = memory.read8( 0x100 + cpu.regS );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 104 ] = PLA_NONE_104_TRACE;
function ADC_IMMEDIATE_105_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 105;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = ( readInValue & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( readInValue ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 105 ] = ADC_IMMEDIATE_105_TRACE;
function ROR_ACCUMULATOR_106_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 106;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.regA;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var result = ( (readInValue & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( readInValue & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.regA = result & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 106 ] = ROR_ACCUMULATOR_106_TRACE;
function ARR_IMMEDIATE_107_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 107;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA &= readInValue & 0xFF;
	cpu.regA = ( ( cpu.regA >> 1 ) & 0xFF ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( cpu.regA & 0x1 ) > 0 );
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	cpu.setOverflow( false );
	cpu.setCarry( false )
	switch ( cpu.regA & 0x60 )
	{
	case 0x20: cpu.setOverflow( true ); break;
	case 0x40: cpu.setOverflow( true );
	cpu.setCarry( true ); break;
	case 0x60: cpu.setCarry( true ); break;
	}
	return cyclesTaken;
};
instructions_TRACE[ 107 ] = ARR_IMMEDIATE_107_TRACE;
function JMP_INDIRECT_108_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 108;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.setPC( ( readInValue ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 108 ] = JMP_INDIRECT_108_TRACE;
function ADC_ABSOLUTE_109_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 109;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 109 ] = ADC_ABSOLUTE_109_TRACE;
function ROR_ABSOLUTE_110_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 110;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 110 ] = ROR_ABSOLUTE_110_TRACE;
function RRA_ABSOLUTE_111_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 111;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 111 ] = RRA_ABSOLUTE_111_TRACE;
function BVS_RELATIVE_112_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 112;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = cpu.getOverflow();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 112 ] = BVS_RELATIVE_112_TRACE;
function ADC_INDIRECTY_113_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 113;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 113 ] = ADC_INDIRECTY_113_TRACE;
function HLT_NONE_114_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 114;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 114 ] = HLT_NONE_114_TRACE;
function RRA_INDIRECTY_115_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 115;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 115 ] = RRA_INDIRECTY_115_TRACE;
function SKB_ZEROPAGEX_116_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 116;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 116 ] = SKB_ZEROPAGEX_116_TRACE;
function ADC_ZEROPAGEX_117_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 117;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 117 ] = ADC_ZEROPAGEX_117_TRACE;
function ROR_ZEROPAGEX_118_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 118;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 118 ] = ROR_ZEROPAGEX_118_TRACE;
function RRA_ZEROPAGEX_119_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 119;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 119 ] = RRA_ZEROPAGEX_119_TRACE;
function SEI_NONE_120_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 120;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setInterrupt( true );
	return cyclesTaken;
};
instructions_TRACE[ 120 ] = SEI_NONE_120_TRACE;
function ADC_ABSOLUTEY_121_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 121;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 121 ] = ADC_ABSOLUTEY_121_TRACE;
function NOP_NONE_122_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 122;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions_TRACE[ 122 ] = NOP_NONE_122_TRACE;
function RRA_ABSOLUTEY_123_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 123;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 123 ] = RRA_ABSOLUTEY_123_TRACE;
function SKW_ABSOLUTEX_124_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 124;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 124 ] = SKW_ABSOLUTEX_124_TRACE;
function ADC_ABSOLUTEX_125_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 125;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = ( operationModeData & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( operationModeData ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	return cyclesTaken;
};
instructions_TRACE[ 125 ] = ADC_ABSOLUTEX_125_TRACE;
function ROR_ABSOLUTEX_126_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 126;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( (operationModeData & 0xFF) >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( operationModeData & 0x1 );
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 126 ] = ROR_ABSOLUTEX_126_TRACE;
function RRA_ABSOLUTEX_127_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 127;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( operationModeData >> 1 ) | ( cpu.getCarry() ? 0x80 : 0 );
	cpu.setCarry( ( operationModeData & 0x1 ) > 0 );
	var temp = ( result & 0xFF ) + cpu.regA + (cpu.getCarry() ? 1 : 0);
	cpu.setCarry( temp > 0xFF );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ ( result ^ 0xFF ) ) & 0x80) );
	cpu.regA = temp & 0xFF;
	result &= 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 127 ] = RRA_ABSOLUTEX_127_TRACE;
function SKB_IMMEDIATE_128_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 128;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 128 ] = SKB_IMMEDIATE_128_TRACE;
function STA_INDIRECTX_129_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 129;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 129 ] = STA_INDIRECTX_129_TRACE;
function SKB_IMMEDIATE_130_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 130;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 130 ] = SKB_IMMEDIATE_130_TRACE;
function AXS_INDIRECTX_131_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 131;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 131 ] = AXS_INDIRECTX_131_TRACE;
function STY_ZEROPAGE_132_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 132;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regY;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 132 ] = STY_ZEROPAGE_132_TRACE;
function STA_ZEROPAGE_133_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 133;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 133 ] = STA_ZEROPAGE_133_TRACE;
function STX_ZEROPAGE_134_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 134;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 134 ] = STX_ZEROPAGE_134_TRACE;
function AXS_ZEROPAGE_135_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 135;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 135 ] = AXS_ZEROPAGE_135_TRACE;
function DEY_NONE_136_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 136;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regY--;
	if ( cpu.regY < 0 )
		cpu.regY = 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 136 ] = DEY_NONE_136_TRACE;
function SKB_IMMEDIATE_137_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 137;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 137 ] = SKB_IMMEDIATE_137_TRACE;
function TXA_NONE_138_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 138;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regA = cpu.regX;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 138 ] = TXA_NONE_138_TRACE;
function XAA_IMMEDIATE_139_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 139;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA = cpu.regX & readInValue;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 139 ] = XAA_IMMEDIATE_139_TRACE;
function STY_ABSOLUTE_140_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 140;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regY;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 140 ] = STY_ABSOLUTE_140_TRACE;
function STA_ABSOLUTE_141_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 141;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 141 ] = STA_ABSOLUTE_141_TRACE;
function STX_ABSOLUTE_142_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 142;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 142 ] = STX_ABSOLUTE_142_TRACE;
function AXS_ABSOLUTE_143_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 143;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 143 ] = AXS_ABSOLUTE_143_TRACE;
function BCC_RELATIVE_144_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 144;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = !cpu.getCarry();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 144 ] = BCC_RELATIVE_144_TRACE;
function STA_INDIRECTY_145_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 145;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 145 ] = STA_INDIRECTY_145_TRACE;
function HLT_NONE_146_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 146;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 146 ] = HLT_NONE_146_TRACE;
function AXA_INDIRECTY_147_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 147;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = ( cpu.regX & cpu.regA ) & 0x7;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 147 ] = AXA_INDIRECTY_147_TRACE;
function STY_ZEROPAGEX_148_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 148;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regY;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 148 ] = STY_ZEROPAGEX_148_TRACE;
function STA_ZEROPAGEX_149_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 149;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 149 ] = STA_ZEROPAGEX_149_TRACE;
function STX_ZEROPAGEY_150_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 150;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 150 ] = STX_ZEROPAGEY_150_TRACE;
function AXS_ZEROPAGEY_151_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 151;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var result = cpu.regA & cpu.regX;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 151 ] = AXS_ZEROPAGEY_151_TRACE;
function TYA_NONE_152_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 152;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regA = cpu.regY;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 152 ] = TYA_NONE_152_TRACE;
function STA_ABSOLUTEY_153_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 153;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 153 ] = STA_ABSOLUTEY_153_TRACE;
function TXS_NONE_154_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 154;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regS = cpu.regX;
	return cyclesTaken;
};
instructions_TRACE[ 154 ] = TXS_NONE_154_TRACE;
function TAS_ABSOLUTEY_155_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 155;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.regS = cpu.regX & cpu.regA;
	return cyclesTaken;
};
instructions_TRACE[ 155 ] = TAS_ABSOLUTEY_155_TRACE;
function SAY_SAY_156_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 156;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.SAYHighByte = memory.read8( ( cpu.getPC() + 2 ) & 0xFFFF );
	address |= ( cpu.SAYHighByte ) << 8;
	var readInValue = ( address + cpu.regX ) & 0xFFFF; // SAY writes to absolute X but needs the high byte of the address to operate on
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = cpu.regY & ( ( cpu.SAYHighByte + 1 ) & 0xFF );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 156 ] = SAY_SAY_156_TRACE;
function STA_ABSOLUTEX_157_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 157;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = cpu.regA;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 157 ] = STA_ABSOLUTEX_157_TRACE;
function XAS_ABSOLUTEY_158_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 158;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction XAS not implemented");
	cpu.incrementSubcycle();
	memory.write8( readInValue, result );
	return cyclesTaken;
};
instructions_TRACE[ 158 ] = XAS_ABSOLUTEY_158_TRACE;
function AXA_ABSOLUTEY_159_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 159;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = ( cpu.regX & cpu.regA ) & 0x7;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 159 ] = AXA_ABSOLUTEY_159_TRACE;
function LDY_IMMEDIATE_160_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 160;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regY = readInValue & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 160 ] = LDY_IMMEDIATE_160_TRACE;
function LDA_INDIRECTX_161_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 161;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 161 ] = LDA_INDIRECTX_161_TRACE;
function LDX_IMMEDIATE_162_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 162;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regX = readInValue & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 162 ] = LDX_IMMEDIATE_162_TRACE;
function LAX_INDIRECTX_163_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 163;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 163 ] = LAX_INDIRECTX_163_TRACE;
function LDY_ZEROPAGE_164_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 164;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 164 ] = LDY_ZEROPAGE_164_TRACE;
function LDA_ZEROPAGE_165_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 165;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 165 ] = LDA_ZEROPAGE_165_TRACE;
function LDX_ZEROPAGE_166_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 166;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 166 ] = LDX_ZEROPAGE_166_TRACE;
function LAX_ZEROPAGE_167_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 167;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 167 ] = LAX_ZEROPAGE_167_TRACE;
function TAY_NONE_168_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 168;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regY = cpu.regA;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 168 ] = TAY_NONE_168_TRACE;
function LDA_IMMEDIATE_169_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 169;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regA = readInValue & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 169 ] = LDA_IMMEDIATE_169_TRACE;
function TAX_NONE_170_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 170;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX = cpu.regA;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 170 ] = TAX_NONE_170_TRACE;
function OAL_IMMEDIATE_171_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 171;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.regX = cpu.regA = readInValue & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 171 ] = OAL_IMMEDIATE_171_TRACE;
function LDY_ABSOLUTE_172_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 172;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 172 ] = LDY_ABSOLUTE_172_TRACE;
function LDA_ABSOLUTE_173_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 173;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 173 ] = LDA_ABSOLUTE_173_TRACE;
function LDX_ABSOLUTE_174_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 174;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 174 ] = LDX_ABSOLUTE_174_TRACE;
function LAX_ABSOLUTE_175_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 175;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 175 ] = LAX_ABSOLUTE_175_TRACE;
function BCS_RELATIVE_176_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 176;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = cpu.getCarry();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 176 ] = BCS_RELATIVE_176_TRACE;
function LDA_INDIRECTY_177_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 177;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 177 ] = LDA_INDIRECTY_177_TRACE;
function HLT_NONE_178_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 178;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 178 ] = HLT_NONE_178_TRACE;
function LAX_INDIRECTY_179_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 179;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 179 ] = LAX_INDIRECTY_179_TRACE;
function LDY_ZEROPAGEX_180_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 180;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 180 ] = LDY_ZEROPAGEX_180_TRACE;
function LDA_ZEROPAGEX_181_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 181;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 181 ] = LDA_ZEROPAGEX_181_TRACE;
function LDX_ZEROPAGEY_182_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 182;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 182 ] = LDX_ZEROPAGEY_182_TRACE;
function LAX_ZEROPAGEY_183_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 183;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 183 ] = LAX_ZEROPAGEY_183_TRACE;
function CLV_NONE_184_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 184;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setOverflow( false );
	return cyclesTaken;
};
instructions_TRACE[ 184 ] = CLV_NONE_184_TRACE;
function LDA_ABSOLUTEY_185_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 185;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 185 ] = LDA_ABSOLUTEY_185_TRACE;
function TSX_NONE_186_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 186;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX = cpu.regS & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 186 ] = TSX_NONE_186_TRACE;
function LAS_ABSOLUTEY_187_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 187;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var result = 0
	console.log("illegal instruction LAS not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 187 ] = LAS_ABSOLUTEY_187_TRACE;
function LDY_ABSOLUTEX_188_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 188;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regY = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 188 ] = LDY_ABSOLUTEX_188_TRACE;
function LDA_ABSOLUTEX_189_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 189;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 189 ] = LDA_ABSOLUTEX_189_TRACE;
function LDX_ABSOLUTEY_190_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 190;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regX = operationModeData & 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 190 ] = LDX_ABSOLUTEY_190_TRACE;
function LAX_ABSOLUTEY_191_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 191;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.regA = operationModeData;
	cpu.regX = operationModeData;
	cpu.setSign( ( cpu.regA & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regA & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 191 ] = LAX_ABSOLUTEY_191_TRACE;
function CPY_IMMEDIATE_192_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 192;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regY - readInValue; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 192 ] = CPY_IMMEDIATE_192_TRACE;
function CMP_INDIRECTX_193_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 193;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 193 ] = CMP_INDIRECTX_193_TRACE;
function SKB_IMMEDIATE_194_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 194;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 194 ] = SKB_IMMEDIATE_194_TRACE;
function DCM_INDIRECTX_195_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 195;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 195 ] = DCM_INDIRECTX_195_TRACE;
function CPY_ZEROPAGE_196_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 196;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regY - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 196 ] = CPY_ZEROPAGE_196_TRACE;
function CMP_ZEROPAGE_197_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 197;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 197 ] = CMP_ZEROPAGE_197_TRACE;
function DEC_ZEROPAGE_198_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 198;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 198 ] = DEC_ZEROPAGE_198_TRACE;
function DCM_ZEROPAGE_199_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 199;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 199 ] = DCM_ZEROPAGE_199_TRACE;
function INY_NONE_200_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 200;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regY++;
	if ( cpu.regY > 0xFF )
		cpu.regY = 0;
	cpu.setSign( ( cpu.regY & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regY & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 200 ] = INY_NONE_200_TRACE;
function CMP_IMMEDIATE_201_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 201;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regA - readInValue;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 201 ] = CMP_IMMEDIATE_201_TRACE;
function DEX_NONE_202_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 202;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX--;
	if ( cpu.regX < 0 )
		cpu.regX = 0xFF;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 202 ] = DEX_NONE_202_TRACE;
function SAX_IMMEDIATE_203_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 203;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = ( cpu.regA & cpu.regX ) - readInValue;
	cpu.regX = temp & 0xFF;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 203 ] = SAX_IMMEDIATE_203_TRACE;
function CPY_ABSOLUTE_204_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 204;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regY - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 204 ] = CPY_ABSOLUTE_204_TRACE;
function CMP_ABSOLUTE_205_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 205;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 205 ] = CMP_ABSOLUTE_205_TRACE;
function DEC_ABSOLUTE_206_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 206;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 206 ] = DEC_ABSOLUTE_206_TRACE;
function DCM_ABSOLUTE_207_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 207;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 207 ] = DCM_ABSOLUTE_207_TRACE;
function BNE_RELATIVE_208_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 208;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = !cpu.getZero();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 208 ] = BNE_RELATIVE_208_TRACE;
function CMP_INDIRECTY_209_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 209;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 209 ] = CMP_INDIRECTY_209_TRACE;
function HLT_NONE_210_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 210;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 210 ] = HLT_NONE_210_TRACE;
function DCM_INDIRECTY_211_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 211;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 211 ] = DCM_INDIRECTY_211_TRACE;
function SKB_ZEROPAGEX_212_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 212;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 212 ] = SKB_ZEROPAGEX_212_TRACE;
function CMP_ZEROPAGEX_213_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 213;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 213 ] = CMP_ZEROPAGEX_213_TRACE;
function DEC_ZEROPAGEX_214_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 214;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 214 ] = DEC_ZEROPAGEX_214_TRACE;
function DCM_ZEROPAGEX_215_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 215;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 215 ] = DCM_ZEROPAGEX_215_TRACE;
function CLD_NONE_216_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 216;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setDecimal( false );
	return cyclesTaken;
};
instructions_TRACE[ 216 ] = CLD_NONE_216_TRACE;
function CMP_ABSOLUTEY_217_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 217;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 217 ] = CMP_ABSOLUTEY_217_TRACE;
function NOP_NONE_218_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 218;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions_TRACE[ 218 ] = NOP_NONE_218_TRACE;
function DCM_ABSOLUTEY_219_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 219;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 219 ] = DCM_ABSOLUTEY_219_TRACE;
function SKW_ABSOLUTEX_220_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 220;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 220 ] = SKW_ABSOLUTEX_220_TRACE;
function CMP_ABSOLUTEX_221_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 221;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 221 ] = CMP_ABSOLUTEX_221_TRACE;
function DEC_ABSOLUTEX_222_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 222;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 222 ] = DEC_ABSOLUTEX_222_TRACE;
function DCM_ABSOLUTEX_223_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 223;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData - 1;
	if ( result < 0 )
		result = 0xFF;
	var temp = cpu.regA - result;
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 223 ] = DCM_ABSOLUTEX_223_TRACE;
function CPX_IMMEDIATE_224_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 224;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regX - readInValue; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 224 ] = CPX_IMMEDIATE_224_TRACE;
function SBC_INDIRECTX_225_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 225;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 225 ] = SBC_INDIRECTX_225_TRACE;
function SKB_IMMEDIATE_226_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 226;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	return cyclesTaken;
};
instructions_TRACE[ 226 ] = SKB_IMMEDIATE_226_TRACE;
function INS_INDIRECTX_227_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 227;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	cpu.incrementSubcycle();
	address = ( address + cpu.regX ) & 0xFF;
	var readInValue = cpu.read16FromMemWithWrap( address );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 227 ] = INS_INDIRECTX_227_TRACE;
function CPX_ZEROPAGE_228_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 228;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regX - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 228 ] = CPX_ZEROPAGE_228_TRACE;
function SBC_ZEROPAGE_229_TRACE( cpu, memory ) {
	var cyclesTaken = 3;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 229;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 229 ] = SBC_ZEROPAGE_229_TRACE;
function INC_ZEROPAGE_230_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 230;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 230 ] = INC_ZEROPAGE_230_TRACE;
function INS_ZEROPAGE_231_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 231;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 231 ] = INS_ZEROPAGE_231_TRACE;
function INX_NONE_232_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 232;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.regX++;
	if ( cpu.regX > 0xFF )
		cpu.regX = 0;
	cpu.setSign( ( cpu.regX & 0x80 ) > 0 );
	cpu.setZero( ( cpu.regX & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 232 ] = INX_NONE_232_TRACE;
function SBC_IMMEDIATE_233_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 233;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regA - readInValue - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ readInValue ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 233 ] = SBC_IMMEDIATE_233_TRACE;
function NOP_NONE_234_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 234;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions_TRACE[ 234 ] = NOP_NONE_234_TRACE;
function SBC_IMMEDIATE_235_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 235;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var readInValue = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	var temp = cpu.regA - readInValue - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ readInValue ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 235 ] = SBC_IMMEDIATE_235_TRACE;
function CPX_ABSOLUTE_236_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 236;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regX - operationModeData; // purposely not wrapped
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	return cyclesTaken;
};
instructions_TRACE[ 236 ] = CPX_ABSOLUTE_236_TRACE;
function SBC_ABSOLUTE_237_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 237;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 237 ] = SBC_ABSOLUTE_237_TRACE;
function INC_ABSOLUTE_238_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 238;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 238 ] = INC_ABSOLUTE_238_TRACE;
function INS_ABSOLUTE_239_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 239;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var readInValue = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = readInValue;
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 239 ] = INS_ABSOLUTE_239_TRACE;
function BEQ_RELATIVE_240_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 240;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	var readInValue = cpu.calculateRelativeDifference( (cpu.getPC()|0), (address|0) );
	formatData.opcodeParam = address;
	formatData.operationParam = ( readInValue + 2 ) & 0xFFFF
	var branchTaken = cpu.getZero();
	if ( branchTaken ) {
	cpu.incrementSubcycle();
		if ( ( ((cpu.getPC() + 2) & 0xff00 ) !== ( ((readInValue + 2) ) & 0xff00 ) ) ) {
			cyclesTaken += 1
	cpu.incrementSubcycle();
		}
		cyclesTaken += 1;
	cpu.incrementSubcycle();
		cpu.setPC( ( readInValue + 2 ) & 0xFFFF );
	} else {
	cpu.incrementSubcycle();
		memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
		cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	}
	return cyclesTaken;
};
instructions_TRACE[ 240 ] = BEQ_RELATIVE_240_TRACE;
function SBC_INDIRECTY_241_TRACE( cpu, memory ) {
	var cyclesTaken = 5;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 241;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 241 ] = SBC_INDIRECTY_241_TRACE;
function HLT_NONE_242_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 242;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	var result = 0
	console.log("illegal instruction HLT not implemented");
	return cyclesTaken;
};
instructions_TRACE[ 242 ] = HLT_NONE_242_TRACE;
function INS_INDIRECTY_243_TRACE( cpu, memory ) {
	var cyclesTaken = 8;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 243;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	address = cpu.read16FromMemWithWrap( address );
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 243 ] = INS_INDIRECTY_243_TRACE;
function SKB_ZEROPAGEX_244_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 244;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 244 ] = SKB_ZEROPAGEX_244_TRACE;
function SBC_ZEROPAGEX_245_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 245;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 245 ] = SBC_ZEROPAGEX_245_TRACE;
function INC_ZEROPAGEX_246_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 246;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 246 ] = INC_ZEROPAGEX_246_TRACE;
function INS_ZEROPAGEX_247_TRACE( cpu, memory ) {
	var cyclesTaken = 6;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 247;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.incrementSubcycle();
	var address = memory.read8( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 2 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 247 ] = INS_ZEROPAGEX_247_TRACE;
function SED_NONE_248_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 248;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	cpu.setDecimal( true );
	return cyclesTaken;
};
instructions_TRACE[ 248 ] = SED_NONE_248_TRACE;
function SBC_ABSOLUTEY_249_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 249;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	if ( ( ( address + cpu.regY ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 249 ] = SBC_ABSOLUTEY_249_TRACE;
function NOP_NONE_250_TRACE( cpu, memory ) {
	var cyclesTaken = 2;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 250;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	cpu.setPC( ( cpu.getPC() + 1 ) & 0xFFFF );
	cpu.incrementSubcycle();
	return cyclesTaken;
};
instructions_TRACE[ 250 ] = NOP_NONE_250_TRACE;
function INS_ABSOLUTEY_251_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 251;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regY ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regY) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 251 ] = INS_ABSOLUTEY_251_TRACE;
function SKW_ABSOLUTEX_252_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 252;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	return cyclesTaken;
};
instructions_TRACE[ 252 ] = SKW_ABSOLUTEX_252_TRACE;
function SBC_ABSOLUTEX_253_TRACE( cpu, memory ) {
	var cyclesTaken = 4;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 253;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	if ( ( ( address + cpu.regX ) & 0xFF00 ) !== ( address & 0xFF00 ) ) { // Only do dummy read if page boundary crossed
		cyclesTaken++
		cpu.incrementSubcycle();
		memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	}
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	var temp = cpu.regA - operationModeData - ( cpu.getCarry() ? 0 : 1 );
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ operationModeData ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = ( temp & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 253 ] = SBC_ABSOLUTEX_253_TRACE;
function INC_ABSOLUTEX_254_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 254;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 254 ] = INC_ABSOLUTEX_254_TRACE;
function INS_ABSOLUTEX_255_TRACE( cpu, memory ) {
	var cyclesTaken = 7;
	formatData.programCounter = cpu.getPC();
	formatData.opcode = 255;
	formatData.regs.a = cpu.regA;
	formatData.regs.x = cpu.regX;
	formatData.regs.y = cpu.regY;
	formatData.regs.p = cpu.statusRegToByte();
	formatData.regs.sp = cpu.regS;
	var address = cpu.read16FromMemNoWrap( ( cpu.getPC() + 1 ) & 0xFFFF );
	formatData.opcodeParam = address;
	var readInValue = ( address + cpu.regX ) & 0xFFFF;
	cpu.incrementSubcycle();
	memory.read8( (address & 0xFF00) | ((address + cpu.regX) & 0xFF) );
	cpu.setPC( ( cpu.getPC() + 3 ) & 0xFFFF );
	cpu.incrementSubcycle();
	var operationModeData = memory.read8( readInValue );
	formatData.operationParam = operationModeData;
	cpu.incrementSubcycle();
	memory.write8( readInValue, operationModeData );
	var result = operationModeData + 1;
	if ( result > 0xFF )
		result = 0;
	cpu.setSign( ( result & 0x80 ) > 0 );
	cpu.setZero( ( result & 0xFF ) === 0 );
	var temp = cpu.regA - result - (cpu.getCarry() ? 0 : 1);
	cpu.setSign( ( temp & 0x80 ) > 0 );
	cpu.setZero( ( temp & 0xFF ) === 0 );
	cpu.setOverflow( (( cpu.regA ^ temp ) & 0x80) && (( cpu.regA ^ result ) & 0x80) );
	cpu.setCarry( temp >= 0 && temp < 0x100 );
	cpu.regA = temp & 0xFF;
	cpu.incrementSubcycle();
	memory.write8( readInValue, result & 0xFF );
	return cyclesTaken;
};
instructions_TRACE[ 255 ] = INS_ABSOLUTEX_255_TRACE;

Nes.cpuInstructionsTrace = instructions_TRACE;
Nes.cpuTrace = formatData;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

// This file has been automatically generated by the cpuCoreBuilder.js tool

(function(){
	"use strict";
	
	var formatCpuTraceString = [];
	var formatStr;
	formatCpuTraceString[ 0 ] = function( formatData ) { // BRK NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BRK ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 1 ] = function( formatData ) { // ORA INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 2 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 3 ] = function( formatData ) { // ASO INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASO ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 4 ] = function( formatData ) { // SKB ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 5 ] = function( formatData ) { // ORA ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 6 ] = function( formatData ) { // ASL ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 7 ] = function( formatData ) { // ASO ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASO ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 8 ] = function( formatData ) { // PHP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " PHP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 9 ] = function( formatData ) { // ORA IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 10 ] = function( formatData ) { // ASL ACCUMULATOR
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASL ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 11 ] = function( formatData ) { // ANC IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ANC ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 12 ] = function( formatData ) { // SKW ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKW ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 13 ] = function( formatData ) { // ORA ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 14 ] = function( formatData ) { // ASL ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 15 ] = function( formatData ) { // ASO ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASO ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 16 ] = function( formatData ) { // BPL RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BPL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 17 ] = function( formatData ) { // ORA INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 18 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 19 ] = function( formatData ) { // ASO INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASO ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 20 ] = function( formatData ) { // SKB ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 21 ] = function( formatData ) { // ORA ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 22 ] = function( formatData ) { // ASL ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 23 ] = function( formatData ) { // ASO ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASO ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 24 ] = function( formatData ) { // CLC NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CLC ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 25 ] = function( formatData ) { // ORA ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 26 ] = function( formatData ) { // NOP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " NOP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 27 ] = function( formatData ) { // ASO ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASO ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 28 ] = function( formatData ) { // SKW ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKW ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 29 ] = function( formatData ) { // ORA ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ORA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 30 ] = function( formatData ) { // ASL ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 31 ] = function( formatData ) { // ASO ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ASO ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 32 ] = function( formatData ) { // JSR IMMEDIATE16
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " JSR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 33 ] = function( formatData ) { // AND INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 34 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 35 ] = function( formatData ) { // RLA INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RLA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 36 ] = function( formatData ) { // BIT ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BIT ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 37 ] = function( formatData ) { // AND ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 38 ] = function( formatData ) { // ROL ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 39 ] = function( formatData ) { // RLA ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RLA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 40 ] = function( formatData ) { // PLP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " PLP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 41 ] = function( formatData ) { // AND IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 42 ] = function( formatData ) { // ROL ACCUMULATOR
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROL ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 43 ] = function( formatData ) { // ANC IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ANC ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 44 ] = function( formatData ) { // BIT ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BIT ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 45 ] = function( formatData ) { // AND ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 46 ] = function( formatData ) { // ROL ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 47 ] = function( formatData ) { // RLA ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RLA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 48 ] = function( formatData ) { // BMI RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BMI ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 49 ] = function( formatData ) { // AND INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 50 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 51 ] = function( formatData ) { // RLA INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RLA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 52 ] = function( formatData ) { // SKB ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 53 ] = function( formatData ) { // AND ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 54 ] = function( formatData ) { // ROL ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 55 ] = function( formatData ) { // RLA ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RLA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 56 ] = function( formatData ) { // SEC NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SEC ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 57 ] = function( formatData ) { // AND ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 58 ] = function( formatData ) { // NOP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " NOP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 59 ] = function( formatData ) { // RLA ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RLA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 60 ] = function( formatData ) { // SKW ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKW ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 61 ] = function( formatData ) { // AND ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AND ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 62 ] = function( formatData ) { // ROL ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROL ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 63 ] = function( formatData ) { // RLA ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RLA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 64 ] = function( formatData ) { // RTI NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RTI ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 65 ] = function( formatData ) { // EOR INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 66 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 67 ] = function( formatData ) { // LSE INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSE ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 68 ] = function( formatData ) { // SKB ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 69 ] = function( formatData ) { // EOR ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 70 ] = function( formatData ) { // LSR ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 71 ] = function( formatData ) { // LSE ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSE ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 72 ] = function( formatData ) { // PHA NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " PHA ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 73 ] = function( formatData ) { // EOR IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 74 ] = function( formatData ) { // LSR ACCUMULATOR
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSR ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 75 ] = function( formatData ) { // ALR IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ALR ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 76 ] = function( formatData ) { // JMP IMMEDIATE16
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " JMP ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 77 ] = function( formatData ) { // EOR ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 78 ] = function( formatData ) { // LSR ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 79 ] = function( formatData ) { // LSE ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSE ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 80 ] = function( formatData ) { // BVC RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BVC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 81 ] = function( formatData ) { // EOR INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 82 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 83 ] = function( formatData ) { // LSE INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSE ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 84 ] = function( formatData ) { // SKB ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 85 ] = function( formatData ) { // EOR ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 86 ] = function( formatData ) { // LSR ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 87 ] = function( formatData ) { // LSE ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSE ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 88 ] = function( formatData ) { // CLI NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CLI ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 89 ] = function( formatData ) { // EOR ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 90 ] = function( formatData ) { // NOP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " NOP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 91 ] = function( formatData ) { // LSE ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSE ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 92 ] = function( formatData ) { // SKW ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKW ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 93 ] = function( formatData ) { // EOR ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " EOR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 94 ] = function( formatData ) { // LSR ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 95 ] = function( formatData ) { // LSE ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LSE ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 96 ] = function( formatData ) { // RTS NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RTS ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 97 ] = function( formatData ) { // ADC INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 98 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 99 ] = function( formatData ) { // RRA INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RRA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 100 ] = function( formatData ) { // SKB ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 101 ] = function( formatData ) { // ADC ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 102 ] = function( formatData ) { // ROR ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 103 ] = function( formatData ) { // RRA ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RRA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 104 ] = function( formatData ) { // PLA NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " PLA ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 105 ] = function( formatData ) { // ADC IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 106 ] = function( formatData ) { // ROR ACCUMULATOR
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROR ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 107 ] = function( formatData ) { // ARR IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ARR ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 108 ] = function( formatData ) { // JMP INDIRECT
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " JMP ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ") = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 109 ] = function( formatData ) { // ADC ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 110 ] = function( formatData ) { // ROR ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 111 ] = function( formatData ) { // RRA ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RRA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 112 ] = function( formatData ) { // BVS RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BVS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 113 ] = function( formatData ) { // ADC INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 114 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 115 ] = function( formatData ) { // RRA INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RRA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 116 ] = function( formatData ) { // SKB ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 117 ] = function( formatData ) { // ADC ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 118 ] = function( formatData ) { // ROR ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 119 ] = function( formatData ) { // RRA ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RRA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 120 ] = function( formatData ) { // SEI NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SEI ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 121 ] = function( formatData ) { // ADC ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 122 ] = function( formatData ) { // NOP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " NOP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 123 ] = function( formatData ) { // RRA ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RRA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 124 ] = function( formatData ) { // SKW ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKW ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 125 ] = function( formatData ) { // ADC ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ADC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 126 ] = function( formatData ) { // ROR ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " ROR ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 127 ] = function( formatData ) { // RRA ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " RRA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 128 ] = function( formatData ) { // SKB IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 129 ] = function( formatData ) { // STA INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 130 ] = function( formatData ) { // SKB IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 131 ] = function( formatData ) { // AXS INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AXS ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 132 ] = function( formatData ) { // STY ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 133 ] = function( formatData ) { // STA ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 134 ] = function( formatData ) { // STX ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 135 ] = function( formatData ) { // AXS ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AXS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 136 ] = function( formatData ) { // DEY NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DEY ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 137 ] = function( formatData ) { // SKB IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 138 ] = function( formatData ) { // TXA NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " TXA ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 139 ] = function( formatData ) { // XAA IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " XAA ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 140 ] = function( formatData ) { // STY ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 141 ] = function( formatData ) { // STA ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 142 ] = function( formatData ) { // STX ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 143 ] = function( formatData ) { // AXS ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AXS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 144 ] = function( formatData ) { // BCC RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BCC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 145 ] = function( formatData ) { // STA INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 146 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 147 ] = function( formatData ) { // AXA INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AXA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 148 ] = function( formatData ) { // STY ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 149 ] = function( formatData ) { // STA ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 150 ] = function( formatData ) { // STX ZEROPAGEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 151 ] = function( formatData ) { // AXS ZEROPAGEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AXS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 152 ] = function( formatData ) { // TYA NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " TYA ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 153 ] = function( formatData ) { // STA ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 154 ] = function( formatData ) { // TXS NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " TXS ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 155 ] = function( formatData ) { // TAS ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " TAS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 156 ] = function( formatData ) { // SAY SAY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SAY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 157 ] = function( formatData ) { // STA ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " STA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 158 ] = function( formatData ) { // XAS ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " XAS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 159 ] = function( formatData ) { // AXA ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " AXA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 160 ] = function( formatData ) { // LDY IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDY ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 161 ] = function( formatData ) { // LDA INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 162 ] = function( formatData ) { // LDX IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDX ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 163 ] = function( formatData ) { // LAX INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LAX ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 164 ] = function( formatData ) { // LDY ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 165 ] = function( formatData ) { // LDA ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 166 ] = function( formatData ) { // LDX ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 167 ] = function( formatData ) { // LAX ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LAX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 168 ] = function( formatData ) { // TAY NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " TAY ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 169 ] = function( formatData ) { // LDA IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 170 ] = function( formatData ) { // TAX NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " TAX ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 171 ] = function( formatData ) { // OAL IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " OAL ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 172 ] = function( formatData ) { // LDY ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 173 ] = function( formatData ) { // LDA ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 174 ] = function( formatData ) { // LDX ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 175 ] = function( formatData ) { // LAX ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LAX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 176 ] = function( formatData ) { // BCS RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BCS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 177 ] = function( formatData ) { // LDA INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 178 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 179 ] = function( formatData ) { // LAX INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LAX ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 180 ] = function( formatData ) { // LDY ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 181 ] = function( formatData ) { // LDA ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 182 ] = function( formatData ) { // LDX ZEROPAGEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 183 ] = function( formatData ) { // LAX ZEROPAGEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LAX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 184 ] = function( formatData ) { // CLV NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CLV ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 185 ] = function( formatData ) { // LDA ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 186 ] = function( formatData ) { // TSX NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " TSX ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 187 ] = function( formatData ) { // LAS ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LAS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 188 ] = function( formatData ) { // LDY ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 189 ] = function( formatData ) { // LDA ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDA ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 190 ] = function( formatData ) { // LDX ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LDX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 191 ] = function( formatData ) { // LAX ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " LAX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 192 ] = function( formatData ) { // CPY IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CPY ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 193 ] = function( formatData ) { // CMP INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 194 ] = function( formatData ) { // SKB IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 195 ] = function( formatData ) { // DCM INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DCM ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 196 ] = function( formatData ) { // CPY ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CPY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 197 ] = function( formatData ) { // CMP ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 198 ] = function( formatData ) { // DEC ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DEC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 199 ] = function( formatData ) { // DCM ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DCM ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 200 ] = function( formatData ) { // INY NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INY ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 201 ] = function( formatData ) { // CMP IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 202 ] = function( formatData ) { // DEX NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DEX ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 203 ] = function( formatData ) { // SAX IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SAX ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 204 ] = function( formatData ) { // CPY ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CPY ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 205 ] = function( formatData ) { // CMP ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 206 ] = function( formatData ) { // DEC ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DEC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 207 ] = function( formatData ) { // DCM ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DCM ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 208 ] = function( formatData ) { // BNE RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BNE ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 209 ] = function( formatData ) { // CMP INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 210 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 211 ] = function( formatData ) { // DCM INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DCM ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 212 ] = function( formatData ) { // SKB ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 213 ] = function( formatData ) { // CMP ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 214 ] = function( formatData ) { // DEC ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DEC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 215 ] = function( formatData ) { // DCM ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DCM ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 216 ] = function( formatData ) { // CLD NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CLD ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 217 ] = function( formatData ) { // CMP ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 218 ] = function( formatData ) { // NOP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " NOP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 219 ] = function( formatData ) { // DCM ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DCM ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 220 ] = function( formatData ) { // SKW ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKW ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 221 ] = function( formatData ) { // CMP ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CMP ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 222 ] = function( formatData ) { // DEC ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DEC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 223 ] = function( formatData ) { // DCM ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " DCM ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 224 ] = function( formatData ) { // CPX IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CPX ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 225 ] = function( formatData ) { // SBC INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 226 ] = function( formatData ) { // SKB IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 227 ] = function( formatData ) { // INS INDIRECTX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INS ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X) = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 228 ] = function( formatData ) { // CPX ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CPX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 229 ] = function( formatData ) { // SBC ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 230 ] = function( formatData ) { // INC ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 231 ] = function( formatData ) { // INS ZEROPAGE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 232 ] = function( formatData ) { // INX NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INX ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 233 ] = function( formatData ) { // SBC IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 234 ] = function( formatData ) { // NOP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " NOP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 235 ] = function( formatData ) { // SBC IMMEDIATE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "#$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 236 ] = function( formatData ) { // CPX ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " CPX ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 237 ] = function( formatData ) { // SBC ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 238 ] = function( formatData ) { // INC ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 239 ] = function( formatData ) { // INS ABSOLUTE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + " = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 240 ] = function( formatData ) { // BEQ RELATIVE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " BEQ ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.operationParam, 4 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 241 ] = function( formatData ) { // SBC INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 242 ] = function( formatData ) { // HLT NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " HLT ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 243 ] = function( formatData ) { // INS INDIRECTY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INS ";
		formatStr += "($" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + "), Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 244 ] = function( formatData ) { // SKB ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKB ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 245 ] = function( formatData ) { // SBC ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 246 ] = function( formatData ) { // INC ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 247 ] = function( formatData ) { // INS ZEROPAGEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 2 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 248 ] = function( formatData ) { // SED NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SED ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 249 ] = function( formatData ) { // SBC ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 250 ] = function( formatData ) { // NOP NONE
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " NOP ";
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 251 ] = function( formatData ) { // INS ABSOLUTEY
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", Y = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 252 ] = function( formatData ) { // SKW ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SKW ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 253 ] = function( formatData ) { // SBC ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " SBC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 254 ] = function( formatData ) { // INC ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INC ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	formatCpuTraceString[ 255 ] = function( formatData ) { // INS ABSOLUTEX
		formatStr = ZERO_PAD_HEX( formatData.programCounter, 4 ) + " INS ";
		formatStr += "$" + ZERO_PAD_HEX( formatData.opcodeParam, 4 ) + ", X = " + ZERO_PAD_HEX( formatData.operationParam, 2 );
		while ( formatStr.length < 47 ) { formatStr += " "; }
		formatStr += " A:" + ZERO_PAD_HEX( formatData.regs.a, 2 );
		formatStr += " X:" + ZERO_PAD_HEX( formatData.regs.x, 2 );
		formatStr += " Y:" + ZERO_PAD_HEX( formatData.regs.y, 2 );
		formatStr += " P:" + ZERO_PAD_HEX( formatData.regs.p, 2 );
		formatStr += " SP:" + ZERO_PAD_HEX( formatData.regs.sp, 2 );
		return formatStr;
	};
	
	Nes.formatCpuTraceString = formatCpuTraceString;
}());


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

var maximumTracesToStoreForLoopDetection = 32;

var cpu6502 = function( mainboard ) {
	var that = this;
	this.mainboard = mainboard;
	this.mainboard.connect( 'reset', function( cold ) { that.reset( cold ); } );
	this.executeCallback = null;
	this.cmosVersion = false;
	this.isRunning = true;
	this._traceEnabled = false;
	this._previousTraceProgramCounters = new Uint16Array( maximumTracesToStoreForLoopDetection ); // used to detect loops in cpu traces
	this._previousTraceProgramCountersIndex = 0;
	this._inTraceLoop = false;
	this._traceLoopCount = 0;
	
	//var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
	
	this._useSwitchStatement = false;// isFirefox;
	this._instructionSet = Nes.cpuInstructions; // Default to 'fast' versions
	this._instructionSwitch = Nes.cpuInstructionsSwitch;
	this.resetVariables();
};


cpu6502.prototype.breakPoint = function( resume ) {

	this.isRunning = resume;
};


cpu6502.prototype.enableTrace = function( enabled ) {

	this._traceEnabled = enabled === undefined ? true : enabled;
	if ( this._traceEnabled ) {
		this._instructionSet = Nes.cpuInstructionsTrace; // use slow instructions
	} else {
		this._instructionSet = Nes.cpuInstructions; // use fast instructions
	}
};


cpu6502.prototype.resetVariables = function() {
	this.programCounter = 0;
	this.subcycle = 0;

	this.waitOneInstructionAfterCli = false;
	this.resetPending = false;
	this.nmiPending = false;
	this.irqLineLow = 0;
	this.triggerNmiAfterNextInstruction = false;

	this._flagCarry = false;
	this._flagZero = false;
	this._flagInterrupt = false;
	this._flagDecimal = false;
	this._flagBreak = true;
	this._flagUnused = true;
	this._flagOverflow = false;
	this._flagSign = false;
	
	this.regS = 0;
	this.regX = 0;
	this.regY = 0;
	this.regA = 0;
	this.SAYHighByte = 0;
};


cpu6502.prototype.incrementSubcycle = function() {
	this.subcycle++;
};


cpu6502.prototype.getPC = function() {
	return this.programCounter;
};

cpu6502.prototype.setPC = function( pc ) {
	this.programCounter = pc;
};


cpu6502.prototype.getZero = function() {
	return this._flagZero;
};

cpu6502.prototype.setZero = function( zero ) {
	this._flagZero = zero;
};

cpu6502.prototype.getOverflow = function() {
	return this._flagOverflow;
};

cpu6502.prototype.setOverflow = function( f ) {
	this._flagOverflow = f;
};

cpu6502.prototype.getInterrupt = function() {
	return this._flagInterrupt;
};

cpu6502.prototype.setInterrupt = function( f ) {
	this._flagInterrupt = f;
};

cpu6502.prototype.getBreak = function() {
	return this._flagBreak;
};

cpu6502.prototype.setBreak = function( f ) {
	this._flagBreak = f;
};

cpu6502.prototype.getDecimal = function() {
	return this._flagDecimal;
};

cpu6502.prototype.setDecimal = function( f ) {
	this._flagDecimal = f;
};

cpu6502.prototype.getUnused = function() {
	return this._flagUnused;
};

cpu6502.prototype.setUnused = function( f ) {
	this._flagUnused = f;
};

cpu6502.prototype.getCarry = function() {
	return this._flagCarry;
};

cpu6502.prototype.setCarry = function( f ) {
	this._flagCarry = f;
};


cpu6502.prototype.getSign = function() {
	return this._flagSign;
};

cpu6502.prototype.setSign = function( f ) {
	this._flagSign = f;
};


cpu6502.prototype.getRegA = function() {
	return this.regA;
};

cpu6502.prototype.setRegA = function( f ) {
	this.regA = f;
};


cpu6502.prototype.getRegX = function() {
	return this.regX;
};

cpu6502.prototype.setRegX = function( f ) {
	this.regX = f;
};


cpu6502.prototype.getRegY = function() {
	return this.regY;
};

cpu6502.prototype.setRegY = function( f ) {
	this.regY = f;
};


cpu6502.prototype.setExecuteCallback = function( cb ) {
	this.executeCallback = cb;
};


cpu6502.prototype.getSubCycle = function() {
	return this.subcycle;
};


cpu6502.prototype.handlePendingInterrupts = function() {

	// TODO: if an NMI interrupt is interrupted by a BRK, dont execute the BRK (6502 bug - fixed in the CMOS version)
	if ( this.resetPending )
	{
		for ( var i=0; i<3; ++i )
			this.incrementStackReg(); // increment stack pointer but dont write to memory

		this.setBreak( false );
		this.setInterrupt( true );

		if ( this.cmosVersion )
			this._flagDecimal = false;

		this.programCounter = this.mainboard.memory.read16NoZeroPageWrap( CPU_RESET_ADDRESS );
		//this.programCounter = 0xC000;
		this.resetPending = false;
		return 0;
	}

	if ( this.nmiPending )
	{
		if ( this.triggerNmiAfterNextInstruction )
		{
			this.triggerNmiAfterNextInstruction = false;
			return 0;
		}
		
		// NMI interrupt
		this.pushStack( ( this.programCounter >> 8 ) & 0xFF );
		this.incrementStackReg();
		this.pushStack( this.programCounter & 0xFF );
		this.incrementStackReg();

		this._flagBreak = false;

		this.pushStack( this.statusRegToByte() );
		this.incrementStackReg();

		this._flagInterrupt = true;
		if ( this.cmosVersion )
			this._flagDecimal = false;
		this.programCounter = this.mainboard.memory.read16NoZeroPageWrap( CPU_NMI_ADDRESS );
		this.nmiPending = false;
		return 7;
	}

	if ( this.irqLineLow > 0 && !this.waitOneInstructionAfterCli && !this._flagInterrupt )
	{
		// IRQ interrupt
		this.pushStack( ( this.programCounter >> 8 ) & 0xFF );
		this.incrementStackReg();
		this.pushStack( this.programCounter & 0xFF );
		this.incrementStackReg();
		
		this._flagBreak = false;

		this.pushStack( this.statusRegToByte() );
		this.incrementStackReg();

		this._flagInterrupt = true;
		if ( this.cmosVersion )
			this._flagDecimal = false;
		this.programCounter = this.mainboard.memory.read16NoZeroPageWrap( CPU_IRQ_ADDRESS );
		return 7;
	}
	return 0;
};


cpu6502.prototype.nonMaskableInterrupt = function( ppuMasterTickCount ) {
	this.nmiPending = true;
	if ( this.mainboard.synchroniser.isPpuTickOnLastCycleOfCpuInstruction( ppuMasterTickCount ) ) {
		// CPU is *always* either ahead or equal to the PPU master tick count.
		// Perform 1-instruction delay if NMI is triggered in the last cycle of an instruction
		this.triggerNmiAfterNextInstruction = true;
	}
};


cpu6502.prototype.reset = function() {
	this.resetVariables();
	this.resetPending = true;
};


cpu6502.prototype.holdIrqLineLow = function( low ) {
	if ( low ) {
		this.irqLineLow++;
	} else {
		if ( this.irqLineLow > 0 ) {
			this.irqLineLow--;
		}
	}
};


cpu6502.prototype.statusRegToByte = function() {
	var b = 0;
	b |= ( this._flagCarry ? 0x1 : 0 );
	b |= ( this._flagZero ? 0x2 : 0 );
	b |= ( this._flagInterrupt ? 0x4 : 0 );
	b |= ( this._flagDecimal ? 0x8 : 0 );
	b |= ( this._flagBreak ? 0x10 : 0 );
	b |= ( this._flagUnused ? 0x20 : 0 );
	b |= ( this._flagOverflow ? 0x40 : 0 );
	b |= ( this._flagSign ? 0x80 : 0 );
	return b;
};


cpu6502.prototype.statusRegFromByte = function( b ) {
	this._flagCarry = ( b & 0x1 ) > 0;
	this._flagZero = ( b & 0x2 ) > 0;
	this._flagInterrupt = ( b & 0x4 ) > 0;
	this._flagDecimal = ( b & 0x8 ) > 0;
	this._flagBreak = ( b & 0x10 ) > 0;
	this._flagUnused = ( b & 0x20 ) > 0;
	this._flagOverflow = ( b & 0x40 ) > 0;
	this._flagSign = ( b & 0x80 ) > 0;
};


cpu6502.prototype.incrementStackReg = function() {
	this.regS--;
	if ( this.regS < 0 )
		this.regS = 0xFF;
};


cpu6502.prototype.decrementStackReg = function() {
	this.regS++;
	if ( this.regS > 0xFF )
		this.regS = 0;
};


cpu6502.prototype.pushStack = function( value ) {
	this.mainboard.memory.write8( 0x100 + this.regS, value & 0xFF );
};


cpu6502.prototype.popStack = function( value ) {
	return this.mainboard.memory.read8( 0x100 + this.regS );
};


cpu6502.prototype.read16FromMemNoWrap = function( offsetAddress ) {

	this.incrementSubcycle();
	var ret = this.mainboard.memory.read8( offsetAddress ) & 0xFF;
	this.incrementSubcycle();
	var secondByte = this.mainboard.memory.read8( ( offsetAddress + 1 ) & 0xFFFF );
	ret |= ( ( secondByte & 0xFF ) << 8 );
	return ret & 0xFFFF;
};


cpu6502.prototype.read16FromMemWithWrap = function( offsetAddress ) {

	this.incrementSubcycle();
	var ret = this.mainboard.memory.read8( offsetAddress );
	var newoffset;
	if ( ( offsetAddress & 0xFF ) === 0xFF ) {
		newoffset = ( offsetAddress & 0xFF00 );
	} else {
		newoffset = offsetAddress + 1;
	}
	this.incrementSubcycle();
	var secondByte = this.mainboard.memory.read8( newoffset & 0xFFFF );
	ret |= ( ( secondByte & 0xFF ) << 8 );
	return ret & 0xFFFF;
};


cpu6502.prototype.calculateRelativeDifference = function( pc, b ) {
	var isSigned = (b & 0x80) > 0;
	if ( isSigned )
	{
		var inverse = ( ( b ^ 0xFF) + 1 ) & 0xFF;
		return pc - inverse;
	}
	else
		return pc + b;
};


cpu6502.prototype.execute = function() {
	this.subcycle = 0;
	if ( this.waitOneInstructionAfterCli )
		this.waitOneInstructionAfterCli = false;
	
	var opcode = this.mainboard.memory.read8( this.programCounter );
	var cyclesTaken = 0;
	if ( !this._useSwitchStatement ) {
		cyclesTaken = this._instructionSet[ opcode ]( this, this.mainboard.memory );
	} else {
		cyclesTaken = this._instructionSwitch( opcode, this, this.mainboard.memory );
	}
	if ( this._traceEnabled ) {
		this._doTrace();
	}
	this.subcycle = 0;
	return cyclesTaken;
};


cpu6502.prototype._hasProgramCounterBeenSeenBefore = function( pg ) {

	for ( var i=0; i<this._previousTraceProgramCounters.length; ++i ) {
		if ( this._previousTraceProgramCounters[ i ] === pg ) {
			return i;
		}
	}
	return -1;
};


cpu6502.prototype._doTrace = function() {
	
	var instructionData = Nes.cpuTrace;
	// check previous instructions for the same program counter
	var prevIndex = this._hasProgramCounterBeenSeenBefore( instructionData.programCounter );
	if ( prevIndex >= 0 ) {
		// if it's the same loop as the one that's already detected, don't report.
		if ( !this._inTraceLoop ) {
			this._inTraceLoop = true;
			this._traceLoopCount = 0;
		}
		this._traceLoopCount++;
	} else {
		if ( this._inTraceLoop ) {
			this._inTraceLoop = false;
			this._traceLoopCount = 0;
		}
	}
	
	if ( !this._inTraceLoop ) {
		this._previousTraceProgramCounters[ this._previousTraceProgramCountersIndex ] = instructionData.programCounter;
		this._previousTraceProgramCountersIndex = ( this._previousTraceProgramCountersIndex + 1 ) & 0x1F;
		//$.extend( true, {}, instructionData );
	}
};


cpu6502.prototype.saveState = function() {

	var data = {};
	data.programCounter = this.programCounter;
	data.subcycle = this.subcycle;
	data.waitOneInstructionAfterCli = this.waitOneInstructionAfterCli;
	data.resetPending = this.resetPending;
	data.nmiPending = this.nmiPending;
	data.irqLineLow = this.irqLineLow;
	data.triggerNmiAfterNextInstruction = this.triggerNmiAfterNextInstruction;
	
	data._flagCarry = this._flagCarry;
	data._flagZero = this._flagZero;
	data._flagInterrupt = this._flagInterrupt;
	data._flagDecimal = this._flagDecimal;
	data._flagBreak = this._flagBreak;
	data._flagUnused = this._flagUnused;
	data._flagOverflow = this._flagOverflow;
	data._flagSign = this._flagSign;
	
	data.regS = this.regS;
	data.regX = this.regX;
	data.regY = this.regY;
	data.regA = this.regA;
	data.SAYHighByte = this.SAYHighByte;
	return data;
};


cpu6502.prototype.loadState = function( state ) {

	this.programCounter = state.programCounter;
	this.subcycle = state.subcycle;
	this.waitOneInstructionAfterCli = state.waitOneInstructionAfterCli;
	this.resetPending = state.resetPending;
	this.nmiPending = state.nmiPending;
	this.irqLineLow = state.irqLineLow;
	this.triggerNmiAfterNextInstruction = state.triggerNmiAfterNextInstruction;
	
	this._flagCarry = state._flagCarry;
	this._flagZero = state._flagZero;
	this._flagInterrupt = state._flagInterrupt;
	this._flagDecimal = state._flagDecimal;
	this._flagBreak = state._flagBreak;
	this._flagUnused = state._flagUnused;
	this._flagOverflow = state._flagOverflow;
	this._flagSign = state._flagSign;
	
	this.regS = state.regS;
	this.regX = state.regX;
	this.regY = state.regY;
	this.regA = state.regA;
	this.SAYHighByte = state.SAYHighByte;
};



Nes.cpu6502 = cpu6502;

/* Copyright (C) 2003-2005 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
more details. You should have received a copy of the GNU Lesser General
Public License along with this module; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA */

this.Nes = this.Nes || {};


(function(){
	"use strict";
	
	var header_size = 0x2C;
	var bufferSize = 32768 * 200;
	var sampleSize = 2; // 16 bit samples

	
	var Wave_Writer = function( sampleRate ) {

		this._buffer = new Int16Array( bufferSize );
		this._sampleCount = 0;
		this._active = false;
		this._sample_rate = sampleRate || 44100;
		this._chan_count = 1;
		this._header = new Uint8Array( header_size );
	};
	
	
	Wave_Writer.prototype.activate = function() {
	
		this._active = true;
	};
	
	
	Wave_Writer.prototype.write = function( dataArray, count ) {
	
		if ( this._active ) {
			var toCopy = Math.min( count, bufferSize - this._sampleCount );

			var dataIndex = 0;
			for ( var i=0; i<toCopy; ++i ) {
				// In original code they swapped low/high bytes - not required for this (for some reason??)
				var d = dataArray[ i ];
				//this._buffer[ this._sampleCount++ ] = ( ( d & 0xFF ) << 8 ) | ( ( d & 0xFF00 ) >> 8 );
				this._buffer[ this._sampleCount++ ] = d;
			}
			
			if ( this._sampleCount >= bufferSize ) {
				this._createFile();
				this._sampleCount = 0;
				this._active = false;
			}
		}
	};
	
	
	Wave_Writer.prototype._buildHeader = function( sampleCount ) {
		var ds = sampleCount * sampleSize;
		var rs = header_size - 8 + ds;
		var frame_size = this._chan_count * sampleSize;
		var bps = this._sample_rate * frame_size;
		
		var bufIndex = 0;
		var writeToBuffer = function( buffer, array ) {
			for ( var i=0; i<array.length; ++i ) {
				buffer[ bufIndex++ ] = array[i];
			}
		};
		
		writeToBuffer( this._header, [ 82, 73, 70, 70 ] ); // RIFF
		writeToBuffer( this._header, [ rs, rs>>8, rs>>16, rs>>24 ] ); // length of rest of file
		writeToBuffer( this._header, [ 87, 65, 86, 69, 102, 109, 116, 32 ] ); // WAVE fmt [space]
		writeToBuffer( this._header, [ 0x10, 0, 0, 0 ] ); // size of fmt chunk
		writeToBuffer( this._header, [ 1, 0 ] ); // uncompressed format
		writeToBuffer( this._header, [ this._chan_count, 0 ] ); // channel count
		writeToBuffer( this._header, [ this._sample_rate, this._sample_rate >> 8, this._sample_rate >> 16, this._sample_rate >> 24 ] ); // sample rate
		writeToBuffer( this._header, [ bps, bps >> 8, bps >> 16, bps >> 24 ] ); // bytes per second
		writeToBuffer( this._header, [ frame_size, 0 ] ); // bytes per sample frame
		writeToBuffer( this._header, [ sampleSize * 8, 0 ] ); // bits per sample
		writeToBuffer( this._header, [ 100, 97, 116, 97 ] ); // 'd','a','t','a',
		writeToBuffer( this._header, [ ds, ds>>8, ds>>16, ds>>24 ] ); // size of sample data
	};
	
		
	Wave_Writer.prototype._createFile = function() {
		
		console.log( "Saving sound.wav..." );
		this._buildHeader( this._sampleCount );
		var blob = new Blob( [ this._header, this._buffer ], { type: "application/octet-stream" } );
		saveAs( blob, "sound.wav" );
	};
	
	
	Nes.Wave_Writer = Wave_Writer;
}());


/* Copyright (C) 2003-2005 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
more details. You should have received a copy of the GNU Lesser General
Public License along with this module; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA */

// Buffer of sound samples into which band-limited waveforms can be synthesized
// using Blip_Wave or Blip_Synth.

// Blip_Buffer 0.3.3. Copyright (C) 2003-2005 Shay Green. GNU LGPL license.

this.Nes = this.Nes || {};


(function(){
	"use strict";
	
	var widest_impulse_ = 24;
	var blip_res_bits_ = 5;
	var BLIP_BUFFER_ACCURACY = 16;
	var max_res = 1 << blip_res_bits_;
	
	
	var Blip_eq_t = function( treble, cutoff, samplerate ) {
		this.treble = treble || 0;
		this.cutoff = cutoff || 0;
		this.sample_rate = samplerate || 44100;
	};

	
	var uintArray_memset = function( buf, data, len, startIndex ) {
	
		startIndex = startIndex || 0;
		for ( var i=0; i<len; ++i ) {
			buf[ startIndex + i ] = data;
		}
	};
	
	
	
	
	
	var uintArray_memmove = function( buf, srcIndex, destIndex, len ) {
	
		var tmpArray = null;
		if ( !tmpArray || tmpArray.length < len ) {
			tmpArray = new Uint16Array( len );
		}
		tmpArray.set( buf.subarray( srcIndex, srcIndex + len ), 0 );
		buf.set( tmpArray.subarray( 0, len ), destIndex );
	};
	
	
	var uintArray_memcpy = function( buf, srcIndex, destIndex, len ) {
		buf.set( buf.subarray( srcIndex, srcIndex + len ), destIndex );
	};
	
	
	var blip_default_length = 0;
	var accum_fract = 15; // less than 16 to give extra sample range
	var sample_offset = 0x7F7F; // repeated byte allows memset to clear buffer
		
	
	var Blip_Buffer = function() {

		this.samples_per_sec = 44100;
		this.reader_accum = 0;
		this.bass_shift = 0;
		this.eq = new Blip_eq_t();

		// try to cause assertion failure if buffer is used before these are set
		this.clocks_per_sec = 0;
		this.buffer_ = null;
		this.factor_ = ~0;
		this.offset_ = 0;
		this.buffer_size_ = 0;
		this.length_ = 0;
		
		this.bass_freq_ = 16;
	};
	
	// Set output sample rate and buffer length in milliseconds (1/1000 sec),
	// If there is insufficient memory for the buffer, sets the buffer length
	// to 0 and returns error string (or propagates exception if compiler supports it).
	Blip_Buffer.prototype.sample_rate = function( new_rate, msec ) {
	
		if ( new_rate === undefined ) {
			return this.samples_per_sec;
		} else {
			msec = msec || blip_default_length;
			
			var new_size = 65448;//(0xFFFFFFFF >> BLIP_BUFFER_ACCURACY) + 1 - widest_impulse_ - 64;
			if ( msec !== blip_default_length ) {
				var s = Math.floor( (new_rate * (msec + 1) + 999) / 1000 );
				if ( s < new_size ) {
					new_size = s;
				} else {
			//		require( false ); // requested buffer length exceeds limit
				}
			}
			
			if ( this.buffer_size_ !== new_size ) {
				this.buffer_ = null; // allow for exception in allocation below
				this.buffer_size_ = 0;
				this.offset_ = 0;
				
				this.buffer_ = new Uint16Array( new_size + widest_impulse_ );
			}
			
			this.buffer_size_ = new_size;
			this.length_ = Math.floor( new_size * 1000 / new_rate ) - 1;
		//	if ( msec )
		//		assert( this.length_ == msec ); // ensure length is same as that passed in
			
			this.samples_per_sec = new_rate;
			if ( this.clocks_per_sec ) {
				this.clock_rate( this.clocks_per_sec ); // recalculate factor
			}
			
			this.bass_freq( this.bass_freq_ ); // recalculate shift
			
			this.clear();
		}
	};
	
	
	// Length of buffer, in milliseconds
	Blip_Buffer.prototype.length = function() {
		return this.length_;
	};

	
	// Number of source time units per second
	Blip_Buffer.prototype.clock_rate = function( cps ) {
		if ( cps === undefined ) {
			return this.clocks_per_sec;
		} else {
			this.clocks_per_sec = cps;
			this.factor_ = Math.floor( this.samples_per_sec / cps * (1 << BLIP_BUFFER_ACCURACY) + 0.5 );
		//	require( this.factor_ > 0 ); // clock_rate/sample_rate ratio is too large
		}
	};
	
	// Set frequency at which high-pass filter attenuation passes -3dB
	Blip_Buffer.prototype.bass_freq = function( freq ) {
		this.bass_freq_ = freq;
		if ( freq === 0 ) {
			this.bass_shift = 31; // 32 or greater invokes undefined behavior elsewhere
			return;
		}
		this.bass_shift = 1 + Math.floor( 1.442695041 * Math.log( 0.124 * this.samples_per_sec / freq ) );
		if ( this.bass_shift < 0 ) {
			this.bass_shift = 0;
		}
		if ( this.bass_shift > 24 ) {
			this.bass_shift = 24;
		}
	};
	
	// Remove all available samples and clear buffer to silence. If 'entire_buffer' is
	// false, just clear out any samples waiting rather than the entire buffer.
	Blip_Buffer.prototype.clear = function( entire_buffer ) {
		entire_buffer = entire_buffer === undefined ? true : entire_buffer;
			
		var count = (entire_buffer ? this.buffer_size_ : this.samples_avail());
		this.offset_ = 0;
		this.reader_accum = 0;
		uintArray_memset( this.buffer_, sample_offset, count + widest_impulse_ );
	};
	
	// to do:
	// Notify Blip_Buffer that synthesis has been performed until specified time
	//void run_until( blip_time_t );
	
	// End current time frame of specified duration and make its samples available
	// (along with any still-unread samples) for reading with read_samples(). Begin
	// a new time frame at the end of the current frame. All transitions must have
	// been added before 'time'.
	Blip_Buffer.prototype.end_frame = function( t ) {
		this.offset_ += t * this.factor_;
	//	assert(( "Blip_Buffer::end_frame(): Frame went past end of buffer",
	//			samples_avail() <= (long) this.buffer_size_ ));
	};
	
	// Number of samples available for reading with read_samples()
	Blip_Buffer.prototype.samples_avail = function() {
		return this.offset_ >> BLIP_BUFFER_ACCURACY;
	};
	
	// Read at most 'max_samples' out of buffer into 'dest', removing them from from
	// the buffer. Return number of samples actually read and removed. If stereo is
	// true, increment 'dest' one extra time after writing each sample, to allow
	// easy interleving of two channels into a stereo output buffer.
	Blip_Buffer.prototype.read_samples = function( out, max_samples, stereo ) {
		//require( this.buffer_ ); // sample rate must have been set
				
		var count = this.samples_avail();
		if ( count > max_samples ) {
			count = max_samples;
		}
		
		if ( !count ) {
			return 0; // optimization
		}
		
		var isFloatOutputArray = out instanceof Float32Array;
		
		var inIndex = 0;
		var outIndex = 0;
		var step = stereo ? 2 : 1;
	
		for ( var n = count; n--; ) {
		
			var s = this.reader_accum >> accum_fract;
			this.reader_accum -= this.reader_accum >> this.bass_shift;
			var inbyte = this.buffer_[inIndex];
			this.reader_accum += ( inbyte - sample_offset) << accum_fract;
			inIndex += 1;
			
			// clamp sample
		//	if ( s !== ( s & 0xFFFF ) ) {
			if ( s < -32767 || s > 32767 ) { // larger than a signed 16 bit value
				s = 0x7FFF - (s >> 24);
			}
			
			if ( isFloatOutputArray ) {
				out[ outIndex ] = s / 32768.0;
			} else {
				out[ outIndex ] = s;
			}
			
			outIndex += step;
		}
		
		this.remove_samples( count );
		
		return count;
	};
	
	// Remove 'count' samples from those waiting to be read
	Blip_Buffer.prototype.remove_samples = function( count ) {
		//require( this.buffer_ ); // sample rate must have been set
		
		if ( !count ) { // optimization
			return;
		}
		
		this.remove_silence( count );
		
		// Allows synthesis slightly past time passed to end_frame(), as long as it's
		// not more than an output sample.
		// to do: kind of hacky, could add run_until() which keeps track of extra synthesis
		var copy_extra = 1;
		
		// copy remaining samples to beginning and clear old samples
		var remain = this.samples_avail() + widest_impulse_ + copy_extra;
		if ( count >= remain ) {
			uintArray_memmove( this.buffer_, count, 0, remain );
		} else {
			uintArray_memcpy( this.buffer_, count, 0, remain );
		}
		uintArray_memset( this.buffer_, sample_offset, count, remain );
	};
	
	// Number of samples delay from synthesis to samples read out
	Blip_Buffer.prototype.output_latency = function() {
		return Math.floor( widest_impulse_ / 2 );
	};
	
	
	// not documented yet
	Blip_Buffer.prototype.remove_silence = function( count ) {
		//assert(( "Blip_Buffer::remove_silence(): Tried to remove more samples than available",
		//		count <= samples_avail() ));
		this.offset_ -= count << BLIP_BUFFER_ACCURACY;
	};
	
	
	Blip_Buffer.prototype.resampled_time = function( t ) {
		return t * this.factor_ + this.offset_;
	};
	
	Blip_Buffer.prototype.resampled_duration = function( t ) {
		return t * this.factor_;
	};
	
	
	Nes.Blip_Buffer = Blip_Buffer;
	
	
	
	
	
	
	var impulse_bits = 15;
	var impulse_amp = 1 << impulse_bits;
	var impulse_offset = Math.floor( impulse_amp / 2 );

	
	var Blip_Impulse_ = function() {
	
		this.impulses = null;
		this.impulse = null;
	};


	Blip_Impulse_.prototype.init = function( imps, w, r, fb ) {
	
		this.fine_bits = fb || 0;
		this.width = w;
		this.impulses = new Uint16Array( imps.buffer );
		this.generate = true;
		this.volume_unit_ = -1.0;
		this.res = r;
		this.buf = null;
		
		this.impulse = new Uint16Array( this.impulses.buffer, ( this.width * this.res * 2 * (this.fine_bits ? 2 : 1) ) * 2 );
		this.offset = 0;
	};


	// TODO: examine this if there are any problems
	Blip_Impulse_.prototype.scale_impulse = function( unit, imp_in ) {
	
		var offset = ( unit << impulse_bits) - impulse_offset * unit + (1 << (impulse_bits - 1));
		var impIndex = 0;
		var fimpIndex = 0;
		for ( var n = Math.floor( this.res / 2 ) + 1; n--; ) {
			var error = unit;
			for ( var nn = this.width; nn--; ) {
				var a = (this.impulse[ fimpIndex++ ] * unit + offset) >> impulse_bits;
				error -= a - unit;
				imp_in[ impIndex++ ] = a;
			}
			
			// add error to middle
			imp_in[ impIndex - Math.floor( this.width / 2 ) - 1] += error;
		}
		
		if ( this.res > 2 ) {
			// second half is mirror-image
			var revIndex = impIndex - this.width - 1;
			for ( var mm = ( Math.floor( this.res / 2 ) - 1) * this.width - 1; mm--; ) {
				imp_in[ impIndex++ ] = imp_in[ --revIndex ];
			}
			imp_in[ impIndex++ ] = unit;
		}
		
		// copy to odd offset
		imp_in[ impIndex++ ] = unit;
		//memcpy( imp, imp_in, (res * width - 1) * sizeof *imp );
		uintArray_memcpy( imp_in, 0, impIndex, (this.res * this.width - 1) );
	};
	
	
	Blip_Impulse_.prototype.fine_volume_unit = function() {
		// to do: find way of merging in-place without temporary buffer
		
		var temp = new Uint16Array( max_res * 2 * widest_impulse_ );
		this.scale_impulse( (this.offset & 0xffff) << this.fine_bits, temp );
		var imp2 = this.impulse.subarray( this.res * 2 * this.width );
		this.scale_impulse( this.offset & 0xffff, imp2 );
		
		// merge impulses
		var impIndex = 0;
		var imp2Index = 0;
		var src2Index = 0;
		for ( var n = Math.floor( this.res / 2 ) * 2 * this.width; n--; ) {
			this.impulses[ impIndex++ ] = imp2[ imp2Index++ ];
			this.impulses[ impIndex++ ] = imp2[ imp2Index++ ];
			this.impulses[ impIndex++ ] = temp[ src2Index++ ];
			this.impulses[ impIndex++ ] = temp[ src2Index++ ];
		}
	};
	
	
	Blip_Impulse_.prototype.volume_unit = function( new_unit ) {
		if ( new_unit === this.volume_unit_ ) {
			return;
		}
		
		if ( this.generate ) {
			this.treble_eq( new Blip_eq_t( -8.87, 8800, 44100 ) );
		}
		
		this.volume_unit_ = new_unit;
		
		this.offset = 0x10001 * Math.floor( this.volume_unit_ * 0x10000 + 0.5 );
		
		if ( this.fine_bits ) {
			this.fine_volume_unit();
		} else {
			this.scale_impulse( this.offset & 0xffff, this.impulses );
		}
	};
	
		

	Blip_Impulse_.prototype.treble_eq = function( new_eq ) {
	
		if ( !this.generate && new_eq.treble === this.eq.treble && new_eq.cutoff === this.eq.cutoff && new_eq.sample_rate === this.eq.sample_rate ) {
			return; // already calculated with same parameters
		}
		
		var pi = 3.1415926535897932384626433832795029;
		
		this.generate = false;
		this.eq = new_eq;
		
		var treble = Math.pow( 10.0, 1.0 / 20 * this.eq.treble ); // dB (-6dB = 0.50)
		if ( treble < 0.000005 ) {
			treble = 0.000005;
		}
		
		var treble_freq = 22050.0; // treble level at 22 kHz harmonic
		var sample_rate = this.eq.sample_rate;
		var pt = treble_freq * 2 / sample_rate;
		var cutoff = this.eq.cutoff * 2 / sample_rate;
		if ( cutoff >= pt * 0.95 || cutoff >= 0.95 ) {
			cutoff = 0.5;
			treble = 1.0;
		}
		
		// DSF Synthesis (See T. Stilson & J. Smith (1996),
		// Alias-free digital synthesis of classic analog waveforms)
		
		// reduce adjacent impulse interference by using small part of wide impulse
		var n_harm = 4096;
		var rolloff = Math.pow( treble, 1.0 / (n_harm * pt - n_harm * cutoff) );
		var rescale = 1.0 / Math.pow( rolloff, n_harm * cutoff );
		
		var pow_a_n = rescale * Math.pow( rolloff, n_harm );
		var pow_a_nc = rescale * Math.pow( rolloff, n_harm * cutoff );
		
		var total = 0.0;
		var to_angle = ( ( ( pi / 2 ) / n_harm ) / max_res );
		
		var buf = [];
		buf.length = Math.floor( max_res * (widest_impulse_ - 2) / 2 );
		var size = Math.floor( max_res * (this.width - 2) / 2 );
		for ( var i = size; i--; )
		{
			var angle = (i * 2 + 1) * to_angle;
			
			// equivalent
			//double y =     dsf( angle, n_harm * cutoff, 1.0 );
			//y -= rescale * dsf( angle, n_harm * cutoff, rolloff );
			//y += rescale * dsf( angle, n_harm,          rolloff );
			
			var cos_angle = Math.cos( angle );
			var cos_nc_angle = Math.cos( n_harm * cutoff * angle );
			var cos_nc1_angle = Math.cos( (n_harm * cutoff - 1.0) * angle );
			
			var b = 2.0 - 2.0 * cos_angle;
			var a = 1.0 - cos_angle - cos_nc_angle + cos_nc1_angle;
			
			var d = 1.0 + rolloff * (rolloff - 2.0 * cos_angle);
			var c = pow_a_n * rolloff * Math.cos( (n_harm - 1.0) * angle ) -
					pow_a_n * Math.cos( n_harm * angle ) -
					pow_a_nc * rolloff * cos_nc1_angle +
					pow_a_nc * cos_nc_angle;
			
			// optimization of a / b + c / d
			var y = (a * d + c * b) / (b * d);
			
			// fixed window which affects wider impulses more
			if ( this.width > 12 ) {
				var windowVar = Math.cos( n_harm / 1.25 / widest_impulse_ * angle );
				y *= windowVar * windowVar;
			}
			
			total += y;
			buf[i] = y;
		}
		
		// integrate runs of length 'max_res'
		var factor = impulse_amp * 0.5 / total; // 0.5 accounts for other mirrored half
		var impIndex = 0;
		var step = Math.floor( max_res / this.res );
		var offset = this.res > 1 ? max_res : Math.floor( max_res / 2 );
		for ( var n = Math.floor( this.res / 2 ) + 1; n--; offset -= step )
		{
			for ( var w = -Math.floor( this.width / 2 ); w < Math.floor( this.width / 2 ); w++ )
			{
				var sum = 0;
				for ( var k = max_res; k--; )
				{
					var index = w * max_res + offset + k;
					if ( index < 0 ) {
						index = -index - 1;
					}
					if ( index < size ) {
						sum += buf [index];
					}
				}
				this.impulse[ impIndex++ ] = Math.floor( sum * factor + (impulse_offset + 0.5) );
			}
		}
		
		// rescale
		var unit = this.volume_unit_;
		if ( unit >= 0 ) {
			this.volume_unit_ = -1;
			this.volume_unit( unit );
		}
	};
	
	
	Nes.Blip_Impulse_ = Blip_Impulse_;
	
}());



/* Copyright (C) 2003-2005 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
more details. You should have received a copy of the GNU Lesser General
Public License along with this module; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA */

// Blip_Synth and Blip_Wave are waveform transition synthesizers for adding
// waveforms to a Blip_Buffer.


this.Nes = this.Nes || {};


(function(){
	"use strict";
	
	var widest_impulse_ = 24;
	var blip_res_bits_ = 5;
	var BLIP_BUFFER_ACCURACY = 16;

	// Quality level. Higher levels are slower, and worse in a few cases.
	// Use blip_good_quality as a starting point.
	var blip_low_quality = 1;
	var blip_med_quality = 2;
	var blip_good_quality = 3;
	var blip_high_quality = 4;

	// Blip_Synth is a transition waveform synthesizer which adds band-limited
	// offsets (transitions) into a Blip_Buffer. For a simpler interface, use
	// Blip_Wave (below).
	//
	// Range specifies the greatest expected offset that will occur. For a
	// waveform that goes between +amp and -amp, range should be amp * 2 (half
	// that if it only goes between +amp and 0). When range is large, a higher
	// accuracy scheme is used; to force this even when range is small, pass
	// the negative of range (i.e. -range).
	
	var Blip_Synth = function( quality, range ) {

		var calc_fine_bits = function( abs_range ) {
			return (abs_range <= 64 ? 2 : abs_range <= 128 ? 3 :
				abs_range <= 256 ? 4 : abs_range <= 512 ? 5 : abs_range <= 1024 ? 6 :
				abs_range <= 2048 ? 7 : 8);
		};
	
		this.abs_range = (range < 0) ? -range : range;
		this.fine_mode = (range > 512 || range < 0);
		this.width = (quality < 5 ? quality * 4 : widest_impulse_);
		this.res = 1 << blip_res_bits_;
		this.impulse_size = Math.floor( this.width / 2 ) * (this.fine_mode + 1);
		this.base_impulses_size = Math.floor( this.width / 2 ) * ( Math.floor( this.res / 2 ) + 1);
		this.fine_bits = this.fine_mode ? calc_fine_bits( this.abs_range ) : 0;
		
		this.impulses = new Uint32Array( this.impulse_size * this.res * 2 + this.base_impulses_size );
		this.impulse = new Nes.Blip_Impulse_();
		
		this.impulse.init( this.impulses, this.width, this.res, this.fine_bits );
	};

	
	Blip_Synth.blip_low_quality = 1;
	Blip_Synth.blip_med_quality = 2;
	Blip_Synth.blip_good_quality = 3;
	Blip_Synth.blip_high_quality = 4;
	
	
	// Set volume of a transition at amplitude 'range' by setting volume_unit
	// to v / range
	Blip_Synth.prototype.volume = function( v ) {
		this.impulse.volume_unit( v * (1.0 / this.abs_range) );
	};

	

	// Set base volume unit of transitions, where 1.0 is a full swing between the
	// positive and negative extremes. Not optimized for real-time control.
	Blip_Synth.prototype.volume_unit = function( unit ) {
		this.impulse.volume_unit( unit );
	};
	
	// Default Blip_Buffer used for output when none is specified for a given call	
	Blip_Synth.prototype.output = function( buf ) {
		if ( buf === undefined ) {
			return this.impulse.buf;
		} else {
			this.impulse.buf = buf;
		}
	};
	

	// Add an amplitude offset (transition) with a magnitude of delta * volume_unit
	// into the specified buffer (default buffer if none specified) at the
	// specified source time. Delta can be positive or negative. To increase
	// performance by inlining code at the call site, use offset_inline().
	Blip_Synth.prototype.offset = function( time, delta, buf ) {
		buf = buf || this.impulse.buf;
		this.offset_resampled( time * buf.factor_ + buf.offset_, delta, buf );
	};
	
	
	Blip_Synth.prototype.offset_resampled = function( time, delta, blip_buf ) {
		blip_buf = blip_buf || this.impulse.buf;

		var sample_index = (time >> BLIP_BUFFER_ACCURACY) & ~1;
	//	assert(( "Blip_Synth/Blip_wave: Went past end of buffer",
	//			sample_index < blip_buf->buffer_size_ ));
		var const_offset = Math.floor( widest_impulse_ / 2 ) - Math.floor( this.width / 2 );
		
		// original code cast from 16 bit array to 32 bit for this function - we can't do that
		// as it requires to modify on 16 bit boundaries so can't just pass .buffer to Uint32Array
		var buf = new Uint32Array( blip_buf.buffer_.buffer, ( const_offset + sample_index ) * 2 );
		
		var shift = BLIP_BUFFER_ACCURACY - blip_res_bits_;
		var mask = this.res * 2 - 1;
		var impulsesIndex = ((time >> shift) & mask) * this.impulse_size;
		var imp = this.impulses.subarray( impulsesIndex );
		
		var offset = this.impulse.offset * delta;
		var bufIndex = 0;
		var impIndex = 0;
		
		if ( !this.fine_bits ) {
			// normal mode
			for ( var n = Math.floor( this.width / 4 ); n > 0; --n ) {
			
				var t0 = buf [ bufIndex + 0] - offset;
				var t1 = buf [ bufIndex + 1] - offset;
				
				t0 += imp [ impIndex + 0] * delta;
				t1 += imp [ impIndex + 1] * delta;
				impIndex += 2;
				
				buf [ bufIndex + 0] = t0;
				buf [ bufIndex + 1] = t1;
				bufIndex += 2;
			}
		}
		else
		{
			// fine mode
			var sub_range = 1 << this.fine_bits;
			delta += Math.floor( sub_range / 2 );
			var delta2 = (delta & (sub_range - 1)) - Math.floor( sub_range / 2 );
			delta >>= this.fine_bits;
			
			for ( var m = Math.floor( this.width / 4 ); m > 0; --m )
			{
				var s0 = buf [ bufIndex + 0] - offset;
				var s1 = buf [ bufIndex + 1] - offset;
				
				s0 += imp [impIndex + 0] * delta2;
				s0 += imp [impIndex + 1] * delta;
				
				s1 += imp [impIndex + 2] * delta2;
				s1 += imp [impIndex + 3] * delta;
				
				impIndex += 4;

				buf [ bufIndex + 0] = s0;
				buf [ bufIndex + 1] = s1;
				bufIndex += 2;
			}
		}
	};
	
	
	Blip_Synth.prototype.offset_inline = function( time, delta, buf ) {
		buf = buf || this.impulse.buf;
		this.offset_resampled( time * buf.factor_ + buf.offset_, delta, buf );
	};
	
	
	Nes.Blip_Synth = Blip_Synth;
	
}());

/* Copyright (C) 2003-2005 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
more details. You should have received a copy of the GNU Lesser General
Public License along with this module; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA */

this.Nes = this.Nes || {};


(function(){
	"use strict";
	
	var no_irq = 1073741824;
	
	var Nes_Osc = function() {
		this.regs = new Uint8Array(4);
		this.reg_written = [ false, false, false, false ];
		this.output = null;
		this.length_counter = 0;// length counter (0 if unused by oscillator)
		this.delay = 0;      // delay until next (potential) transition
		this.last_amp = 0;   // last amplitude oscillator was outputting
	};
	
	
	Nes_Osc.prototype.clock_length = function( halt_mask ) {
	
		if ( this.length_counter > 0 && (this.regs[0] & halt_mask) === 0 ) {
			this.length_counter--;
		}
	};
	
	
	Nes_Osc.prototype.period = function( halt_mask ) {
		return (this.regs[3] & 7) * 0x100 + (this.regs [2] & 0xff);
	};
	
	
	Nes_Osc.prototype.reset = function() {
		this.delay = 0;
		this.last_amp = 0;
	};

	
	Nes_Osc.prototype.update_amp = function( amp ) {
		var delta = amp - this.last_amp;
		this.last_amp = amp;
		return delta;
	};
	
	
	
	
	
	
	var Nes_Envelope = function() {
		Nes_Osc.call( this );
		this.envelope = 0;
		this.env_delay = 0;
	};
	
	Nes_Envelope.prototype = Object.create( Nes_Osc.prototype );

	
	Nes_Envelope.prototype.clock_envelope = function() {
		var period = this.regs[0] & 15;
		if ( this.reg_written [3] ) {
			this.reg_written [3] = false;
			this.env_delay = period;
			this.envelope = 15;
		} else if ( --this.env_delay < 0 ) {
			this.env_delay = period;
			if ( this.envelope | (this.regs [0] & 0x20) ) {
				this.envelope = (this.envelope - 1) & 15;
			}
		}
	};
	
	
	Nes_Envelope.prototype.volume = function() {
		return this.length_counter === 0 ? 0 : (this.regs [0] & 0x10) ? (this.regs [0] & 15) : this.envelope;
	};
	
	
	Nes_Envelope.prototype.reset = function() {
		this.envelope = 0;
		this.env_delay = 0;
		Nes_Osc.prototype.reset.call( this );
	};
	
	
	
	var Nes_Square = function() {
		Nes_Envelope.call( this );
		this.phase = 0;
		this.sweep_delay = 0;
		this.synth = null;
		// typedef Blip_Synth<blip_good_quality,15> Synth;
	};
	
	Nes_Square.prototype = Object.create( Nes_Envelope.prototype );

	Nes_Square.negate_flag = 0x08;
	Nes_Square.shift_mask = 0x07;
	Nes_Square.phase_range = 8;

	
	Nes_Square.prototype.clock_sweep = function( negative_adjust ) {
		var sweep = this.regs [1];
		
		if ( --this.sweep_delay < 0 )
		{
			this.reg_written [1] = true;
			
			var period = this.period();
			var shift = sweep & Nes_Square.shift_mask;
			if ( shift && (sweep & 0x80) && period >= 8 )
			{
				var offset = period >> shift;
				
				if ( sweep & Nes_Square.negate_flag ) {
					offset = negative_adjust - offset;
				}
				
				if ( period + offset < 0x800 ) {
					period += offset;
					// rewrite period
					this.regs [2] = period & 0xff;
					this.regs [3] = (this.regs [3] & 0xF8) | ((period >> 8) & 7);
				}
			}
		}
		
		if ( this.reg_written [1] ) {
			this.reg_written [1] = false;
			this.sweep_delay = (sweep >> 4) & 7;
		}
	};
	
	
	Nes_Square.prototype.run = function( time, end_time ) {
		if ( !this.output )
			return;
		
		var volume = this.volume();
		var period = this.period();
		var offset = period >> (this.regs [1] & Nes_Square.shift_mask);
		if ( this.regs [1] & Nes_Square.negate_flag ) {
			offset = 0;
		}
		
		var timer_period = (period + 1) * 2;
		if ( volume === 0 || period < 8 || (period + offset) >= 0x800 )
		{
			if ( this.last_amp ) {
				this.synth.offset( time, -this.last_amp, this.output );
				this.last_amp = 0;
			}
			
			time += this.delay;
			if ( time < end_time ) {
				// maintain proper phase
				var count = Math.floor( (end_time - time + timer_period - 1) / timer_period );
				this.phase = (this.phase + count) & (Nes_Square.phase_range - 1);
				time += count * timer_period;
			}
		} else {
			// handle duty select
			var duty_select = (this.regs [0] >> 6) & 3;
			var duty = 1 << duty_select; // 1, 2, 4, 2
			var amp = 0;
			if ( duty_select === 3 ) {
				duty = 2; // negated 25%
				amp = volume;
			}
			if ( this.phase < duty ) {
				amp ^= volume;
			}
			
			var delta = this.update_amp( amp );
			if ( delta ) {
				this.synth.offset( time, delta, this.output );
			}
			
			time += this.delay;
			if ( time < end_time ) {
				delta = amp * 2 - volume;

				do {
					this.phase = (this.phase + 1) & (Nes_Square.phase_range - 1);
					if ( this.phase === 0 || this.phase === duty ) {
						delta = -delta;
						this.synth.offset_inline( time, delta, this.output );
					}
					time += timer_period;
				} while ( time < end_time );
				
				this.last_amp = (delta + volume) >> 1;
			}
		}
		
		this.delay = time - end_time;
	};
	
	
	Nes_Square.prototype.reset = function() {
		this.sweep_delay = 0;
		Nes_Envelope.prototype.reset.call( this );
	};
	
	
	
	
	
	var Nes_Triangle = function() {
		Nes_Osc.call( this );
		this.phase = Nes_Triangle.phase_range;
		this.linear_counter = 0;
		this.synth = new Nes.Blip_Synth( Nes.Blip_Synth.blip_good_quality, 15 );
		//Blip_Synth<blip_good_quality,15> synth;
	};
	
	Nes_Triangle.prototype = Object.create( Nes_Osc.prototype );

	Nes_Triangle.phase_range = 16;
	
	
	Nes_Triangle.prototype.reset = function() {
		this.phase = Nes_Triangle.phase_range;
		this.linear_counter = 0;
		Nes_Osc.prototype.reset.call( this );
	};
	
	
	Nes_Triangle.prototype.run = function( time, end_time ) {
		if ( !this.output )
			return;
		
		// to do: track phase when period < 3
		// to do: Output 7.5 on dac when period < 2? More accurate, but results in more clicks.
		
		var delta = this.update_amp( this.calc_amp() );
		if ( delta ) {
			this.synth.offset( time, delta, this.output );
		}
		
		time += this.delay;
		var timer_period = this.period() + 1;
		if ( this.length_counter === 0 || this.linear_counter === 0 || timer_period < 3 ) {
			time = end_time;
		} else if ( time < end_time ) {
			var volume = 1;
			if ( this.phase > Nes_Triangle.phase_range ) {
				this.phase -= Nes_Triangle.phase_range;
				volume = -volume;
			}
			
			do {
				if ( --this.phase === 0 ) {
					this.phase = Nes_Triangle.phase_range;
					volume = -volume;
				} else {
					this.synth.offset_inline( time, volume, this.output );
				}
				
				time += timer_period;
			} while ( time < end_time );
			
			if ( volume < 0 ) {
				this.phase += Nes_Triangle.phase_range;
			}
			this.last_amp = this.calc_amp();
		}
		this.delay = time - end_time;
	};
	
	
	Nes_Triangle.prototype.clock_linear_counter = function() {
		if ( this.reg_written [3] ) {
			this.linear_counter = this.regs [0] & 0x7f;
		} else if ( this.linear_counter ) {
			this.linear_counter--;
		}
		
		if ( !(this.regs [0] & 0x80) ) {
			this.reg_written [3] = false;
		}
	};
	
	
	Nes_Triangle.prototype.calc_amp = function() {
		var amp = Nes_Triangle.phase_range - this.phase;
		if ( amp < 0 ) {
			amp = this.phase - (Nes_Triangle.phase_range + 1);
		}
		return amp;
	};
	
	
	

	var noise_period_table = [
		0x004, 0x008, 0x010, 0x020, 0x040, 0x060, 0x080, 0x0A0,
		0x0CA, 0x0FE, 0x17C, 0x1FC, 0x2FA, 0x3F8, 0x7F2, 0xFE4
	];

	
	var Nes_Noise = function() {
		Nes_Envelope.call( this );
		this.noise = 0x4000;
		this.synth = new Nes.Blip_Synth( Nes.Blip_Synth.blip_med_quality, 15 );
		//Blip_Synth<blip_med_quality,15> synth;
	};
	
	Nes_Noise.prototype = Object.create( Nes_Envelope.prototype );
	
	
	Nes_Noise.prototype.run = function( time, end_time ) {
		if ( !this.output )
			return;
		
		var volume = this.volume();
		var amp = (this.noise & 1) ? volume : 0;
		var delta = this.update_amp( amp );
		if ( delta ) {
			this.synth.offset( time, delta, this.output );
		}
		
		time += this.delay;
		if ( time < end_time ) {
			var mode_flag = 0x80;
			
			var period = noise_period_table [this.regs [2] & 15];
			if ( !volume ) {
				// round to next multiple of period
				time += Math.floor( (end_time - time + period - 1) / period ) * period;
				
				// approximate noise cycling while muted, by shuffling up noise register
				// to do: precise muted noise cycling?
				if ( !(this.regs [2] & mode_flag) ) {
					var feedback = (this.noise << 13) ^ (this.noise << 14);
					this.noise = (feedback & 0x4000) | (this.noise >> 1);
				}
			} else {
				// using resampled time avoids conversion in synth.offset()
				var rperiod = this.output.resampled_duration( period );
				var rtime = this.output.resampled_time( time );
				
				delta = amp * 2 - volume;
				var tap = (this.regs [2] & mode_flag ? 8 : 13);
				
				do {
					var feedback2 = (this.noise << tap) ^ (this.noise << 14);
					time += period;
					
					if ( (this.noise + 1) & 2 ) {
						// bits 0 and 1 of noise differ
						delta = -delta;
						this.synth.offset_resampled( rtime, delta, this.output );
					}
					
					rtime += rperiod;
					this.noise = (feedback2 & 0x4000) | (this.noise >> 1);
				}
				while ( time < end_time );
				
				this.last_amp = (delta + volume) >> 1;
			}
		}
		
		this.delay = time - end_time;
	};
	
	
	Nes_Noise.prototype.reset = function() {
		this.noise = 0x4000;
		Nes_Envelope.prototype.reset.call( this );
	};
	
	
	
	
	


	var dmc_period_table = [
		[
			0x1ac, 0x17c, 0x154, 0x140, 0x11e, 0x0fe, 0x0e2, 0x0d6, // NTSC
			0x0be, 0x0a0, 0x08e, 0x080, 0x06a, 0x054, 0x048, 0x036
		],
		[
			0x18e, 0x161, 0x13c, 0x129, 0x10a, 0x0ec, 0x0d2, 0x0c7, // PAL (totally untested)
			0x0b1, 0x095, 0x084, 0x077, 0x062, 0x04e, 0x043, 0x032  // to do: verify PAL periods
		]
	];
		
		
	var dac_table = [
		 0,  0,  1,  2,  2,  3,  3,  4,  5,  5,  6,  7,  7,  8,  8,  9,
		10, 10, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 18,
		19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26,
		27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 32, 33, 33, 34,
		34, 35, 35, 35, 36, 36, 37, 37, 38, 38, 38, 39, 39, 40, 40, 40,
		41, 41, 42, 42, 42, 43, 43, 44, 44, 44, 45, 45, 45, 46, 46, 47,
		47, 47, 48, 48, 48, 49, 49, 49, 50, 50, 50, 51, 51, 51, 52, 52,
		52, 53, 53, 53, 54, 54, 54, 55, 55, 55, 56, 56, 56, 57, 57, 57
	];

	var loop_flag = 0x40;


	var Nes_Dmc = function( apu ) {
		Nes_Osc.call( this );
		this.apu = apu;
		this.address = 0;
		this.dac = 0;
		this.buf = 0;
		this.bits_remain = 1;
		this.bits = 0;
		this.buf_empty = true;
		this.silence = true;
		this.next_irq = no_irq;
		this.irq_flag = false;
		this.irq_enabled = false;
		this.periodValue = 0;
		this.pal_mode = 0;
		this.nonlinear = false;

		this.rom_reader = null;

		this.synth = new Nes.Blip_Synth( Nes.Blip_Synth.blip_med_quality, 127 );
		//Blip_Synth<blip_med_quality,127> synth;
	};
	
	Nes_Dmc.prototype = Object.create( Nes_Osc.prototype );
	
	
	Nes_Dmc.prototype.run = function( time, end_time ) {
		if ( !this.output )
			return;
		
		var delta = this.update_amp( this.dac );
		if ( delta ) {
			this.synth.offset( time, delta, this.output );
		}
		
		time += this.delay;
		if ( time < end_time ) {
			var bits_remain_copy = this.bits_remain;
			if ( this.silence && this.buf_empty ) {
				var count = Math.floor( (end_time - time + this.periodValue - 1) / this.periodValue );
				bits_remain_copy = (bits_remain_copy - 1 + 8 - (count % 8)) % 8 + 1;
				time += count * this.periodValue;
			} else {
				var bits_copy = this.bits;
				var dac_copy = this.dac;
				do {
					if ( !this.silence ) {
						var step = (bits_copy & 1) * 4 - 2;
						bits_copy >>= 1;
						var tot_step = ( dac_copy + step ) >>> 0; // converts to unsigned, see http://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it
						if ( tot_step <= 0x7F ) {
							dac_copy += step;
							this.synth.offset_inline( time, step, this.output );
						}
					}
					
					time += this.periodValue;
					
					if ( --bits_remain_copy === 0 ) {
						bits_remain_copy = 8;
						if ( this.buf_empty ) {
							this.silence = true;
						} else {
							this.silence = false;
							bits_copy = this.buf;
							this.buf_empty = true;
							this.fill_buffer();
						}
					}
				}
				while ( time < end_time );

				this.last_amp = dac_copy;
				this.dac = dac_copy;
				this.bits = bits_copy;
			}
			this.bits_remain = bits_remain_copy;
		}
		this.delay = time - end_time;
	};
	
	
	Nes_Dmc.prototype.reset = function() {

		this.address = 0;
		this.dac = 0;
		this.buf = 0;
		this.bits_remain = 1;
		this.bits = 0;
		this.buf_empty = true;
		this.silence = true;
		this.next_irq = no_irq;
		this.irq_flag = false;
		this.irq_enabled = false;
		Nes_Osc.prototype.reset.call( this );		
		this.periodValue = 0x036;
	};
	
	
	Nes_Dmc.prototype.start = function() {
		this.reload_sample();
		this.fill_buffer();
		this.recalc_irq();
	};
	
	
	Nes_Dmc.prototype.write_register = function( addr, data ) {
		if ( addr === 0 ) {
			this.periodValue = dmc_period_table [this.pal_mode] [data & 15];
			this.irq_enabled = (data & 0xc0) === 0x80; // enabled only if loop disabled
			this.irq_flag = this.irq_flag && this.irq_enabled;
			this.recalc_irq();
		} else if ( addr === 1 ) {
			if ( !this.nonlinear ) {
				// adjust last_amp so that "pop" amplitude will be properly non-linear
				// with respect to change in dac
				var old_amp = dac_table [this.dac];
				this.dac = data & 0x7F;
				var diff = dac_table [this.dac] - old_amp;
				this.last_amp = this.dac - diff;
			}
			
			this.dac = data & 0x7F;
		}
	};
	
	
	Nes_Dmc.prototype.recalc_irq = function() {
		var irq = no_irq;
		if ( this.irq_enabled && this.length_counter ) {
			irq = this.apu.last_time + this.delay +
					((this.length_counter - 1) * 8 + this.bits_remain - 1) * this.periodValue + 1;
		}
		if ( irq !== this.next_irq ) {
			this.next_irq = irq;
			this.apu.irq_changed();
		}
	};
	
	
	Nes_Dmc.prototype.fill_buffer = function() {
		if ( this.buf_empty && this.length_counter ) {
			//require( rom_reader ); // rom_reader must be set
			this.buf = this.rom_reader( 0x8000 + this.address );
			this.address = (this.address + 1) & 0x7FFF;
			this.buf_empty = false;
			if ( --this.length_counter === 0 ) {
				if ( ( this.regs [0] & loop_flag ) > 0 ) {
					this.reload_sample();
				} else {
					this.apu.osc_enables &= 0xEF;
					this.irq_flag = this.irq_enabled;
					this.next_irq = no_irq;
					this.apu.irq_changed();
				}
			}
		}
	};
	
	
	Nes_Dmc.prototype.reload_sample = function() {
		this.address = 0x4000 + this.regs [2] * 0x40;
		this.length_counter = this.regs [3] * 0x10 + 1;
	};
	
	
	Nes.Nes_Square = Nes_Square;
	Nes.Nes_Triangle = Nes_Triangle;
	Nes.Nes_Noise = Nes_Noise;
	Nes.Nes_Dmc = Nes_Dmc;

	
}());


/* Copyright (C) 2003-2005 Shay Green. This module is free software; you
can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version. This
module is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
more details. You should have received a copy of the GNU Lesser General
Public License along with this module; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA */

// NES 2A03 APU sound chip emulator

// Nes_Snd_Emu 0.1.7. Copyright (C) 2003-2005 Shay Green. GNU LGPL license.

this.Nes = this.Nes || {};


(function(){
	"use strict";

	var osc_count = 5;
	var start_addr = 0x4000;
	var end_addr   = 0x4017;
	var no_irq = 1073741824;
	var irq_waiting = 0;
		
	// registers
	var length_table = [
		0x0A, 0xFE, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06,
		0xA0, 0x08, 0x3C, 0x0A, 0x0E, 0x0C, 0x1A, 0x0E, 
		0x0C, 0x10, 0x18, 0x12, 0x30, 0x14, 0x60, 0x16,
		0xC0, 0x18, 0x48, 0x1A, 0x10, 0x1C, 0x20, 0x1E
	];

	
	var Nes_Apu = function() {
	
		this.start_addr = start_addr;
		this.end_addr = end_addr;
		this.status_addr = 0x4015;
		
		this._square1 = new Nes.Nes_Square();
		this._square2 = new Nes.Nes_Square();
		this._triangle = new Nes.Nes_Triangle();
		this._noise = new Nes.Nes_Noise();
		this._dmc = new Nes.Nes_Dmc();
		this.osc = [ this._square1, this._square2, this._triangle, this._noise, this._dmc ];

		this.last_time = 0; // has been run until this time in current frame
		this.earliest_irq_ = 0;
		this.next_irq = 0;

		this._square_synth = new Nes.Blip_Synth( Nes.Blip_Synth.blip_good_quality, 15 );
		this._irqCallback = null;
		this.frame_mode = 0;
		this.frame = 0;
	
		this._dmc.apu = this;
		this._dmc.rom_reader = null;
		this._square1.synth = this._square_synth;
		this._square2.synth = this._square_synth;

		this.output( null );
		this.volume( 1.0 );
		this.reset( false );
	};
	
	
	Nes_Apu.no_irq = no_irq;
	Nes_Apu.irq_waiting = irq_waiting;
	
	
	// Reset internal frame counter, registers, and all oscillators.
	// Use PAL timing if pal_timing is true, otherwise use NTSC timing.
	// Set the DMC oscillator's initial DAC value to initial_dmc_dac without
	// any audible click.
	Nes_Apu.prototype.reset = function( pal_mode, initial_dmc_dac ) {
		pal_mode = pal_mode || false;
		initial_dmc_dac = initial_dmc_dac || 0;
		
		// to do: time pal frame periods exactly
		this.frame_period = pal_mode ? 8314 : 7458;
		this._dmc.pal_mode = pal_mode ? 1 : 0;
		
		this._square1.reset();
		this._square2.reset();
		this._triangle.reset();
		this._noise.reset();
		this._dmc.reset();
		
		this.last_time = 0;
		this.osc_enables = 0;
		this.irq_flag = false;
		this.earliest_irq_ = no_irq;
		this.frame_delay = 1;  // cycles until frame counter runs next
		this.write_register( 0, 0x4017, 0x00 );
		this.write_register( 0, 0x4015, 0x00 );
		
		for ( var addr = start_addr; addr <= 0x4013; addr++ ) {
			this.write_register( 0, addr, (addr & 3) ? 0x00 : 0x10 );
		}
		
		this._dmc.dac = initial_dmc_dac;
		if ( !this._dmc.nonlinear ) {
			this._dmc.last_amp = initial_dmc_dac; // prevent output transition
		}
	};
	
	
	// Set buffer to generate all sound into, or disable sound if NULL
	Nes_Apu.prototype.output = function( buffer ) {
		for ( var i = 0; i < osc_count; i++ ) {
			this.osc_output( i, buffer );
		}
	};
	
	// Set memory reader callback used by DMC oscillator to fetch samples.
	// When callback is invoked, 'user_data' is passed unchanged as the
	// first parameter.
	Nes_Apu.prototype.dmc_reader = function( dmcCallback ) {
		this._dmc.rom_reader = dmcCallback;
	};
	
	// All time values are the number of CPU clock cycles relative to the
	// beginning of the current time frame. Before resetting the CPU clock
	// count, call end_frame( last_cpu_time ).
	// Write to register (0x4000-0x4017, except 0x4014 and 0x4016)
	Nes_Apu.prototype.write_register = function( time, addr, data ) {

	//	require( addr > 0x20 ); // addr must be actual address (i.e. 0x40xx)
	//	require( (unsigned) data <= 0xff );
		
		// Ignore addresses outside range
		if ( addr < start_addr || end_addr < addr ) {
			return;
		}
		
		this.run_until( time );
		
		if ( addr < 0x4014 ) {
			// Write to channel
			var osc_index = (addr - start_addr) >> 2;
			var osc = this.osc[osc_index];
			
			var reg = addr & 3;
			osc.regs[reg] = data;
			osc.reg_written[reg] = true;
			
			if ( osc_index === 4 ) {
				// handle DMC specially
				this._dmc.write_register( reg, data );
			} else if ( reg === 3 ) {
				// load length counter
				if ( (this.osc_enables >> osc_index) & 1 ) {
					osc.length_counter = length_table[(data >> 3) & 0x1f];
				}
				
				// reset square phase
				if ( osc_index < 2 ) {
					osc.phase = Nes.Nes_Square.phase_range - 1;
				}
			}
		} else if ( addr === 0x4015 ) {
			// Channel enables
			for ( var i=0; i<osc_count; ++i ) {
				var enabled = (data >> i) & 1;
				if ( enabled === 0 ) {
					this.osc[i].length_counter = 0;
				}
			}
			
			var recalc_irq = this._dmc.irq_flag;
			this._dmc.irq_flag = false;
			
			var old_enables = this.osc_enables;
			this.osc_enables = data;
			if ( !(data & 0x10) ) {
				this._dmc.next_irq = no_irq;
				recalc_irq = true;
			} else if ( !(old_enables & 0x10) ) {
				this._dmc.start(); // dmc just enabled
			}
			
			if ( recalc_irq ) {
				this.irq_changed();
			}
		} else if ( addr === 0x4017 ) {
			// Frame mode
			this.frame_mode = data;
			
			var irq_enabled = !(data & 0x40);
			this.irq_flag &= irq_enabled;
			this.next_irq = no_irq;
			
			// mode 1
			this.frame_delay = (this.frame_delay & 1);
			this.frame = 0;
			
			if ( !(data & 0x80) ) {
				// mode 0
				this.frame = 1;
				this.frame_delay += this.frame_period;
				if ( irq_enabled ) {
					this.next_irq = time + this.frame_delay + this.frame_period * 3;
				}
			}
			
			this.irq_changed();
		}
	};
	
	// Read from status register at 0x4015
	Nes_Apu.prototype.read_status = function( time ) {

		this.run_until( time - 1 );
		
		var result = ( this._dmc.irq_flag ? 0x80 : 0 ) | ( this.irq_flag ? 0x40 : 0 );
		
		for ( var i = 0; i < osc_count; i++ ) {
			if ( this.osc[i].length_counter > 0 ) {
				result |= 1 << i;
			}
		}
		
		this.run_until( time );
		
		if ( this.irq_flag ) {
			this.irq_flag = false;
			this.irq_changed();
		}
		
		return result;
	};
	
	// Run all oscillators up to specified time, end current time frame, then
	// start a new time frame at time 0. Time frames have no effect on emulation
	// and each can be whatever length is convenient.
	Nes_Apu.prototype.end_frame = function( end_time ) {
		if ( end_time > this.last_time ) {
			this.run_until( end_time );
		}
		
		// make times relative to new frame
		this.last_time -= end_time;
		//require( this.last_time >= 0 );
		
		if ( this.next_irq !== no_irq ) {
			this.next_irq -= end_time;
			//assert( this.next_irq >= 0 );
		}
		if ( this._dmc.next_irq !== no_irq ) {
			this._dmc.next_irq -= end_time;
			//assert( this._dmc.next_irq >= 0 );
		}
		if ( this.earliest_irq_ !== no_irq ) {
			this.earliest_irq_ -= end_time;
			if ( this.earliest_irq_ < 0 ) {
				this.earliest_irq_ = 0;
			}
		}
	};

	
	// Save/load snapshot of exact emulation state
	Nes_Apu.prototype.save_snapshot = function( apu_snapshot_t ) {
	
	};
	
	
	Nes_Apu.prototype.load_snapshot = function( apu_snapshot_t ) {
	
	};
	
	// Set overall volume (default is 1.0)
	Nes_Apu.prototype.volume = function( v ) {
		v = v || 1.0;
		this._dmc.nonlinear = false;
		this._square_synth.volume( 0.1128 * v );
		this._triangle.synth.volume( 0.12765 * v );
		this._noise.synth.volume( 0.0741 * v );
		this._dmc.synth.volume( 0.42545 * v );
	};
	
	
	// Set IRQ time callback that is invoked when the time of earliest IRQ
	// may have changed, or NULL to disable. When callback is invoked,
	// 'user_data' is passed unchanged as the first parameter.
	Nes_Apu.prototype.irq_notifier = function( irqCallback ) {
	
		this._irqCallback = irqCallback;
	};
	
	
	// Get time that APU-generated IRQ will occur if no further register reads
	// or writes occur. If IRQ is already pending, returns irq_waiting. If no
	// IRQ will occur, returns no_irq.
	Nes_Apu.prototype.earliest_irq = function() {
		return this.earliest_irq_;
	};
	
	
	// Run APU until specified time, so that any DMC memory reads can be
	// accounted for (i.e. inserting CPU wait states).
	Nes_Apu.prototype.run_until = function( end_time ) {
		//require( end_time >= this.last_time );
		
		if ( end_time === this.last_time ) {
			return;
		}
		
		while ( true ) {
			// earlier of next frame time or end time
			var time = this.last_time + this.frame_delay;
			if ( time > end_time ) {
				time = end_time;
			}
			this.frame_delay -= time - this.last_time;
			
			// run oscs to present
			this._square1.run( this.last_time, time );
			this._square2.run( this.last_time, time );
			this._triangle.run( this.last_time, time );
			this._noise.run( this.last_time, time );
			this._dmc.run( this.last_time, time );
			this.last_time = time;
			
			if ( time === end_time ) {
				break; // no more frames to run
			}
			
			// take frame-specific actions
			this.frame_delay = this.frame_period;
			switch ( this.frame++ ) {
				case 0:
					if ( !(this.frame_mode & 0xc0) ) {
						this.next_irq = time + this.frame_period * 4 + 1;
						this.irq_flag = true;
					}
					// fall through
				case 2:
					// clock length and sweep on frames 0 and 2
					this._square1.clock_length( 0x20 );
					this._square2.clock_length( 0x20 );
					this._noise.clock_length( 0x20 );
					this._triangle.clock_length( 0x80 ); // different bit for halt flag on triangle
					
					this._square1.clock_sweep( -1 );
					this._square2.clock_sweep( 0 );
					break;
				
				case 1:
					// frame 1 is slightly shorter
					this.frame_delay -= 2;
					break;
				
				case 3:
					this.frame = 0;
					
					// frame 3 is almost twice as long in mode 1
					if ( this.frame_mode & 0x80 ) {
						this.frame_delay += this.frame_period - 6;
					}
					break;
			}
			
			// clock envelopes and linear counter every frame
			this._triangle.clock_linear_counter();
			this._square1.clock_envelope();
			this._square2.clock_envelope();
			this._noise.clock_envelope();
		}
	};
	
	
	Nes_Apu.prototype.irq_changed = function() {
		var new_irq = this._dmc.next_irq;
		if ( this._dmc.irq_flag || this.irq_flag ) {
			new_irq = 0;
		} else if ( new_irq > this.next_irq ) {
			new_irq = this.next_irq;
		}
		
		if ( new_irq !== this.earliest_irq_ ) {
			this.earliest_irq_ = new_irq;
			if ( this._irqCallback ) {
				this._irqCallback();
			}
		}
	};

	
	Nes_Apu.prototype.osc_output = function( osc, buf ) {
		//assert(( "Nes_Apu::osc_output(): Index out of range", 0 <= osc && osc < osc_count ));
		this.osc[osc].output = buf;
	};
	
	
	Nes_Apu.prototype.save_snapshot = function() {
	
		var data = {};
		return data;
		
		// for ( int i = 0; i < osc_count * 4; i++ )
			// state->w40xx [i] = oscs [i >> 2]->regs [i & 3];
		// state->w40xx [0x11] = dmc.dac;
		
		// state->w4015    = osc_enables;
		// state->w4017    = frame_mode;
		// state->delay    = frame_delay;
		// state->step     = frame;
		// state->irq_flag = irq_flag;
		
		// typedef apu_reflection<1> refl;
		// Nes_Apu& apu = *(Nes_Apu*) this; // const_cast
		// refl::reflect_square  ( state->square1,     apu.square1 );
		// refl::reflect_square  ( state->square2,     apu.square2 );
		// refl::reflect_triangle( state->triangle,    apu.triangle );
		// refl::reflect_noise   ( state->noise,       apu.noise );
		// refl::reflect_dmc     ( state->dmc,         apu.dmc );
	};
	
	
	Nes_Apu.prototype.load_snapshot = function() {
	
		// reset();
		
		// write_register( 0, 0x4017, state.w4017 );
		// write_register( 0, 0x4015, state.w4015 );
		
		// for ( int i = 0; i < osc_count * 4; i++ )
		// {
			// int n = state.w40xx [i];
			// oscs [i >> 2]->regs [i & 3] = n;
			// write_register( 0, 0x4000 + i, n );
		// }
		
		// frame_delay = state.delay;
		// frame       = state.step;
		// irq_flag    = state.irq_flag > 0;
		
		// typedef apu_reflection<0> refl;
		// apu_snapshot_t& st = (apu_snapshot_t&) state; // const_cast
		// refl::reflect_square  ( st.square1,     square1 );
		// refl::reflect_square  ( st.square2,     square2 );
		// refl::reflect_triangle( st.triangle,    triangle );
		// refl::reflect_noise   ( st.noise,       noise );
		// refl::reflect_dmc     ( st.dmc,         dmc );
		// dmc.recalc_irq();
		// dmc.last_amp = dmc.dac;

	};
	
	Nes.Nes_Apu = Nes_Apu;
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};
this.Gui = this.Gui || {};
	
var APUOutBufferSize = 4096;
var APUBaseRate = 1789773;


var ApuLegacy = function( mainboard ) {
	
	var that = this;
	
	this._outBufferSize = 4096;
	this._soundRate = 44100;
	
	this.mainboard = mainboard;
	this.mainboard.connect( 'reset', function( cold ) { that._onReset( cold ); } );
	this.nextIrq = -1;
	this._irqActive = false;
	this.mLastCalculatedNextIrqTime = -1;
	
	this._enabled = true;
	this._justRenabled = 0;
	var soundRate = 44100;

	this.apu = new Nes.Nes_Apu();
	
	try {
		this._renderer = new Gui.WebAudioRenderer( APUOutBufferSize );
		this._outBuffer = this._renderer.createBuffer( this._outBufferSize );
		soundRate = this._renderer.getSampleRate();
		this.buf = new Nes.Blip_Buffer();
	//	this._writer = new Nes.Wave_Writer( soundRate );
	//	this._writer.activate();
			
		this.buf.clock_rate( APUBaseRate );
		this.apu.output( this.buf );
		this.buf.sample_rate( soundRate );
	}
	catch ( err ) {
		this._renderer = null;
		this._enabled = false;
		console.log( "WebAudio unsupported in this browser. Sound will be disabled..." );
	}
	
	this.apu.dmc_reader( function( addr ) { 
		return mainboard.memory.read8( addr );
	} );
	this.apu.irq_notifier( function() {
		// called when the next predicted nmi changes
		//that.mainboard.synchroniser.synchronise();
		that.CalculateWhenIrqDue();
	} );
};


ApuLegacy.prototype.enableSound = function( enable ) {
	enable = enable === undefined ? true : enable;
	if ( enable !== this._enabled ) {
		if ( enable ) { // after re-enabling sound, fill audio buffer with zeroes to prevent static
			this._justRenabled = 2;
		}
		this._enabled = enable;
	}
};


ApuLegacy.prototype.soundEnabled = function() {
	return this._enabled && this.soundSupported();
};


ApuLegacy.prototype.soundSupported = function() {
	return !!this._renderer;
};


ApuLegacy.prototype.setVolume = function( val ) {
	if ( this._renderer ) {
		this._renderer.setVolume( val );
	}
};


ApuLegacy.prototype._onReset = function( cold ) {

	this.nextIrq = -1;
	this.apu.reset( COLOUR_ENCODING_NAME !== "NTSC" );
};


ApuLegacy.prototype.readFromRegister = function( offset ) {
	var ret = 0;
	if ( offset === this.apu.status_addr ) {
		this.mainboard.synchroniser.synchronise();
		var realTime = Math.floor( this.mainboard.synchroniser.getCpuMTC() / COLOUR_ENCODING_MTC_PER_CPU );			
		if ( offset === 0x4015 && this._irqActive ) {
			// irq acknowledge
			this._irqActive = false;
			//this.mainboard.cpu.holdIrqLineLow( false );
		}
		ret = this.apu.read_status( realTime );
	}
	return ret;
};


ApuLegacy.prototype.writeToRegister = function( offset, data ) {
	if ( offset >= this.apu.start_addr && offset <= this.apu.end_addr ) {
		this.mainboard.synchroniser.synchronise();
		var realTime = Math.floor( this.mainboard.synchroniser.getCpuMTC() / COLOUR_ENCODING_MTC_PER_CPU );
		this.apu.write_register( realTime, offset, data );
	}
};


ApuLegacy.prototype.synchronise = function( startTicks, endTicks ) {
	var cpuClocks = Math.floor( startTicks / COLOUR_ENCODING_MTC_PER_CPU ) - 1;
	this.apu.run_until( cpuClocks >= 0 ? cpuClocks : 0 );
	
	if ( this.apu.earliest_irq() === Nes.Nes_Apu.irq_waiting ) {
		//console.log( "Triggering APU IRQ" );
		//this.mainboard.cpu.holdIrqLineLow();
		this._irqActive = true;
	}
};


ApuLegacy.prototype.onEndFrame = function( cpuMtc ) {
	var realTime = Math.floor( this.mainboard.synchroniser.getCpuMTC() / COLOUR_ENCODING_MTC_PER_CPU );
	this.apu.end_frame( realTime );

	if ( this._renderer && this._enabled ) {
		// Read some samples out of Blip_Buffer if there are enough to
		// fill our output buffer
		this.buf.end_frame( realTime );

		var samplesAvailable = this.buf.samples_avail();

		//	if ( g_options->SoundEnabled && g_options->ApplicationSpeed == 0 ) // dont play sound if disabled or not running at normal speed
		if ( samplesAvailable >= APUOutBufferSize ) {
			//write samples directly to renderer's buffer
			var floatArray = this._outBuffer.lockBuffer();
			this.buf.read_samples( floatArray, APUOutBufferSize );
			this._outBuffer.unlockBuffer();
		//	this._writer.write( buffer, count );
		}
	}
	
	this.CalculateWhenIrqDue();
};


ApuLegacy.prototype._eventIrqTrigger = function( eventTime ) {

	// done in the synchronise method
//	this.mainboard.cpu.holdIrqLineLow();
};


ApuLegacy.prototype.CalculateWhenIrqDue = function() {

	var that = this;
	var earliestIrq = this.apu.earliest_irq();
	if ( earliestIrq !== this.apu.no_irq ) {
		this.nextIrq = earliestIrq * COLOUR_ENCODING_MTC_PER_CPU;
		if ( this.nextIrq >= 0 ) {
			//this.mainboard.synchroniser.addEvent( 'apu irq', this.nextIrq, function( eventTime ) { that._eventIrqTrigger( eventTime ); } );
		}
	} else {
		this.nextIrq = -1;
		// TODO: change irq event if it changes
	}
};


ApuLegacy.prototype.saveState = function() {
	var data = {};
	data.apu = this.apu.save_snapshot();
	data.nextIrq = this.nextIrq;
	data.mLastCalculatedNextIrqTime = this.mLastCalculatedNextIrqTime;
	return data;
};


ApuLegacy.prototype.loadState = function( state ) {

	this.apu.load_snapshot( state.apu );
	this.nextIrq = state.nextIrq;
	this.mLastCalculatedNextIrqTime = state.mLastCalculatedNextIrqTime;
};


Nes.ApuLegacy = ApuLegacy;

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

//////////////////////////////////////////////////////////////////////////
// 7456 cycles after init, triggers quarter frame
// 14912 cycles after init, triggers quarter+half frames 
// 22370 cycles after init, triggers quarter frame
// mode 0 - 29828 cycles after init, triggers quarter+half frames, checks IRQ
// 29829 and 30 - checks IRQ
// 37280 cycles after init, triggers quarter+half frames

var APU_BASE_UNIT = 15; // Number of ticks to use as the base unit MTC timer. This is the NTSC MTC per cpu
var APU_FRAME_COUNTER_INTERVAL = 7456 * APU_BASE_UNIT;
var APU_IRQ_FRAME_EVENT = 29828 * APU_BASE_UNIT;
var APU_FRAME_MODE0_TOTAL = 29830 * APU_BASE_UNIT;
var APU_FRAME_MODE1_TOTAL = 37282 * APU_BASE_UNIT;

// Note: Writing to $4017 with bit 7 set will immediately generate a clock for both the quarter frame and the half frame units, regardless of what the sequencer is doing.

// mode 0:    mode 1:       function
// ---------  -----------  -----------------------------
 // - - - f    - - - - -    IRQ (if bit 6 is clear)
 // - l - l    l - l - -    Length counter and sweep
 // e e e e    e e e e -    Envelope and linear counter


var ApuFrameCounter = function( mainboard ) {
	this._mainboard = mainboard;
	this._mode = 0;
	this._lastFrameStartMtc = 0;
	this._sequenceStage = 0; // either 0,1,2,3 or 4 (if mode 1 enabled) to indicate where in the sequence the frame counter is
	this._irqEventId = -1;
	this._interruptInProgress = false;
};


// This is used by the APU to determine when to decrement the length counters
// Doesn't use the main app's synchroniser as frame clocks don't effect cpu or ppu, but irq does
ApuFrameCounter.prototype.getNextFrameClock = function( ticks ) {

	// work out when next frame count is
	var nextFrameTicks = this._lastFrameStartMtc + ( ( this._sequenceStage + 1 ) * APU_FRAME_COUNTER_INTERVAL );
	if ( nextFrameTicks >= COLOUR_ENCODING_FRAME_MTC ) {
		nextFrameTicks -= COLOUR_ENCODING_FRAME_MTC;
	}
	return nextFrameTicks;
};


ApuFrameCounter.prototype._getNextIrqClock = function( ticks ) {
	
	var nextIrqTicks = this._lastFrameStartMtc + APU_IRQ_FRAME_EVENT;
	if ( nextIrqTicks >= COLOUR_ENCODING_FRAME_MTC ) {
		nextIrqTicks -= COLOUR_ENCODING_FRAME_MTC;
	}
	return nextIrqTicks;
};


ApuFrameCounter.prototype.acknowledgeClock = function( ticks ) {
	this._sequenceStage++;
	var endOfApuFrame = false;
	var frameSize = 0;
	switch ( this._mode ) {
		case 0:
			endOfApuFrame = this._sequenceStage >= 4;
			frameSize = APU_FRAME_MODE0_TOTAL;
			break;
		case 1:
			endOfApuFrame = this._sequenceStage >= 5;
			frameSize = APU_FRAME_MODE1_TOTAL;
			break;
	}
	if ( endOfApuFrame ) {
		// end of the apu frame - the apu frame is slightly longer than simply the clock interval * sequence count
		this._sequenceStage = 0;
		this._lastFrameStartMtc += frameSize;
		if ( this._lastFrameStartMtc >= COLOUR_ENCODING_FRAME_MTC ) {
			this._lastFrameStartMtc -= COLOUR_ENCODING_FRAME_MTC;
		}
		// Update IRQ time
		this._mainboard.synchroniser.changeEventTime( this._irqEventId, this._getNextIrqClock() );
	}
};


ApuFrameCounter.prototype.onEndFrame = function() {

};


ApuFrameCounter.prototype.reset = function() {
	var that = this;
	this._irqEventId = this._mainboard.synchroniser.addEvent( 'apu irq', -1, function( eventTime ) { that._eventApuIrq( eventTime ); } );
};


ApuFrameCounter.prototype._eventApuIrq = function( eventTime ) {
	if ( !this._interruptInProgress ) {
		this._interruptInProgress = true;
		this.mainboard.cpu.holdIrqLineLow( true );
	}
};


ApuFrameCounter.prototype.acknowledgeIrq = function() {
	if ( this._interruptInProgress ) {
		this._mainboard.cpu.holdIrqLineLow( false );
		this._interruptInProgress = false;
	}
};


Nes.ApuFrameCounter = ApuFrameCounter;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};


// You aren't handling odd clock jitter properly. It's really simple, if the APU is on an odd clock on the $4017 write, act as if the write was one clock later.

var ApuOutputBuffer = function( webAudioBuffer, size, sampleRate ) {

	this._buffer = webAudioBuffer;
	this._array = new Float32Array( size );
	this._sampleRate = sampleRate;
	this._framesWorthOfDataSize = Math.floor( this._sampleRate / COLOUR_ENCODING_REFRESHRATE ); // sample rate is number of samples consumed in a second.
	if ( this._array.length < this._framesWorthOfDataSize ) {
		throw new Error( "Could not contain a frames worth of audio data in the provided audio buffer!" );
	}
	this.clear();
};


ApuOutputBuffer.prototype._ticksToBufferPosition = function( ticks ) {

	var pos = Math.floor( ( ticks / COLOUR_ENCODING_FRAME_MTC ) * this._framesWorthOfDataSize );
	return pos;
};


ApuOutputBuffer.prototype.clear = function() {

	for ( var i=0; i<this._array.length; ++i ) {
		this._array[i] = 0;
	}
};


ApuOutputBuffer.prototype.write = function( startTicks, lengthTicks, val ) {
	
	var startBytes = this._ticksToBufferPosition( startTicks );
	var endBytes = Math.min( this._array.length, this._ticksToBufferPosition( startTicks + lengthTicks ) );
	for ( var i=startBytes; i<endBytes; ++i ) {
		this._array[ i ] = val;
	}
};


ApuOutputBuffer.prototype.commit = function() {

	// commit to web audio api
	var dest = this._buffer.lockBuffer();
	for ( var i=0; i<this._array.length; ++i ) {
		dest[i] = this._array[i];
	}
	this._buffer.unlockBuffer();
};

Nes.ApuOutputBuffer = ApuOutputBuffer;

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

//////////////////////////////////////////////////////////////////////////


var ApuEnvelope = function() {
	this._envelopeCounter = 0; // number of ticks every time the envelope volume is decremented.
	this._envelopeVolume = 0;
	this._doEnvelopeReloadOnNextClock = false;
};


ApuEnvelope.prototype.reset = function() {
	this._envelopeCounter = 0;
	this._envelopeVolume = 0;
	this._doEnvelopeReloadOnNextClock = false;
};


ApuEnvelope.prototype.reloadOnNextClock = function() {
	this._doEnvelopeReloadOnNextClock = true;
};

// Called every time the envelope is clocked by the divider
ApuEnvelope.prototype.decrementCounter = function( envelopeNotLooped ) {
	
	if ( this._doEnvelopeReloadOnNextClock ) {
		this._doEnvelopeReloadOnNextClock = false;
		this._envelopeCounter = this._volumeValue;
		this._envelopeVolume = 15;
	} else {
		this._envelopeCounter--;
		if ( this._envelopeCounter < 0 ) {
			this._envelopeCounter = this._volumeValue;
			if ( this._envelopeVolume > 0 || !envelopeNotLooped ) {
				this._envelopeVolume--;
				if ( this._envelopeVolume < 0 ) {
					this._envelopeVolume = 15;
				}
			}
		}
	}
};


ApuEnvelope.prototype.getEnvelopeVolume = function() {
	return this._envelopeVolume;
};


Nes.ApuEnvelope = ApuEnvelope;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};


//////////////////////////////////////////////////////////////

var lengthCounterTable = [
	0x0A, 0xFE, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06,
	0xA0, 0x08, 0x3C, 0x0A, 0x0E, 0x0C, 0x1A, 0x0E, 
	0x0C, 0x10, 0x18, 0x12, 0x30, 0x14, 0x60, 0x16,
	0xC0, 0x18, 0x48, 0x1A, 0x10, 0x1C, 0x20, 0x1E
];


var ApuSquareWaveOscillator = function( buffer ) {
	
	this._buffer = buffer;
	this._enabled = false;
	this._timer = 0;
	this._lengthCounter = 0;
	this._lengthCounterEnabled = true;
	this._useConstantVolume = false;
	this._volumeValue = 0;
	this._envelope = new Nes.ApuEnvelope();
	
	this._delay = 0;
};

ApuSquareWaveOscillator.prototype.decrementLengthCounter = function() {
	if ( this._lengthCounter > 0 && this._lengthCounterEnabled ) {
		this._lengthCounter--;
		if ( this._lengthCounter === 0 ) {
			// silence
		}
	}
};

ApuSquareWaveOscillator.prototype._getVolume = function() {
	if ( this._lengthCounter > 0 && this._timer >= 8 ) {
		if ( this._useConstantVolume ) {
			return this._volumeValue;
		} else {
			return this._envelope.getEnvelopeVolume();
		}
	}
	return 0;
};

ApuSquareWaveOscillator.prototype.enable = function( enabled ) {
	this._enabled = enabled;
	this._lengthCounter = 0; // set length counter to zero on enabled/disabled
	// disable irq flag (?)
};

ApuSquareWaveOscillator.prototype.writeEnvelope = function( data ) {
	// DDLC VVVV 	Duty (D), envelope loop / length counter halt (L), constant volume (C), volume/envelope (V)
	this._lengthCounterEnabled = ( data & 0x20 ) === 0;
	this._useConstantVolume = ( data & 0x10 ) === 0x10;
	this._volumeValue = data & 0xF;
};

ApuSquareWaveOscillator.prototype.writeSweep = function( data ) {
	// EPPP NSSS 	Sweep unit: enabled (E), period (P), negate (N), shift (S)
};

ApuSquareWaveOscillator.prototype.writeTimer = function( data ) {
	// TTTT TTTT	Timer low (T) (bottom 8 bits)
	this._timer = ( this._timer & 0x700 ) | data;
};

ApuSquareWaveOscillator.prototype.writeLengthCounter = function( data ) {
	// LLLL LTTT 	Length counter load (L), timer high (T)
	this._timer = ( this._timer & 0xFF ) | ( ( data & 0x7 ) << 8 );
	this._lengthCounter = lengthCounterTable[ (data >> 3) & 0x1f ];
	//  (also resets duty and starts envelope)
	this._envelope.reloadOnNextClock();
};


ApuSquareWaveOscillator.prototype._4bitVolumeToBufferValue = function( vol ) {
	return ( vol / 16 );// * 128.0;
};


ApuSquareWaveOscillator.prototype.synchronise = function( startTicks, endTicks ) {

	if ( !this._enabled ) {
		return;
	}

	var volume = this._getVolume();
	var period = this._timer;
	
	// TODO: apply sweep shift
	var offset = 0;
	
	// OPTIMISE: When silent, dont do loop - just calculate next phase
	var timer_period = ( period + 1 ) * 16 * COLOUR_ENCODING_MTC_PER_CPU; // APU cycle is 2* cpu cycle - pulse timer period is 16* cpu cycle due to sequencer having 8 steps
	var timeUp = Math.floor( timer_period / 2 ); // TODO: implement correct duty cycle: this is 50/50 here
	var timeDown = timer_period - timeUp;
	var mtc = startTicks + this._delay;
	var delta = this._4bitVolumeToBufferValue( volume );
	for ( ; mtc<endTicks; mtc += timer_period ) {

		if ( this._lengthCounter === 0 || volume === 0 || ( period + offset ) >= 0x800 ) {
			// silent
		} else {
			this._buffer.write( mtc, timeUp, delta );
			this._buffer.write( mtc + timeUp, timeDown, -delta );
		}
		//this._decrementLengthCounter();
		//this._decrementLengthCounter();
	}
	this._delay = mtc - endTicks;
};


Nes.ApuSquareWaveOscillator = ApuSquareWaveOscillator;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

///////////////////////////////////////////////////////////////////////////////////////////////


var Apu = function( mainboard ) {
	
	var that = this;
	
	this.mainboard = mainboard;
	this.mainboard.connect( 'reset', function( cold ) { that._onReset( cold ); } );

	this._enabled = true;
	this._soundRate = 44100;
	this._outBufferSize = 4096;

	try {
		this._renderer = new Gui.WebAudioRenderer( this._outBufferSize );
		this._soundRate = this._renderer.getSampleRate();
		//this._triangle = new ApuWaveOscillator( 'triangle' );
		// noise
		// dmc
	}
	catch ( err ) {
		this._renderer = null;
		this._enabled = false;
		console.log( "WebAudio unsupported in this browser. Sound will be disabled..." );
	}
	
	this._frameCounter = new Nes.ApuFrameCounter( this.mainboard );
	this._buffers = [];
	this._square1 = new ApuSquareWaveOscillator( this._addBuffer() );
	this._square2 = new ApuSquareWaveOscillator( this._addBuffer() );
	
	//this._squareTest = new Nes.SquareWaveTester();
};


Apu.prototype._addBuffer = function() {
	var buffer = new ApuOutputBuffer( this._renderer.createBuffer( this._outBufferSize ), this._outBufferSize, this._soundRate );
	this._buffers.push( buffer );
	return buffer;
};


Apu.prototype.enableSound = function( enable ) {
	this._enabled = enable;
};


Apu.prototype.soundEnabled = function() {
	return this._enabled && this.soundSupported();
};


Apu.prototype.soundSupported = function() {
	return !!this._renderer;
};


Apu.prototype.setVolume = function( val ) {
	if ( this._renderer ) {
		this._renderer.setVolume( val );
	}
};


Apu.prototype._onReset = function( cold ) {

	this._frameCounter.reset();
};


Apu.prototype.readFromRegister = function( offset ) {
	var ret = 0;

	return ret;
};


Apu.prototype.writeToRegister = function( offset, data ) {

	switch ( offset ) {
	case 0x4000: // square 1
		this._square1.writeEnvelope( data );
		break;
	case 0x4001:
		this._square1.writeSweep( data );
		break;
	case 0x4002:
		this._square1.writeTimer( data );
		break;
	case 0x4003:
		this._square1.writeLengthCounter( data );
		break;
	case 0x4004: // square 2
		this._square2.writeEnvelope( data );
		break;
	case 0x4005:
		this._square2.writeSweep( data );
		break;
	case 0x4006:
		this._square2.writeTimer( data );
		break;
	case 0x4007:
		this._square2.writeLengthCounter( data );
		break;
	
	// The status register is used to enable and disable individual channels,
	// control the DMC, and can read the status of length counters and APU interrupts.
	case 0x4015:
		this._square1.enable( ( data & 0x1 ) > 0 );
		this._square2.enable( ( data & 0x2 ) > 0 );
		//this._triangle.enable( ( data & 0x4 ) > 0 );
		//this._noise.enable( ( data & 0x8 ) > 0 );
		//this._dmc.enable( ( data & 0x10 ) > 0 );
		break;
	}
	
};


Apu.prototype.synchronise = function( startTicks, endTicks ) {

	if ( this._enabled ) {
	
		while ( startTicks < endTicks ) {
			var nextFrameTick = this._frameCounter.getNextFrameClock( startTicks );
		
			var syncEnd = Math.min( endTicks, nextFrameTick );
			
			this._square1.synchronise( startTicks, syncEnd );
			this._square2.synchronise( startTicks, syncEnd );
			
			if ( syncEnd === nextFrameTick ) {
				this._square1.decrementLengthCounter();
				this._square2.decrementLengthCounter();
				this._frameCounter.acknowledgeClock( nextFrameTick );
			}
			
			startTicks = syncEnd;
		}
	}
};


Apu.prototype.onEndFrame = function( cpuMtc ) {

//	this._squareTest.onEndFrame();
	this._frameCounter.onEndFrame();
	
	if ( this._renderer && this._enabled ) {
	
		for ( var index=0; index<this._buffers.length; ++index ) {
			var buf = this._buffers[index];
			buf.commit();
			buf.clear();
		}

		// //	if ( g_options->SoundEnabled && g_options->ApplicationSpeed == 0 ) // dont play sound if disabled or not running at normal speed
		// if ( samplesAvailable >= APUOutBufferSize ) {
			// //write samples directly to renderer's buffer
			// var buffer = this._renderer.lockBuffer();
			// if ( this._justRenabled > 0 ) {
				// for ( var i=0; i<APUOutBufferSize; ++i ) {
					// buffer[i] = 0;
				// }
				// this._justRenabled--;
			// } else {
				// this.buf.read_samples( buffer, APUOutBufferSize );
			// }
		// //	this._writer.write( buffer, count );
			// this._renderer.unlockBuffer();
		// }
	}
};



Apu.prototype.saveState = function() {
	var data = {};
	return data;
};


Apu.prototype.loadState = function( state ) {

};


Nes.Apu = Apu;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

///////////////////////////////////////////////////////////////////////////////////////////////


var SquareWaveTester = function( mainboard ) {
	
	var that = this;
	
	this._enabled = true;
	this._soundRate = 44100;
	this._outBufferSize = 4096;

	try {
		this._renderer = new Gui.WebAudioRenderer( this._outBufferSize );
		this._soundRate = this._renderer.getSampleRate();
	}
	catch ( err ) {
		this._renderer = null;
		this._enabled = false;
		console.log( "WebAudio unsupported in this browser. Sound will be disabled..." );
	}
	
	this._buffers = [];
	this._square1 = new ApuSquareWaveOscillator( this._addBuffer() );
	this._square1.enable( true );
	
	this._square1.writeTimer( 128 );
	this._square1.writeLengthCounter( 0x20 );  // writes value of 4 to length counter
	this._square1.writeEnvelope( 0x1F ); // constant volume mode, maximum volume
};


SquareWaveTester.prototype._addBuffer = function() {
	var buffer = new ApuOutputBuffer( this._renderer.createBuffer( this._outBufferSize ), this._outBufferSize, this._soundRate );
	this._buffers.push( buffer );
	return buffer;
};


SquareWaveTester.prototype.synchronise = function( startTicks, endTicks ) {

	if ( this._enabled ) {
		this._square1.synchronise( startTicks, endTicks );
	}
};


SquareWaveTester.prototype.onEndFrame = function( cpuMtc ) {

	if ( this._renderer && this._enabled ) {
		// run a frames worth of sound processing
		this.synchronise( 0, COLOUR_ENCODING_FRAME_MTC );
	
		for ( var index=0; index<this._buffers.length; ++index ) {
			var buf = this._buffers[index];
			buf.commit();
			buf.clear();
		}
	}
};


Nes.SquareWaveTester = SquareWaveTester;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

// consts use by renderPartialScanline
var ScrollReloadTime = 304; // pre-render SL only
var XReloadTime = 257;
var SecondLastTileReloadTime = 324;
var LastTileReloadTime = 332;

var ticksPerTile = 8;
var ticksFirstTile = 3;
var ticksLastTile = ticksFirstTile + ( 31 * ticksPerTile );

var YIncrementTime = 251;
var YIncrementTimeRendering = ( YIncrementTime + 17 ) * MASTER_CYCLES_PER_PPU;
var XReloadTimeRendering = ( XReloadTime + 17 ) * MASTER_CYCLES_PER_PPU;


var backgroundRenderingStart = 0;//this.ppu.screenCoordinatesToTicks( ScrollReloadTime-1, -1 );
var backgroundRenderingEnd = 0;//this.ppu.screenCoordinatesToTicks( SecondLastTileReloadTime-1, 239 );
var backgroundScrollReloadTime = 0; // this.ppu.screenCoordinatesToTicks( ScrollReloadTime, -1 );


var PpuRenderBg = function( ppu ) {

	this.ppu = ppu;
	this._spriteZeroHit = false;
	this._useMMC2Latch = false;
};


PpuRenderBg.prototype.reset = function() {

	backgroundRenderingStart = this.ppu.screenCoordinatesToTicks( ScrollReloadTime-1, -1 );
	backgroundRenderingEnd = this.ppu.screenCoordinatesToTicks( SecondLastTileReloadTime-1, 239 );
	backgroundScrollReloadTime = this.ppu.screenCoordinatesToTicks( ScrollReloadTime, -1 );

	this._bgTableAddress = 0;
	this._spriteZeroHit = false;
	this._renderBuffer = this.ppu.mainboard.renderBuffer;
	this._useMMC2Latch = this.ppu.mainboard.cart.memoryMapper.MMC2Latch !== undefined;
};


PpuRenderBg.prototype.onControl1Change = function( control1 ) {

	this._bgTableAddress = ( control1 & 0x10 ) > 0 /*ppuControl1.screenPatternTableAddress*/ ? 0x1000 : 0;
};


PpuRenderBg.prototype.onEndFrame = function() {

	this._spriteZeroHit = false;
};


PpuRenderBg.prototype.saveState = function( data ) {

	data._spriteZeroHit = this._spriteZeroHit;
};


PpuRenderBg.prototype.loadState = function( state ) {

	this._spriteZeroHit = state._spriteZeroHit;
};


PpuRenderBg.prototype._renderTile = function( ppuReadAddress, tilenum, posy, clippingEnabled ) {

	var triggerTime = 0;
	var renderScanline = posy|0;// ( tilenum <= 2 ? posy + 1 : posy );
	var startXRendering = clippingEnabled ? 8 : 0;
	var baseindex = (tilenum|0) * 8;

	var htile = (ppuReadAddress & 0x001F);
	var vtile = (ppuReadAddress & 0x03E0) >> 5;
	//var finey = ((this.ppu.ppuReadAddress & 0x7000) >> 12);

	var nameTableAddress = ( 0x2000 + (ppuReadAddress & 0x0FFF) ) & 0xFFFF;
	var tileNumber = this.ppu.readNameTable( nameTableAddress, 0 );

	// (screen address) + (tilenumber * 16) + finey
	var tileAddress = this._bgTableAddress + tileNumber * 16 + ((ppuReadAddress & 0x7000) >> 12);
	var attributeByte = this.ppu.readNameTable( 0x23C0 | (ppuReadAddress & 0x0C00) | ((vtile & 0x1C) << 1) | ( (htile >> 2) & 0x7 ), 1 );

	var mergeByte = 0;
	if ( ( htile & 0x2 ) === 0 ) {
		if ( ( vtile & 0x2 ) === 0 ) {
			mergeByte = ( attributeByte & 0x3 ) << 2;
		} else {
			mergeByte = ( attributeByte & 0x30 ) >> 2;
		}
	} else {
		if ( ( vtile & 0x2 ) === 0 ) {
			mergeByte = ( attributeByte & 0xC );
		} else {
			mergeByte = ( attributeByte & 0xC0 ) >> 4;
		}
	}

	//Nes.Trace.writeLine( 'ppu', 'Tile rendered pos: ' + tilenum + ' tileid: ' + tileNumber + ' h=' + htile + ' v=' + vtile + ' ppuAddress=' + ppuReadAddress.toString( 16 ) );
	
	// pattern table reads
	var firstByte = this.ppu.read8( tileAddress, false, 2 );
	var secondByte = this.ppu.read8( tileAddress + 8, false, 3 );
	
	if ( this._useMMC2Latch ) {
		this.ppu.mainboard.cart.memoryMapper.MMC2Latch( tileAddress + 8 );
	}
	
	// render tiles from right-most pixel first - allows us to shift the first & second pattern table byte to get the palette
	// index we want.
	
	var startPixel = baseindex - this.ppu.fineX;
	var endPixel = startPixel + 7;
	var realStartPixel = Math.max( startPixel, 0 );
	var startPixelIndex = realStartPixel - startPixel;
	var paletteIndex = 0;
	var byteMask = 0x80 >> startPixelIndex;
	var x = realStartPixel;
	for ( ; x<=endPixel; ++x )
	{
		paletteIndex = ( firstByte & byteMask ) > 0 ? 0x1 : 0;
		paletteIndex |= ( secondByte & byteMask ) > 0 ? 0x2 : 0;
		
		byteMask >>= 1;

		if ( x >= startXRendering && x < SCREEN_WIDTH ) {
			if ( paletteIndex > 0 ) {
				paletteIndex |= mergeByte;

				if ( ( paletteIndex & 0x3 ) === 0 )
					paletteIndex = 0;
					
				if ( this._renderBuffer.renderPixel( x, renderScanline,  this.ppu.paletteTables[ 0 ][ paletteIndex & 0xF ] | 0 ) ) {
					
					// Sprite zero hit - will happen in the future as this is the prefetch
					if ( !this._spriteZeroHit ) {
						triggerTime = this.ppu.screenCoordinatesToTicks( x, renderScanline );
						this._spriteZeroHit = true;
						this.ppu.mainboard.synchroniser.changeEventTime( this.ppu._spriteZeroEventId, triggerTime );
					}
				}
			}
		}
	}
};


var backgroundTileCount = 34;


PpuRenderBg.prototype._incrementY = function( ppuReadAddress ) {
	/*
		Y increment
		At dot 256 of each scanline, fine Y is incremented, overflowing to coarse Y, and finally adjusted to wrap among the nametables vertically.
		Bits 12-14 are fine Y. Bits 5-9 are coarse Y. Bit 11 selects the vertical nametable.
			if ((v & 0x7000) != 0x7000)        // if fine Y < 7
				v += 0x1000                      // increment fine Y
			else
				v &= ~0x7000                     // fine Y = 0
				int y = (v & 0x03E0) >> 5        // let y = coarse Y
				if y == 29
					y = 0                          // coarse Y = 0
					v ^= 0x0800                    // switch vertical nametable
				else if y == 31
					y = 0                          // coarse Y = 0, nametable not switched
				else
					y += 1                         // increment coarse Y
				v = (v & ~0x03E0) | (y << 5)     // put coarse Y back into v
	*/
	// INCREMENT Y LOGIC
	if ((ppuReadAddress & 0x7000) === 0x7000) {
		// wrap when tile y offset = 7
		//ppuReadAddress &= ~0x7000;
		ppuReadAddress &= 0x8FFF;

		if ((ppuReadAddress & 0x03E0) === 0x03A0) {
			// wrap tile y and switch name table bit 11, if tile y is 29
			ppuReadAddress ^= 0x0800; 
			ppuReadAddress &= 0xFC1F;
		} else if ((ppuReadAddress & 0x03E0) === 0x03E0) {
			// wrap tile y if it is 31
			ppuReadAddress &= 0xFC1F;
		} else {
			// just increment tile y
			ppuReadAddress += 0x0020;
		}
	} else {
		// increment tile y offset
		ppuReadAddress += 0x1000; 
	}
	return ppuReadAddress;
};


PpuRenderBg.prototype._incrementX = function( ppuReadAddress ) {
	/*
	The coarse X component of v needs to be incremented when the next tile is reached. Bits 0-4 are incremented, with overflow toggling bit 10. This means that bits 0-4 count from 0 to 31 across a single nametable, and bit 10 selects the current nametable horizontally.
	if ((v & 0x001F) == 31) // if coarse X == 31
	  v &= ~0x001F          // coarse X = 0
	  v ^= 0x0400           // switch horizontal nametable
	else
	  v += 1                // increment coarse X
	*/
	// INCREMENT X LOGIC
	if ((ppuReadAddress & 0x001F) === 0x001F) {
		// switch name tables (bit 10) and reset tile x to 0
		ppuReadAddress = ( ppuReadAddress ^ 0x0400 ) & 0xFFE0;
	} else {
		// next tile
		ppuReadAddress = ( ppuReadAddress + 1 ) & 0xFFFF;
	}
	return ppuReadAddress;
};


PpuRenderBg.prototype.renderTo = function( startTicks, endTicks, ppuReadAddress, ppuLatchAddress ) {

	var ticksInFirstLine = 0;
	var ticksAtFirstScanline = 0;
	var tileTickPosition = 0;
	var tilenum = 0;
	var ticksAtFirstRenderingScanline = 0;
	var ticksAtFirstRenderingScanlineEnd = 0;
	var scanlineStart = 0;
	var posy = 0;
	var clippingEnabled = ( this.ppu.control2 & 0x2 ) === 0/*ppuControl2.backgroundClipping*/;
	var backgroundRenderingEnabled = ( this.ppu.control2 & 0x8 ) > 0 /* ppuControl2.backgroundSwitch */;
	var reloadTime = 0;
	var incrementYTime = 0;
	var scanline = 0;

	if ( startTicks < backgroundRenderingStart ) {
		startTicks = backgroundRenderingStart;
	}
	if ( endTicks > backgroundRenderingEnd ) {
		endTicks = backgroundRenderingEnd;
	}
	if ( endTicks <= startTicks ) {
		return ppuReadAddress;
	}

	ticksInFirstLine = ( startTicks % MASTER_CYCLES_PER_SCANLINE );
	ticksAtFirstScanline = startTicks - ticksInFirstLine;
	ticksAtFirstRenderingScanline = ticksAtFirstScanline - MASTER_CYCLES_PER_SCANLINE + ( SecondLastTileReloadTime * MASTER_CYCLES_PER_PPU );
	ticksAtFirstRenderingScanlineEnd = ticksAtFirstRenderingScanline + MASTER_CYCLES_PER_SCANLINE; // ( 34 * 8 * MASTER_CYCLES_PER_PPU );
	
	while ( ticksAtFirstRenderingScanlineEnd < startTicks || ticksAtFirstRenderingScanline < backgroundRenderingStart ) {
		ticksAtFirstRenderingScanline += MASTER_CYCLES_PER_SCANLINE;
		ticksAtFirstRenderingScanlineEnd += MASTER_CYCLES_PER_SCANLINE;
	}
		
	if ( backgroundScrollReloadTime > startTicks && backgroundScrollReloadTime <= endTicks ) {
		// reset ppu address on cycle 304 of pre-render scanline
		ppuReadAddress = (ppuReadAddress & 0x41F) | (ppuLatchAddress & 0x7BE0);
	}

//	Nes.Trace.writeLine( 'ppu', 'Start sync start=' + JSON.stringify( this.ppu.ticksToScreenCoordinates( startTicks ) ) + ' end=' + JSON.stringify( this.ppu.ticksToScreenCoordinates( endTicks ) ) + " ticksAtFirstRenderingScanline=" + JSON.stringify( this.ppu.ticksToScreenCoordinates( ticksAtFirstRenderingScanline ) ) );

	scanlineStart = ticksAtFirstRenderingScanline;
	scanline = ( Math.floor( ( ticksAtFirstRenderingScanline - backgroundRenderingStart ) / MASTER_CYCLES_PER_SCANLINE ) ) | 0;

	// tile prefetches between SecondLastTileReloadTime (previous line) for 34 tiles
	while ( scanlineStart <= endTicks ) {
		incrementYTime = scanlineStart + YIncrementTimeRendering;
		reloadTime = scanlineStart + XReloadTimeRendering;

		for ( tilenum=0; tilenum<backgroundTileCount; ++tilenum ) {
		
			tileTickPosition = scanlineStart + ( tilenum * 8 * MASTER_CYCLES_PER_PPU );
							
			if ( tileTickPosition > endTicks || tileTickPosition > backgroundRenderingEnd ) {
				break;
			}
			if ( tileTickPosition <= startTicks ) {
				continue;
			}
			
			if ( backgroundRenderingEnabled ) {
				this._renderTile( ppuReadAddress, tilenum, scanline, clippingEnabled );
			}
			ppuReadAddress = this._incrementX( ppuReadAddress );
		}

		// render last tile on screen, increment Y
		if ( incrementYTime < backgroundRenderingEnd && incrementYTime > startTicks && incrementYTime <= endTicks ) {
			ppuReadAddress = this._incrementY( ppuReadAddress );
		}

		//Nes.Trace.writeLine( 'ppu', 'reloadTime=' + JSON.stringify( this.ppu.ticksToScreenCoordinates( reloadTime ) ) + " scanlineStart=" + JSON.stringify( this.ppu.ticksToScreenCoordinates( scanlineStart ) ) );
		if ( reloadTime < backgroundRenderingEnd && reloadTime > startTicks && reloadTime <= endTicks ) {
			ppuReadAddress = (ppuReadAddress & 0xFBE0) | (ppuLatchAddress & 0x041F);
		}
		
		scanlineStart += MASTER_CYCLES_PER_SCANLINE;
		scanline++;
	}
	return ppuReadAddress;
};


Nes.PpuRenderBg = PpuRenderBg;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var PpuRenderSprites = function( ppu ) {

	this.ppu = ppu;
	this._overflowSet = false;
	this._useMMC2Latch = false;
};


PpuRenderSprites.prototype.reset = function() {

	this._overflowSet = false;
	this._useMMC2Latch = this.ppu.mainboard.cart.memoryMapper.MMC2Latch !== undefined;
};


PpuRenderSprites.prototype.onEndFrame = function() {

	this._overflowSet = false;
};


PpuRenderSprites.prototype.saveState = function( data ) {

	data._overflowSet = this._overflowSet;
};


PpuRenderSprites.prototype.loadState = function( state ) {

	this._overflowSet = state._overflowSet;
};

/* TODO: 2C02 errata.txt states: Is this right?
What was the timing issue? I fixed 3 major
ones: sprites are evaluated on PPU clock #256,
and not at every 4 pixels like the NTSC 2C02
technical document describes.
*/
var spriteEvaluationStart = 64;
	
var isRangeOverlapping = function( a1, a2, b1, b2 ) {
	// http://stackoverflow.com/questions/3269434/whats-the-most-efficient-way-to-test-two-integer-ranges-for-overlap
	return a2 >= b1 && a1 <= b2;
};



PpuRenderSprites.prototype._renderSprite = function( spriteHeight, spritenum, startline, endline, spritey ) {

	var spriteIndex = spritenum*4;
	var patternnum =  this.ppu.spriteMemory[ spriteIndex + 1 ];
	var attribs =  this.ppu.spriteMemory[ spriteIndex + 2 ];
	var sx =  this.ppu.spriteMemory[ spriteIndex + 3 ];

	var behindBackground = ( attribs & 0x20 ) > 0;
	var flipHorz = ( attribs & 0x40 ) > 0;
	var flipVert = ( attribs & 0x80 ) > 0;
	
	var renderScanlineStart = Math.max( spritey, startline );
	var renderScanlineEnd = Math.min( spritey + spriteHeight - 1, endline );
	var ppuAddress = 0;
	var absSy = 0;
	var mask = 0;
	var topsprite = false;
	var firstByte = 0;
	var secondByte = 0;
	var paletteMergeByte = 0;
	var absx = 0;
	var x = 0;

	for ( var scanline=renderScanlineStart; scanline<=renderScanlineEnd; ++scanline ) {
		ppuAddress = 0;
		absSy = scanline - spritey;

		if ( spriteHeight === 8 /*!ppuControl1.spriteSize*/ )
		{
			ppuAddress = ( patternnum * 16 ) + ( ( flipVert ? 7 - absSy : absSy ) & 0x7 ) + ( ( this.ppu.control1 & 0x8 ) > 0 /*ppuControl1.spritePatternTableAddress*/ ? 0x1000 : 0 );
		}
		else // big sprites - if sprite num is even, use 0x0 else use 0x1000
		{
			ppuAddress = ((patternnum & 0xFE) * 16) + ((patternnum & 0x01) * 0x1000);

			topsprite = IS_INT_BETWEEN( scanline, spritey, spritey + 8 );

			if ( !topsprite )
			{ // on flipped, put top sprite on bottom & vis versa
				if ( flipVert )
					ppuAddress += 15 - scanline + spritey;
				else
					ppuAddress += 8 + absSy;
			}
			else
			{
				if ( flipVert )
					ppuAddress += 23 - scanline + spritey;
				else
					ppuAddress += absSy;
			}
		}

		firstByte = this.ppu.read8( ppuAddress, true, 0 );
		secondByte = this.ppu.read8( ppuAddress + 8, true, 0 );
		paletteMergeByte = (attribs & 3) << 2;
		
		if ( this._useMMC2Latch ) {
			this.ppu.mainboard.cart.memoryMapper.MMC2Latch( ppuAddress + 8 );
		}

		for ( x=0; x<8; ++x )
		{
			absx = x + sx;

			// check sprite clipping
			if ( ( this.ppu.control2 & 0x4 ) === 0 /*!ppuControl2.spriteClipping*/ && absx < 8 ) {
				continue;
			}
			if ( absx > 255 ) {
				break;
			}
		
			mask = 0x80 >> ( flipHorz ? 7 - x : x );
				
			// get 2 lower bits from the pattern table for the colour index
			var paletteindex = ( firstByte & mask ) > 0 ? 1 : 0; // first bit
			paletteindex |= ( secondByte & mask ) > 0 ? 2 : 0; // second bit

			// add 2 upper bits
			if ( paletteindex > 0 ) {
				paletteindex |= paletteMergeByte;
				this.ppu.mainboard.renderBuffer.renderSpritePixel( spritenum, behindBackground, absx, scanline,  this.ppu.paletteTables[ 1 ][ paletteindex & 0xF ] | 0 );
			}
							
		//	if ( this.ppu.mainboard.debuggingEnabled ) {
		//		this.ppu.mainboard.renderBuffer.renderSpritePixelDebug( spritenum, absx, scanline );
		//	}
		}
	}
};

	
//*** Cycles 0-63: Secondary OAM (32-byte buffer for current sprites on scanline) is initialized to $FF - attempting to read $2004 will return $FF
//*** Cycles 64-255: Sprite evaluation
//* On even cycles, data is read from (primary) OAM
//* On odd cycles, data is written to secondary OAM (unless writes are inhibited, in which case it will read the value in secondary OAM instead)
//1. Starting at n = 0, read a sprite's Y-coordinate (OAM[n][0], copying it to the next open slot in secondary OAM (unless 8 sprites have been found, in which case the write is ignored).
//1a. If Y-coordinate is in range, copy remaining bytes of sprite data (OAM[n][1] thru OAM[n][3]) into secondary OAM.
//2. Increment n
//2a. If n has overflowed back to zero (all 64 sprites evaluated), go to 4
//2b. If less than 8 sprites have been found, go to 1
//2c. If exactly 8 sprites have been found, disable writes to secondary OAM
//3. Starting at m = 0, evaluate OAM[n][m] as a Y-coordinate.
//3a. If the value is in range, set the sprite overflow flag in $2002 and read the next 3 entries of OAM (incrementing 'm' after each byte and incrementing 'n' when 'm' overflows); if m = 3, increment n
//3b. If the value is not in range, increment n AND m (without carry). If n overflows to 0, go to 4; otherwise go to 3
//4. Attempt (and fail) to copy OAM[n][0] into the next free slot in secondary OAM, and increment n (repeat until HBLANK is reached)
//*** Cycles 256-319: Sprite fetches (8 sprites total, 8 cycles per sprite)
//1-4: Read the Y-coordinate, tile number, attributes, and X-coordinate of the selected sprite
//5-8: Read the X-coordinate of the selected sprite 4 times.
//* On the first empty sprite slot, read the Y-coordinate of sprite #63 followed by $FF for the remaining 7 cycles
//* On all subsequent empty sprite slots, read $FF for all 8 reads
//*** Cycles 320-340: Background render pipeline initialization
//* Read the first byte in secondary OAM (the Y-coordinate of the first sprite found, sprite #63 if no sprites were found)

PpuRenderSprites.prototype.renderTo = function( startTicks, endTicks ) {

	// Further optimisations can be made: Keep list of visible sprites, update on memory changes -
	// don't need to iterate over 64 of them each time then
	// (dont think this'll work as you need to go over 64 sprites anyway for overflow check)
	
	var firstSpriteEvaluation = this.ppu.screenCoordinatesToTicks( spriteEvaluationStart-1, -1 );
	var lastSpriteEvaluation = this.ppu.screenCoordinatesToTicks( spriteEvaluationStart, 238 );
	var spritesVisible = ( this.ppu.control2 & 0x10 ) > 0 /*ppuControl2.spritesVisible*/;
	var ticksIntoCurrentLine = ( startTicks % MASTER_CYCLES_PER_SCANLINE );
	var nextSpriteEval = startTicks - ticksIntoCurrentLine + spriteEvaluationStart * MASTER_CYCLES_PER_PPU;
	var startline = 0;
	var endline = 0;
	var spriteHeight = ( this.ppu.control1 & 0x20 ) > 0 /*ppuControl1.spriteSize*/ ? 16 : 8;
	var nextScanlineSpritesCount = 0;
	var readFromY = 0;
	var spritenum = 0;
	var spritey = 0;
	var that = this;
	
	if ( !spritesVisible ) {
		return;
	}

	if ( startTicks < firstSpriteEvaluation ) {
		startTicks = firstSpriteEvaluation;
	}
	if ( endTicks > lastSpriteEvaluation ) {
		endTicks = lastSpriteEvaluation;
	}
	
	if ( endTicks <= startTicks ) {
		return;
	}

	// work out when sprites are next due to be evaluated
	while ( nextSpriteEval <= startTicks ) {
		nextSpriteEval += MASTER_CYCLES_PER_SCANLINE;
	}
	
	if ( nextSpriteEval > endTicks ) {
		return; // not yet time for the next evaluation period
	}
	
	startline = this.ppu.ticksToScreenCoordinates( nextSpriteEval ).y + 1;
	endline = startline;
	while ( nextSpriteEval <= endTicks ) {
		nextSpriteEval += MASTER_CYCLES_PER_SCANLINE;
		endline++;
	}
	endline = Math.min( endline, 239 );
	
//		Nes.Trace.writeLine( 'ppu', 'sprite sync=' + JSON.stringify( this.ppu.ticksToScreenCoordinates( startTicks ) ) + ' end=' + JSON.stringify( this.ppu.ticksToScreenCoordinates( endTicks ) ) + ' startline=' + startline + ' endline=' + endline );

	// check each sprite to see which fall within the area to check.
	for ( spritenum=0; spritenum < 64; ++spritenum )
	{
		// if ( ( this.ppu.status & 0x20 ) === 0 /*!ppuStatus.spriteOverflow*/ && !this._overflowSet && nextScanlineSpritesCount >= 8 )
		// { // bug in ppu, must emulate for purposes of calculating correct overflow set time
			// var overflowSpriteY = this.ppu.spriteMemory[ spritenum * 4 + readFromY ];
			// readFromY++;
			// if ( readFromY >= 4 )
				// readFromY = 0;

			// //if ( overflowSpriteY >= 0 && overflowSpriteY < SCREEN_HEIGHT ) {
				// // TODO: overflow broken
				// // if ( isRangeOverlapping( startline, endline, overflowSpriteY + 1, overflowSpriteY + spriteHeight + 1 ) ) {
					// // // ( number of ticks since start of frame to the current scanline (-1 because this function predicts the scanline ahead, +1 for pre-render scanline
					// // // and last one of vblank) + ( 64 ppu ticks into scanline when evaluation begins )
					// // // + ( 2 ppu ticks per sprite evaluated ) + ( 6 ppu ticks per sprite found )
					// // var ticksWhenToSetOverflow = ( (scanline + COLOUR_ENCODING_VBLANK_SCANLINES) * PPU_TICKS_PER_SCANLINE * MASTER_CYCLES_PER_PPU );
					// // ticksWhenToSetOverflow += ( 64 * MASTER_CYCLES_PER_PPU );
					// // ticksWhenToSetOverflow += ( spritenum * 2 * MASTER_CYCLES_PER_PPU ) + ( 8 * 6 * MASTER_CYCLES_PER_PPU );
					
					// // this._overflowSet = true;
					// // this.ppu.mainboard.synchroniser.addEvent( 'ppu sprite overflow', ticksWhenToSetOverflow, function( eventTime ) { that.ppu._eventSpriteOverflow( eventTime ); } );
				// // }
			// //}
		// }

		spritey =  this.ppu.spriteMemory[ spritenum * 4 ] + 1;

		if ( spritey > 0 && spritey < SCREEN_HEIGHT ) {
			if ( isRangeOverlapping( startline, endline, spritey, spritey + spriteHeight ) ) {
				//var moreThanEightSprites = nextScanlineSpritesCount >= 8;
				//nextScanlineSpritesCount++;
				this._renderSprite( spriteHeight, spritenum, startline, endline, spritey );
			}
		}
	}
};


Nes.PpuRenderSprites = PpuRenderSprites;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

var ppu = function( mainboard ) {
	var that = this;
	this.mainboard = mainboard;
	this.mainboard.connect( 'reset', function( cold ) { that.reset( cold ); } );
	this.lastTransferredValue = 0;
	this.mirroringMethod = null;
	this.spriteMemory = new Int32Array( 0x100 );
	this._invokeA12Latch = false;
	this._bitOperationOn2002 = false;
	
	this.nameTablesMap = new Int32Array( 4 );
	this.nameTables = [];
	for ( var i=0; i<4; ++i )
		this.nameTables.push( new Int32Array( 0x400 ) );
	
	this.paletteTables = [ new Int32Array( 0x10 ), new Int32Array( 0x10 ) ];
	this.frameCounter = 0;
	this._ppuRenderBg = new Nes.PpuRenderBg( this );
	this._ppuRenderSprites = new Nes.PpuRenderSprites( this );

	this.resetVariables();
};


ppu.prototype.reset = function( cold ) {

	this._useMapperNameTableRead = this.mainboard.cart.memoryMapper.nameTableRead !== undefined;
	this._sync = this.mainboard.synchroniser;
	this.resetVariables( cold );
	this._invokeA12Latch = this.mainboard.cart.memoryMapper.ppuA12Latch !== undefined;
	this._ppuRenderBg.reset();
	this._ppuRenderSprites.reset();
};


ppu.prototype.bitOperationHappening = function() {

	this._bitOperationOn2002 = true;
};


ppu.prototype.resetVariables = function( cold ) {
	if ( cold )
		this.control1 = this.control2 = this.status = 0;
	else
		this.control1 &= 0x7F; // ppuControl1.vBlankNmi = false;
	this.status |= 0x80; // vblank

	this.isOddFrame = false;
	this.suppressNmi = this.suppressVblank = false;
	this.forceNmi = false;

	this.doSpriteTransferAfterNextCpuInstruction = false;
	this.spriteTransferArgument = 0;

	this.fineX = 0;
	this.bufferedppuread = 0;
	this.ppuSecondAddressWrite = false;
	this.ppuReadAddress = 0;
	this.ppuLatchAddress = 0;
	this.spriteaddress = 0;

	this.frameCounter = 0;
};


ppu.prototype.hookSyncEvents = function( synchroniser ) {
	
	var that = this;
	this._clockSkipEventId = synchroniser.addEvent( 'ppu clockskip', this.getMasterTicksTillClockSkip(), function() { that._eventClockskip(); } );
	this._vblankClearEventId = synchroniser.addEvent( 'ppu vblank clear', COLOUR_ENCODING_VBLANK_MTC, function( eventTime ) { that._eventVblankClear( eventTime ); } );
	this._ppuNmiEventId = synchroniser.addEvent( 'ppu NMI', -1, function( eventTime ) { that._eventNmiTrigger( eventTime ); } );
	this._spriteZeroEventId = synchroniser.addEvent( 'ppu sprite zero hit', -1, function( eventTime ) { that._eventSpriteZeroHit( eventTime ); } );
};


ppu.prototype._eventClockskip = function() {
		
	// Skip a PPU clock cycle if the background is enabled
	if ( this.isOddFrame && ( this.control2 & 0x8 ) > 0 /*ppuControl2.backgroundSwitch*/ && COLOUR_ENCODING_NAME === "NTSC" ) {
		this._sync.advanceCpuMTC( MASTER_CYCLES_PER_PPU );
	}
};


ppu.prototype._eventVblankClear = function( eventTime ) {

	// clear vblank flags after vblank period (in this emultor, at the start of the frame)
	// clear bits 5,6,7 in 0x2002
	//console.log( "CLEAR VBLANK: " + eventTime );
	this.status &= 0x1F;
};


ppu.prototype._eventNmiTrigger = function( eventTime ) {

	if ( ( ( this.control1 & 0x80 ) > 0 /* ppuControl1.vBlankNmi*/ && ( this.status & 0x80 ) > 0/* ppuStatus.vBlank*/ ) ) {
		this.mainboard.cpu.nonMaskableInterrupt( eventTime );
	}
	
	this._sync.changeEventTime( this._ppuNmiEventId, -1 );
};


ppu.prototype._eventSpriteZeroHit = function( eventTime ) {
	// var realmtc = this._sync.getCpuMTC();
	// console.log( "[" + this.frameCounter + "] Sprite hit at: " + realmtc + " [" + JSON.stringify( this.ticksToScreenCoordinates( realmtc ) )
		// + " due: " + eventTime + " [" + JSON.stringify( this.ticksToScreenCoordinates( eventTime ) ) + "]" );
	this.status |= 0x40;
	this._sync.changeEventTime( this._spriteZeroEventId, -1 );
};


ppu.prototype._eventSpriteOverflow = function( eventTime ) {
	
	//var realmtc = this._sync.getCpuMTC();
	//console.log( "Sprite overflow at: " + realmtc + " [" + JSON.stringify( this.ticksToScreenCoordinates( realmtc ) )
	//	+ " due: " + eventTime + " [" + JSON.stringify( this.ticksToScreenCoordinates( eventTime ) ) + "]" );
	this.status |= 0x20; /*ppuStatus.spriteOverflow = true;*/
};


ppu.prototype.getMasterTicksTillVBlankClearDue = function( tickCount ) {
	tickCount = tickCount || 0;
	return COLOUR_ENCODING_VBLANK_MTC - tickCount;
};


ppu.prototype.getMasterTicksTillClockSkip = function( tickCount ) {
	tickCount = tickCount || 0;
	return ( COLOUR_ENCODING_VBLANK_MTC + ( MASTER_CYCLES_PER_PPU * ( 328 + 9 ) ) ) - tickCount;
};


// Recycles a static return object to save creating an object per call (sloooow...) be warned using this method, dont call more than once at a time
// else the values will be overwritten
var screenPos = { x:0, y:0 };
ppu.prototype.ticksToScreenCoordinates = function( tickCount ) {
	tickCount = tickCount || this._sync.getCpuMTC();
	tickCount = Math.floor( tickCount / MASTER_CYCLES_PER_PPU ) | 0;
	screenPos.x = tickCount % PPU_TICKS_PER_SCANLINE;
	screenPos.y = ( Math.floor( tickCount / PPU_TICKS_PER_SCANLINE ) - COLOUR_ENCODING_VBLANK_SCANLINES - 1 ) | 0;
	return screenPos;
};


ppu.prototype.screenCoordinatesToTicks = function( x, y ) {
	
	return ( x * MASTER_CYCLES_PER_PPU ) + ( ( y + COLOUR_ENCODING_VBLANK_SCANLINES + 1 ) * MASTER_CYCLES_PER_SCANLINE );
};


ppu.prototype.isRenderingEnabled = function() {
	return ( this.control2 & 0x18 ) > 0;
};

	
ppu.prototype.isRendering = function( tickCount, includeHblank ) {
	if ( this.isRenderingEnabled() )
	{
		var pos = this.ticksToScreenCoordinates( tickCount );
		return ( includeHblank ? IS_INT_BETWEEN( pos.x, 0, 256 ) : true ) && IS_INT_BETWEEN( pos.y, -1, 241 );
	}
	else
		return false;
};


ppu.prototype.updatePPUReadAddress = function( newAddress, invokedFromRegisterWrite ) {
	if ( invokedFromRegisterWrite && this._invokeA12Latch ) {
		if ( ( newAddress & 0x1000 ) > 0 ) {
			this.mainboard.cart.memoryMapper.ppuA12Latch();
		}
	}
	this.ppuReadAddress = newAddress;
};


ppu.prototype.changeMirroringMethod = function( method ) {

	if ( method !== this.mirroringMethod ) {
		this.mirroringMethod = method;
		var name = '';
		switch ( this.mirroringMethod )
		{
			default:
			case PPU_MIRRORING_HORIZONTAL: // mirrors 3 & 4 point to the second nametable
				this.nameTablesMap[0] = 0;
				this.nameTablesMap[1] = 0;
				this.nameTablesMap[2] = 1;
				this.nameTablesMap[3] = 1;
				//name = 'horizontal';
				break;
			case PPU_MIRRORING_VERTICAL: // mirrors 2 & 4 point to the second nametable
				this.nameTablesMap[0] = 0;
				this.nameTablesMap[1] = 1;
				this.nameTablesMap[2] = 0;
				this.nameTablesMap[3] = 1;
				//name = 'vertical';
				break;
			case PPU_MIRRORING_FOURSCREEN: // no mirroring done, requires an extra 0x800 of memory kept on cart
				for ( var i=0; i<4; ++i )
					this.nameTablesMap[i] = i;
				//name = 'four screen';
				break;
			case PPU_MIRRORING_SINGLESCREEN_NT0:
				for ( var j=0; j<4; ++j )
					this.nameTablesMap[j] = 0;
				//name = 'single 0';
				break;
			case PPU_MIRRORING_SINGLESCREEN_NT1:
				for ( var k=0; k<4; ++k )
					this.nameTablesMap[k] = 1;
				//name = 'single 1';
				break;
		}
		//console.log( 'PPU nametable mirroring set to ' + name );
	}
};


ppu.prototype.getMirroringMethod = function() {
	return this.mirroringMethod;
};


ppu.prototype.handleSpriteTransfer = function() {
	/*
	SPR DMA should take 513 cycles if it starts on an even cycle, 514 if it starts on an odd cycle.

	Remember that SPR DMA only takes place when the instruction has finished executing, and not at the write cycle of the instruction! You can check this behavior by using a RMW instruction with $4014, it will only do one sprite dma at the end of the instruction.

	I m able to pass irq and dma, as well as both spr and dma tests using this implementation.
	*/
	var baseReadAddress = this.spriteTransferArgument * 0x100;
	if ( this.doSpriteTransferAfterNextCpuInstruction) {
		this.doSpriteTransferAfterNextCpuInstruction = false;
		this._sync.synchronise();
		// TODO: Optimise 
		this._sync.advanceCpuMTC( 1 * COLOUR_ENCODING_MTC_PER_CPU );
		this.spriteaddress &= 0xFF
		for ( var i=0; i<0x100; ++i )
		{
			var dmaData = this.mainboard.memory.read8( baseReadAddress + i );
			this._sync.advanceCpuMTC( 1 * COLOUR_ENCODING_MTC_PER_CPU );
			 this.spriteMemory[ this.spriteaddress] =  dmaData ;
			this.spriteaddress = (this.spriteaddress + 1 ) & 0xFF;
			//this.lastTransferredValue = dmaData;
			this._sync.advanceCpuMTC( 1 * COLOUR_ENCODING_MTC_PER_CPU );
		}
		// add extra cycle on odd frame
		if ( this.isOddFrame )
			this._sync.advanceCpuMTC( 1 * COLOUR_ENCODING_MTC_PER_CPU );
	}
};


ppu.prototype._writeTo2000 = function( offset, data ) {
	var cpuMtc = this._sync.getCpuMTC();
	var vblankSetTime = COLOUR_ENCODING_FRAME_MTC;
	var ticksTillSet = vblankSetTime - cpuMtc;

	if ( ( data & 0x80 ) === 0 ) { // vblank nmi cleared
		// special case code for disabling NMI when disabled near vblank set
		// NMI should occur when disabled 2, 3 or 4 PPU clocks after VBL set
		if ( ticksTillSet <= -MASTER_CYCLES_PER_PPU * 2 && ticksTillSet >= -MASTER_CYCLES_PER_PPU * 4 ) {
			this.forceNmi = true;
		} else if ( ticksTillSet >= -MASTER_CYCLES_PER_PPU * 1 && ticksTillSet <= MASTER_CYCLES_PER_PPU * 1 ) {
			this.suppressNmi = true;
		}
	} else {
		// NMI should occur if enabled when VBL already set		
		// vblank = true && vblanknmi = false 
		if ( ( this.status & 0x80 ) > 0 && ( this.control1 & 0x80 ) === 0 ) { // there be a 1-PPU clock latency for this
			var triggerTime = this._sync.getCpuMTC() + MASTER_CYCLES_PER_PPU * 1;
			//console.log( "NMI trigger due: " + triggerTime );
			this._sync.changeEventTime( this._ppuNmiEventId, triggerTime );
		}
	}

	this._sync.synchronise();
	
	// update nametable switch
	this.ppuLatchAddress &= 0xF3FF;
	this.ppuLatchAddress |= ((data & 3) << 10);

	var spriteScreenAddressChanged = ( this.control1 & 0x18 ) !== ( data & 0x18 );
	//var spriteSizeOrSpriteAddressChanged = ( this.control1 & 0x28 ) !== ( data & 0x28 );
	var spriteSizeChanged = ( this.control1 & 0x20 ) !== ( data & 0x20 );

	this.control1 = data;

	if ( spriteScreenAddressChanged ) {
		this.mainboard.cart.memoryMapper.spriteScreenEnabledUpdate( ( this.control1 & 0x8 ) > 0, ( this.control1 & 0x10 ) > 0 );
		this._ppuRenderBg.onControl1Change( this.control1 );
	}
	if ( spriteSizeChanged && this.mainboard.cart.memoryMapper.spriteSizeChanged ) { // used by MMC5
		this.mainboard.cart.memoryMapper.spriteSizeChanged( ( this.control1 & 0x20 ) > 0 );
	}
};


ppu.prototype._writeTo2001 = function( offset, data ) {
	this._sync.synchronise();
	var renderingEnabledChanged = ( ( this.control2 & 0x18 ) > 0 ) !== ( ( data & 0x18 ) > 0 );
	//var spriteVisibleOrClippingChanged = ( ( this.control2 & 0x14 ) > 0 ) !== ( ( data & 0x14 ) > 0 );
	
	this.control2 = data;

	if ( renderingEnabledChanged )
		this.mainboard.cart.memoryMapper.renderingEnabledChanged( ( this.control2 & 0x18 ) > 0 );
};


ppu.prototype._writeTo2005 = function( offset, data ) {
	this._sync.synchronise();

/*
I don't know anything about this game in particular, but bear in mind when examining
$2005 writes that changes to bits 0-2 take effect immediately, while changes to bits 3-7
(as well as bit 0 of $2000) don't have any effect until the start of the next H-Blank
(cycle 257 to be specific).
Thus, if $2005 were written in the middle of H-Blank, bits 0-2 will affect the next scanline,
but bits 3-7 won't take effect until the scanline afterwards.
Emulators that don't use cycle-accurate PPU rendering will not correctly handle this condition.
*/

	// bottom 3 bits are "fine" scroll value, top 5 are tile number
	// first write is horizontal value, second is vertical
	if ( !this.ppuSecondAddressWrite )
	{
		this.ppuLatchAddress &= 0xFFE0;
		this.ppuLatchAddress |= ((data & 0xF8) >> 3);
		this.fineX = (data & 0x07)|0;
		//var pos = this.ticksToScreenCoordinates();
		//console.log( "changed fineX at " + pos.x + "x" + pos.y + "=" + this.fineX );
	}
	else
	{
		this.ppuLatchAddress &= 0xFC1F;
		this.ppuLatchAddress |= ((data & 0xF8) << 2);
		this.ppuLatchAddress &= 0x8FFF;
		this.ppuLatchAddress |= ((data & 0x07) << 12);
	}

	this.ppuSecondAddressWrite = !this.ppuSecondAddressWrite;
	
	//Nes.Trace.writeLine( 'ppu', '2005 write: ' + data.toString( 16 ) );
};


ppu.prototype._writeTo2006 = function( offset, data ) {
	// first write is upper byte of address, second is lower
	this._sync.synchronise();

	if ( !this.ppuSecondAddressWrite )
	{
		this.control1 &= 0xFC; // TODO: is this correct?
		this.control1 |= (data & 0x0C) >> 2; // nametable
		this.ppuLatchAddress &= 0x00FF;
		this.ppuLatchAddress |= ((data & 0x3F) << 8);
	}
	else
	{
		this.ppuLatchAddress &= 0xFF00;
		this.ppuLatchAddress |= data;
		
		this.updatePPUReadAddress( this.ppuLatchAddress, true );
	}

	this.ppuSecondAddressWrite = !this.ppuSecondAddressWrite;

	//Nes.Trace.writeLine( 'ppu', '2006 write: ' + data.toString( 16 ) );
};


ppu.prototype._writeTo2007 = function( offset, data ) {
	/*
	$2007 reads and writes:
	Outside of rendering, reads from or writes to $2007 will add either 1 or 32 to v depending on the VRAM increment bit set via $2000.
	During rendering (on the pre-render line and the visible lines 0-239, provided either background or sprite rendering is enabled),
	it will update v in an odd way, triggering a coarse X increment and a Y increment simultaneously (with normal wrapping behaviour).
	Internally, this is caused by the carry inputs to various sections of v being set up for rendering, and the $2007 access triggering a
	"load next value" signal for all of v (when not rendering, the carry inputs are set up to linearly increment v by either 1 or 32).
	This behaviour is not affected by the status of the increment bit. The Young Indiana Jones Chronicles uses this for some effects to adjust
	the Y scroll during rendering. If the $2007 access happens to coincide with a standard VRAM address increment (either horizontal or vertical),
	it will presumably not double-increment the relevant counter.
	*/
	this._sync.synchronise();
	
	var bufferedAddress = 0;
	var newAddress = 0;

	if ( !this.isRendering( this._sync.getCpuMTC(), false ) ) {
		bufferedAddress = this.ppuReadAddress;

		// increment PPU address as according to bit 2 of 0x2000
		newAddress = this.ppuReadAddress + ( ( this.control1 & 0x04 ) > 0 ? 32 : 1 ); // verticalwrite flag
		this.updatePPUReadAddress( newAddress, true );
		this.write8( bufferedAddress /*& 0x3FFF*/, data );
	} else {
		// TODO: disallow if due to occur this tick anyway
	//	this.background_IncrementXTile();
	//	this.background_IncrementYTile();
	}

	if ( this.mainboard.cart.memoryMapper.MMC2Latch ) {
		this.mainboard.cart.memoryMapper.MMC2Latch( this.ppuReadAddress );
	}
	
	//Nes.Trace.writeLine( 'ppu', '2007 write: ' + data.toString( 16 ) );
};


ppu.prototype.writeToRegister = function( offset, data ) {

	this.lastTransferredValue = data;

	switch ( offset )
	{
	case 0:
		this._writeTo2000( offset, data );
		break;
	case 0x01:
		this._writeTo2001( offset, data );
		break;
	case 0x03: // sprite memory address, no need to synchronise
		this.spriteaddress = data & 0xFF;
		break;
	case 0x04: // sprite memory data
		this._sync.synchronise();
		 this.spriteMemory[ this.spriteaddress & 0xFF] =  data ;
		this.spriteaddress = ( this.spriteaddress + 1 ) & 0xFF;
		break;
	case 0x05: // PPU scrolling
		this._writeTo2005( offset, data );
		break;
	case 0x06: // PPU memory address
		this._writeTo2006( offset, data );
		break;
	case 0x07: // PPU memory data
		this._writeTo2007( offset, data );
		break;
	}
};


ppu.prototype.writeToSpriteDMARegister = function( data ) {
	this.doSpriteTransferAfterNextCpuInstruction = true;
	this.spriteTransferArgument = data;
};


ppu.prototype._readFromRegister2002 = function() {
	var cpuMtc = this._sync.getCpuMTC();
	var vblankSetTime = COLOUR_ENCODING_FRAME_MTC;
	var ticksTillSet = vblankSetTime - cpuMtc;
	var suppress = false;

	// check that vblank flag isn't tried to be set 1 PPU clock before VBlank is due
	if ( ticksTillSet === MASTER_CYCLES_PER_PPU )
	{
		this.suppressVblank = true;
		this.suppressNmi = true;
		suppress = true;
	}
	// Suppress NMI on the tick VBlank is read and the one after
	else if ( ticksTillSet <= 0 && ticksTillSet >= -MASTER_CYCLES_PER_PPU * 1 )
	{
		this.suppressNmi = true;
	}

	// If we are performing a BIT on 2002, then we can optimise by not needing
	// to synchronise (as it is only looking at the vblank flag, and we always know
	// when that is due to happen)
	//if ( !this._bitOperationOn2002 ) {
	//Nes.Trace.writeLine( 'ppu', '2002 read sync - pre: ' + cpuMtc );
		this._sync.synchronise();
	//Nes.Trace.writeLine( 'ppu', '2002 read sync - post ' + cpuMtc );
	// } else {
		// if ( ticksTillSet < MASTER_CYCLES_PER_PPU * 5 ) { // if it's about to clear, synchronise
			// this._sync.synchronise();
		// }
		// this._bitOperationOn2002 = false;
	// }
	
	var ret = this.status;
	//console.log( "0x2002 read : " + Number( ret ) + " status: " + Number( this.status ) );
	this.ppuSecondAddressWrite = false; // reset latch on read to 0x2002

	// wipe vblank flag from status reg
	if ( suppress )
		ret &= 0x7F;
	else
		this.status &= 0x7F;
	return ret;
};


ppu.prototype._readFromRegister2007 = function() {
	var ret = 0;
	// dont buffer reads from palette space
	var bufferedaddress = this.ppuReadAddress;
	var newAddress = 0;

	if ( !this.isRendering( this._sync.getCpuMTC(), true ) )
	{
		newAddress = ( this.ppuReadAddress + ( ( this.control1 & 0x4 ) > 0 /*ppuControl1.verticalWrite*/ ? 32 : 1) ) & 0xFFFF;
		this.updatePPUReadAddress( newAddress, true );

		if ( ( bufferedaddress & 0xFF00 ) === 0x3F00 ) //IS_INT_BETWEEN( bufferedaddress, 0x3F00, 0x4000 ) )
		{
			ret = this.read8( bufferedaddress, false, 0 );
			this.bufferedppuread = this.read8( bufferedaddress - 0x1000, false, 0 );
		}
		else
		{
			ret = this.bufferedppuread;
			this.bufferedppuread = this.read8( bufferedaddress, false, 0 );
		}
	}
	else
	{
		ret = this.bufferedppuread;
		this.bufferedppuread = 0;
	}
	return ret;
};


ppu.prototype.readFromRegister = function( offset ) {
	var ret = 0;

	switch ( offset ) // offset is 0x2000 -> 0x2008
	{
	case 0x2:
		ret = this._readFromRegister2002();
	break;

	case 0x4: // sprite memory data
		ret =  this.spriteMemory[ this.spriteaddress & 0xFF ] | 0;
	break;

	case 0x7: // PPU memory data
		ret = this._readFromRegister2007();
	break;

	//case 0x2005:
	//	Log::Write( LOG_ERROR, "Read from PPU register 0x2005 - Emulation may be inaccurate and problematic" );
	//	ret = mLastTransferredValue;
	//	throw std::runtime_error( "Read to 0x2005" );
	//case 0x2006:
	//	Log::Write( LOG_ERROR, "Read from PPU register 0x2006 - Emulation may be inaccurate and problematic" );
	//	ret = mLastTransferredValue;
	//	throw std::runtime_error( "Read to 0x2006" );
	default:
		ret = this.lastTransferredValue;
		break;
	}

	this.lastTransferredValue = ret;
	return ret;
};


ppu.prototype.write8 = function( offset, data ) {

	if ( ( offset & 0x2000 ) === 0 ) { // IS_INT_BETWEEN( offset, 0, 0x2000 )
		this.mainboard.cart.memoryMapper.write8ChrRom( offset & 0x1FFF, data );
	} else { // IS_INT_BETWEEN( offset, 0x2000, 0x4000 )
		if ( ( offset & 0x3F00 ) === 0x3F00 ) { // IS_INT_BETWEEN( offset, 0x3F00, 0x4000 )
			// image and sprite palettes (both mirror each other)
			var paletteOffset = offset & 0xF;
			var targetPalette = ( offset & 0x10 ) >> 4; // whether its a sprite or background palette
			var newColour = data & 0x3F;

			 this.paletteTables[ targetPalette ][ paletteOffset] =  newColour ;
			if ( ( paletteOffset & 0x3 ) === 0 ) {
				var otherPalette = targetPalette === 1 ? 0 : 1;
				 this.paletteTables[ otherPalette ][ paletteOffset] =  newColour ;
			}
		} else { // IS_INT_BETWEEN( offset, 0x2000, 0x3F00 )
			// name tables
			var pageid = ( offset & 0xC00 ) >> 10;
			if ( this.mainboard.cart.memoryMapper.nameTableWrite ) {
				this.mainboard.cart.memoryMapper.nameTableWrite( this.nameTables, pageid, offset & 0x3FF, data );
			} else {
				var pagepos =  this.nameTablesMap[ pageid ];
				 this.nameTables[ pagepos ][ offset & 0x3FF] =  data ;
			}
		}
	}
};


ppu.prototype.read8 = function( offset, renderingSprites, readType ) {

	var pageid = 0;
	var pagepos = 0;
	var paletteOffset = 0;
	var targetPalette = 0;
	
	if ( ( offset & 0x2000 ) === 0 ) { // IS_INT_BETWEEN( offset, 0, 0x2000 )
		// pattern tables
		return this.mainboard.cart.memoryMapper.read8ChrRom( offset & 0x1FFF, renderingSprites, readType ) | 0;
	} else {
		if ( ( offset & 0x3F00 ) === 0x3F00 ) { // IS_INT_BETWEEN( offset, 0x3F00, 0x4000 )
			// palettes
			paletteOffset = offset & 0xF;
			targetPalette = ( offset & 0x10 ) >> 4;
			return  this.paletteTables[ targetPalette ][ paletteOffset ] | 0;
		} else { // IS_INT_BETWEEN( offset, 0x2000, 0x3F00 )
			// name tables
			pageid = ( offset & 0xC00 ) >> 10;
			if ( this._useMapperNameTableRead ) {
				return this.mainboard.cart.memoryMapper.nameTableRead( this.nameTables, pageid, offset & 0x3FF ) | 0;
			} else {
				pagepos =  this.nameTablesMap[ pageid ];
				return  this.nameTables[ pagepos ][ offset & 0x3FF ] | 0;
			}
		}
	}
};


ppu.prototype.synchronise = function( startTicks, endTicks ) {

	if ( this.isRenderingEnabled() ) {
		this._ppuRenderSprites.renderTo( startTicks, endTicks );
		this.ppuReadAddress = this._ppuRenderBg.renderTo( startTicks, endTicks, this.ppuReadAddress, this.ppuLatchAddress );
	}
};


ppu.prototype.onEndFrame = function() {
	
	// start vblank period
	if ( !this.suppressVblank )
	{
		this.status |= 0x80; // set vblank
	}

	if ( this.forceNmi || (!this.suppressNmi && ( this.control1 & 0x80 ) > 0 ) )
	{
		this.mainboard.cpu.nonMaskableInterrupt( COLOUR_ENCODING_FRAME_MTC + MASTER_CYCLES_PER_PPU );
	}

	this.suppressNmi = false;
	this.suppressVblank = false;
	this.forceNmi = false;
	this.isOddFrame = !this.isOddFrame;
	this.frameCounter++;
	this._ppuRenderBg.onEndFrame();
	this._ppuRenderSprites.onEndFrame();
	
	if ( Nes.Trace.enabled() ) {
	}
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ppu.prototype.getBackgroundPaletteIndex = function() {
	return this.paletteTables[ 0 ][ 0 ] | 0;
};


ppu.prototype.readNameTable = function( address, readType ) {
	var pageid = (address >> 10) & 3;
	if ( this._useMapperNameTableRead ) {
		return this.mainboard.cart.memoryMapper.nameTableRead( this.nameTables, pageid, address & 0x3FF, readType ) | 0;
	} else {
		var pagepos =  this.nameTablesMap[ pageid ];
		return  this.nameTables[ pagepos ][ address & 0x3FF] | 0;
	}
};


ppu.prototype.formatStatusString = function() {

	var pos = this.ticksToScreenCoordinates();
	var str = "";
	str += "CYC:" + ZERO_PAD( pos.x, 3, ' ' ) + " SL:" + pos.y + " F:" + this.frameCounter;
	str += " S:" + ZERO_PAD_HEX( this.status, 2 ) + " C1:" + ZERO_PAD_HEX( this.control1, 2 ) + " C2:" + ZERO_PAD_HEX( this.control2, 2 );
	return str;
};


ppu.prototype.saveState = function() {
	
	var data = {};
	data.mirroringMethod = this.mirroringMethod;
	data.isOddFrame = this.isOddFrame;
	data.suppressNmi = this.suppressNmi;
	data.suppressVblank = this.suppressVblank;
	data.forceNmi = this.forceNmi;
	
	data.control1 = this.control1;
	data.control2 = this.control2;
	data.status = this.status;
	
	data.bufferedppuread = this.bufferedppuread;
	data.ppuReadAddress = this.ppuReadAddress;
	data.ppuLatchAddress = this.ppuLatchAddress;
	
	data.spriteaddress = this.spriteaddress;
	data.ppuSecondAddressWrite = this.ppuSecondAddressWrite;
	
	data.fineX = this.fineX;

	data.lastTransferredValue = this.lastTransferredValue;
	data.frameCounter = this.frameCounter;
	data._invokeA12Latch = this._invokeA12Latch;

	data.doSpriteTransferAfterNextCpuInstruction = this.doSpriteTransferAfterNextCpuInstruction;
	data.spriteTransferArgument = this.spriteTransferArgument;
	
	data.spriteMemory = Nes.uintArrayToString( this.spriteMemory );
	data.nameTables = [];
	for ( var i=0; i<this.nameTables.length; ++i ) {
		data.nameTables.push( Nes.uintArrayToString( this.nameTables[i] ) );
	}
	data.paletteTables = [];
	for ( var i=0; i<this.paletteTables.length; ++i ) {
		data.paletteTables.push( Nes.uintArrayToString( this.paletteTables[i] ) );
	}
	data.nameTablesMap = Nes.uintArrayToString( this.nameTablesMap );
	
	this._ppuRenderBg.saveState( data );
	this._ppuRenderSprites.saveState( data );
	return data;
};


ppu.prototype.loadState = function( state ) {
	this.mirroringMethod = state.mirroringMethod;
	this.isOddFrame = state.isOddFrame;
	this.suppressNmi = state.suppressNmi;
	this.suppressVblank = state.suppressVblank;
	this.forceNmi = state.forceNmi;
	
	this.control1 = state.control1;
	this.control2 = state.control2;
	this.status = state.status;
	
	this.bufferedppuread = state.bufferedppuread;
	this.ppuReadAddress = state.ppuReadAddress;
	this.ppuLatchAddress = state.ppuLatchAddress;
	
	this.spriteaddress = state.spriteaddress;
	this.ppuSecondAddressWrite = state.ppuSecondAddressWrite;
	
	this.fineX = state.fineX;

	this.lastTransferredValue = state.lastTransferredValue;
	this.frameCounter = state.frameCounter;
	
	this.doSpriteTransferAfterNextCpuInstruction = state.doSpriteTransferAfterNextCpuInstruction;
	this.spriteTransferArgument = state.spriteTransferArgument;
	this._invokeA12Latch = state._invokeA12Latch;
	
	this.spriteMemory = Nes.stringToUintArray( state.spriteMemory );
	this.nameTables = [];
	for ( var i=0; i<state.nameTables.length; ++i ) {
		this.nameTables.push( Nes.stringToUintArray( state.nameTables[i] ) );
	}
	this.paletteTables = [];
	for ( var i=0; i<state.paletteTables.length; ++i ) {
		this.paletteTables.push( Nes.stringToUintArray( state.paletteTables[i] ) );
	}
	this.nameTablesMap = Nes.stringToUintArray( state.nameTablesMap );
	
	this._ppuRenderBg.loadState( state );
	this._ppuRenderSprites.loadState( state );
};



Nes.ppu = ppu;

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

/* Estimated number of games with mapper (other mappers had <10 games)
Mapper 004: 569
Mapper 001: 481
Mapper 000: 260
Mapper 002: 200
Mapper 003: 145
Mapper 007: 56
Mapper 011: 35
Mapper 019: 32
Mapper 016: 26
Mapper 099: 25
Mapper 005: 24
Mapper 018: 16
Mapper 066: 16
Mapper 033: 15
Mapper 079: 15
Mapper 045: 14
Mapper 071: 14
Mapper 113: 12
Mapper 245: 11
Mapper 023: 11
Mapper 069: 11 
*/

Nes.mappers = {};
	
"use strict";


var basemapper = function() {
};


basemapper.prototype.construct = function( mainboard, mirroringMethod ) {

	this.mainboard = mainboard;
	this.mirroringMethod = mirroringMethod;
	this.prgPagesMap = new Int32Array( 4 );
	this._prgData = null;
	this._prgPageCount = 0;
	
	this.chrPages = [];
	this.chrPagesMap = new Int32Array( 8 );
	this._chrData = null;
	this._chrPageCount = 0;
	this._usingChrVram = false;
	
	this._gameGenieActive = false;
	this._gameGeniePokes = {};
	
	this.sram = new Int32Array( 0x2000 );
	this.expansionRam = new Int32Array( 0x1FE0 );
};


basemapper.prototype.onEndFrame = function() {
};


basemapper.prototype.getNextEvent = function() {
	return -1;
};


basemapper.prototype.synchronise = function( startTicks, endTicks ) {
};

// MMC3 specific functions
basemapper.prototype.spriteScreenEnabledUpdate = function( spriteEnabled, screenEnabled ) { };
basemapper.prototype.renderingEnabledChanged = function( enabled ) { };


basemapper.prototype.setPrgData = function( array, prg8kPageCount ) {

	this._prgData = array;
	this._prgPageCount = prg8kPageCount;
};


basemapper.prototype.setChrData = function( array, chr1kPageCount ) {

	this._chrData = array;
	this._chrPageCount = chr1kPageCount;
};


////// PRG switching


basemapper.prototype.get1kChrBankCount = function() {
	return this._chrPageCount;
};


basemapper.prototype.get2kChrBankCount = function() {
	return this._chrPageCount >> 1; // Math.floor( this.chrPages.length / 2 );
};


basemapper.prototype.get4kChrBankCount = function() {
	return this._chrPageCount >> 2; // Math.floor( this.chrPages.length / 4 );
};


basemapper.prototype.get8kChrBankCount = function() {
	return this._chrPageCount >> 3; // Math.floor( this.chrPages.length / 8 );
};


basemapper.prototype.get8kPrgBankCount = function() {
	return this._prgPageCount;
};


basemapper.prototype.get16kPrgBankCount = function() {
	return this._prgPageCount >> 1; // Math.floor( this.prgPages.length / 2 );
};


basemapper.prototype.get32kPrgBankCount = function() {
	return this._prgPageCount >> 2; // Math.floor( this.prgPages.length / 4 );
};


basemapper.prototype.switch8kPrgBank = function( id, pos ) {
	//Nes.Trace.writeLine( 'mapper', 'switch8kPrgBank:' + id );
	this.setPrgPage( id % this._prgPageCount, pos );
};


basemapper.prototype.switch16kPrgBank = function( id, low ) {
	if ( this.get16kPrgBankCount() > 0 )
	{
		//Nes.Trace.writeLine( 'mapper', 'switch16kPrgBank:' + id );
		var aid = ( id * 2 ) % this._prgPageCount;
		for ( var i=0; i<2; ++i )
			this.setPrgPage( aid + i, i + (low ? 0 : 2) );
	}
};


basemapper.prototype.switch32kPrgBank = function( id ) {
	if ( this.get32kPrgBankCount() > 0 )
	{
		//Nes.Trace.writeLine( 'mapper', 'switch32kPrgBank:' + id );
		var aid = ( id * 4 ) % this._prgPageCount;
		for ( var i=0; i<4; ++i )
			this.setPrgPage( aid + i, i );
	}
};


basemapper.prototype.setPrgPage = function( id, pos ) {
	if (  this.prgPagesMap[ pos ] !== id ) {
		 this.prgPagesMap[ pos] =  id * 0x2000 ;
	}
};


basemapper.prototype.setChrPage = function( id, pos ) {
	 this.chrPagesMap[ pos] =  id * 0x400 ;
};


basemapper.prototype.switch1kChrBank = function( id, pos ) {
	this.setChrPage( id % this._chrPageCount, pos );
};


basemapper.prototype.switch2kChrBank = function( id, pos ) {
	if ( this.get2kChrBankCount() > 0 )
	{
		var aid = ( id * 2 ) % this._chrPageCount;
		for ( var i=0; i<2; ++i )
			this.setChrPage( aid + i, ( pos * 2 ) + i );
	}
};


basemapper.prototype.switch4kChrBank = function( id, low ) {
	if ( this.get4kChrBankCount() > 0 )
	{
		var aid = ( id * 4 ) % this._chrPageCount;
		for ( var i=0; i<4; ++i )
			this.setChrPage( aid + i, i + (low ? 0 : 4) );
	}
};


basemapper.prototype.switch8kChrBank = function( id ) {
	if ( this.get8kChrBankCount() > 0 )
	{
		var aid = ( id * 8 ) % this._chrPageCount;
		for ( var i=0; i<8; ++i )
			this.setChrPage( aid + i, i );
	}
};


basemapper.prototype.useVRAM = function( numBanks ) {
	
	numBanks = numBanks || 8;
	this._usingChrVram = true;
	this._chrData = new Int32Array( 0x400 * numBanks );

	this._chrPageCount = numBanks;
	for ( var i=0; i< Math.min( 8, numBanks ); ++i ) {
		this.setChrPage( i, i );
	}
};


// 0x8000 -> 0xFFFF
basemapper.prototype.write8PrgRom = function( offset, data ) {
};


basemapper.prototype.read8PrgRom = function( offset ) {
	
	var pageid = ( offset & 0x6000 ) >> 13; // Math.floor( ( prgOffset ) / 0x2000 );
	var pagepos =  this.prgPagesMap[ pageid ];
	var aid = offset & 0x1FFF;
	var readValue =  this._prgData[ pagepos + aid ];

	if ( this._gameGenieActive ) {
		if ( this._gameGeniePokes.hasOwnProperty( offset ) ) {
			return this._checkGameGenieCode( readValue, offset );
		}
	}
	return readValue;
};


basemapper.prototype._checkGameGenieCode = function( readValue, offset ) {	
	// Game genie override
	var gg = this._gameGeniePokes[ offset ];
	if ( gg.compare === -1 || gg.compare === readValue ) {
		return gg.value;
	}
	return readValue | 0;
};


// VRAM 0x0000 -> 0x2000
basemapper.prototype.write8ChrRom = function( offset, data ) {
	if ( this._usingChrVram ) {
		var pageid = ( offset & 0x1C00 ) >> 10; // Math.floor( offset / 0x400 );
		var pagepos =  this.chrPagesMap[ pageid ];
		var writeOffset = pagepos + ( offset & 0x3FF );
		 this._chrData[ writeOffset] =  data ;
	}
};


basemapper.prototype.read8ChrRom = function( offset, renderingSprites, readType ) {
	var pageid = ( offset & 0x1C00 ) >> 10; // Math.floor( offset / 0x400 );
	var pagepos =  this.chrPagesMap[ pageid ];
	var readOffset = pagepos + ( offset & 0x3FF );
	return  this._chrData[ readOffset ] | 0;
};


basemapper.prototype.write8SRam = function( offset, data ) {
	 this.sram[ offset & 0x1FFF] =  data ;
};


basemapper.prototype.read8SRam = function( offset ) {
	return  this.sram[ offset & 0x1FFF ] | 0;
};


basemapper.prototype.write8EXRam = function( offset, data ) {
	 this.expansionRam[ offset - 0x4020] =  data ;
};


basemapper.prototype.read8EXRam = function( offset ) {
	return  this.expansionRam[ offset - 0x4020 ] | 0;
};


basemapper.prototype.reset = function() {
};


// Called from gameGenie.js - modified the PRG at given value
basemapper.prototype.gameGeniePoke = function( codeName, address, value, compareValue ) {

	this._gameGenieActive = true;
	this._gameGeniePokes[ address ] = { name: codeName, value: value, compare: compareValue };
};

basemapper.prototype.removeGameGeniePoke = function( codeName ) {
	
	var keyArray = Object.keys( this._gameGeniePokes );
	for ( var i=0; i<keyArray.length; ++i ) {
		var prop = keyArray[i];
		if ( this._gameGeniePokes.hasOwnProperty( prop ) ) {
			var gg = this._gameGeniePokes[ prop ];
			if ( gg && gg.name === codeName ) {
				delete this._gameGeniePokes[ prop ];
			}
		}
	}
	
	var codesActive = Object.keys( this._gameGeniePokes ).length;
	this._gameGenieActive = codesActive > 0;
};


basemapper.prototype.saveState = function() {

	var data = {};
	
	data.mirroringMethod = this.mirroringMethod;
	data._usingChrVram = this._usingChrVram;
	//data.prgPagesMap = $.extend( {}, this.prgPagesMap );
	//data.chrPagesMap = $.extend( {}, this.chrPagesMap ); // TODO: restore
	data.sram = Nes.uintArrayToString( this.sram );
	data.expansionRam = Nes.uintArrayToString( this.expansionRam );
	data._gameGeniePokes = $.extend( {}, this._gameGeniePokes );
	if ( this._usingChrVram ) {
		//data.chrPages = this.chrPages.map( function( page ) { return Nes.uintArrayToString( page ); } );
		data._chrData = Nes.uintArrayToString( this._chrData );
	}
	if ( this.mapperSaveState ) {
		this.mapperSaveState( data );
	}
	return data;
};


basemapper.prototype.loadState = function( state ) {

	this.mirroringMethod = state.mirroringMethod;
	this._usingChrVram = state._usingChrVram;
	//this.prgPagesMap = $.extend( {}, state.prgPagesMap );
	// this.chrPagesMap = $.extend( {}, state.chrPagesMap ); // TODO: restore
	this.sram = Nes.stringToUintArray( state.sram );
	this.expansionRam = Nes.stringToUintArray( state.expansionRam );
	this._gameGeniePokes = $.extend( {}, state._gameGeniePokes );
	if ( this._usingChrVram ) {
		this._chrData = Nes.stringToUintArray( state._chrData );
	}
	if ( this.mapperLoadState ) {
		this.mapperLoadState( state );
	}
};


Nes.basemapper = basemapper;


Nes.createMapper = function( mapperId, mainboard, mirroringMethod ) {

	var mapperClass = Nes.mappers[ mapperId ];
	if ( mapperClass === undefined ) {
		throw new Error( 'Mapper id ' + mapperId + ' is not supported' );
	}
	var mapper = new mapperClass();
	mapper.construct( mainboard, mirroringMethod );
	return mapper;
};


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper0 = function() {
};

mapper0.prototype = Object.create( Nes.basemapper.prototype );

mapper0.prototype.reset = function() {

	if ( this.get32kPrgBankCount() >= 1 )
	{
		this.switch32kPrgBank( 0 );
	}
	else if ( this.get16kPrgBankCount() == 1 )
	{
		this.switch16kPrgBank( 0, true );
		this.switch16kPrgBank( 0, false );
	}

	if ( this.get1kChrBankCount() === 0 )
	{
		this.useVRAM();
	}
	else
	{
		this.switch8kChrBank( 0 );
	}

	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

Nes.mappers[0] = mapper0;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper1 = function() {
	this.val = 0;
	this.count = 0;
	this.lastWriteMTC = -1;

	this.registers = new Int32Array( 4 ); // size 4
	this.registers[0] = 0x0C;
	this.registers[1] = this.registers[2] = this.registers[3] = 0;
	
	this.wRamEnabled = true;
	this.soromlatch = false;
};

mapper1.prototype = Object.create( Nes.basemapper.prototype );

mapper1.prototype.mapperSaveState = function( state ) {
	state.val = this.val;
	state.count = this.count;
	state.lastWriteMTC = this.lastWriteMTC;
	state.registers = Nes.uintArrayToString( this.registers );
	state.wRamEnabled = this.wRamEnabled;
	state.soromlatch = this.soromlatch;
};

mapper1.prototype.mapperLoadState = function( state ) {
	this.val = state.val;
	this.count = state.count;
	this.lastWriteMTC = state.lastWriteMTC;
	this.registers = Nes.stringToUintArray( state.registers );
	this.wRamEnabled = state.wRamEnabled;
	this.soromlatch = state.soromlatch;
};

mapper1.prototype.onEndFrame = function() {

	this.lastWriteMTC = -1;
};

mapper1.prototype.reset = function() {

	this.switch16kPrgBank( 0, true );
	this.switch16kPrgBank( this.get16kPrgBankCount() - 1, false );

	if ( this.get8kChrBankCount() === 0 )
	{
		this.useVRAM();
	}
	else
	{
		this.switch8kChrBank( 0 );
	}

	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper1.prototype.syncChrMirrors = function() {
	if ( ( this.registers[0] & 0x10 ) > 0 )
	{
		this.switch4kChrBank( this.registers[1] & 0x1F, true );
		this.switch4kChrBank( this.registers[2] & 0x1F, false );
	}
	else
	{
		this.switch8kChrBank( ( (this.registers[1] & 0x1F) >> 1 ) );
	}
};

mapper1.prototype.syncPrgMirrors = function() {
	var offset = this.soromlatch ? 16 : 0; //if more than 256k ROM AND SOROM latch is on
	var reg = this.registers[3];
	if ( ( this.registers[0] & 0x8 ) > 0 ) { // 16k / 32k prg switch
		if ( ( this.registers[0] & 0x4 ) > 0 ) { // high/low prg switch
			var last = Math.min( this.get16kPrgBankCount() - 1, 15 ); // this.get16kPrgBankCount() - 1;
			this.switch16kPrgBank( reg + offset, true );
			this.switch16kPrgBank( last + offset, false );
		} else {
			this.switch16kPrgBank( 0 + offset, true );
			this.switch16kPrgBank( reg + offset, false );
		}
	} else {
		this.switch32kPrgBank( ( reg >> 1 ) + ( this.soromlatch ? 8 : 0 ) );
	}
};

mapper1.prototype.write8PrgRom = function( offset, data ) {

	// To get Bill&Ted to work, we need to ignore calls that are less than 2 cpu calls from each other.
	// see http://wiki.nesdev.com/w/index.php/INES_Mapper_001
	var currTime = this.mainboard.synchroniser.getCpuMTC();
	var minTime = this.lastWriteMTC + ( COLOUR_ENCODING_MTC_PER_CPU * 2 );
	var valid = this.lastWriteMTC >= 0;
	this.lastWriteMTC = currTime;
	if ( valid && minTime >= currTime ) {
		return;
	}

	if ( ( data & 0x80 ) > 0 )
	{
		this.val = 0;
		this.count = 0;
		this.registers[0] |= 0x0C;
		//this.syncChrMirrors();
		//this.syncPrgMirrors();
		return;
	}

	this.val |= (data & 0x01) << this.count;
	this.count = this.count + 1;

	if ( this.count >= 5 )
	{
		this.mainboard.synchroniser.synchronise();
		var top3Bits = offset & 0xE000;
		switch ( top3Bits ) {
			case 0x8000: // IS_INT_BETWEEN( offset, 0x8000, 0xA000 )
				this.registers[0] = this.val & 0x1F;

				// bit 0 - Horizontal / vertical mirror switch
				var mirroringMethod;
				switch ( this.val & 0x3 )
				{
				case 0:
					mirroringMethod = PPU_MIRRORING_SINGLESCREEN_NT0;
					break;
				case 1:
					mirroringMethod = PPU_MIRRORING_SINGLESCREEN_NT1;
					break;
				case 2:
					mirroringMethod = PPU_MIRRORING_VERTICAL;
					break;
				case 3:
					mirroringMethod = PPU_MIRRORING_HORIZONTAL;
					break;
				}

				this.mainboard.ppu.changeMirroringMethod( mirroringMethod );				
			break;
			case 0xA000:
				this.registers[1] = this.val & 0x1F;
				//SOROM boards use the high bit of CHR to switch between 1st and last
				//256k of the PRG ROM
				if ( this.get16kPrgBankCount() > 16 ) {
					this.soromlatch = ( ( this.val & 0x10 ) > 0 );
					this.syncPrgMirrors();
				}
			break;
			case 0xC000:
				this.registers[2] = this.val & 0x1F;
				if ( this.get16kPrgBankCount() > 16 ) {
					this.registers[2] &= 0xF;
				}
			break;
			case 0xE000:
				this.registers[3] = this.val & 0xF;
				this.wRamEnabled = ( this.val & 0x10 ) === 0;
			break;
		}

		this.syncChrMirrors();
		this.syncPrgMirrors();

		this.count = 0;
		this.val = 0;
	}
};

mapper1.prototype.write8SRam = function( offset, data ) {
	if ( this.wRamEnabled )
	{
		Nes.basemapper.prototype.write8SRam.call( this, offset, data );
	}
};

mapper1.prototype.read8SRam = function( offset ) {
	if ( this.wRamEnabled )
		return Nes.basemapper.prototype.read8SRam.call( this, offset );
	else
		return 0; // TODO: supposed to be open bus
};

Nes.mappers[1] = mapper1;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper2 = function() {
};

mapper2.prototype = Object.create( Nes.basemapper.prototype );

mapper2.prototype.reset = function() {
	this.switch16kPrgBank( 0, true );
	this.switch16kPrgBank( this.get16kPrgBankCount() - 1, false );
	this.useVRAM();
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper2.prototype.write8PrgRom = function( offset, data ) {
//	this.mainboard.synchroniser.synchronise();
	this.switch16kPrgBank( data, true );
};

Nes.mappers[2] = mapper2;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

var mapper3 = function() {
};

mapper3.prototype = Object.create( Nes.basemapper.prototype );

mapper3.prototype.reset = function() {

	if ( this.get16kPrgBankCount() === 1 )
	{
		this.switch16kPrgBank( 0, true );
		this.switch16kPrgBank( 0, false );
	}
	else
	{
		this.switch32kPrgBank( 0 );
	}
	this.switch8kChrBank( 0 /* this.get8kChrBankCount() - 1 */ );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper3.prototype.write8PrgRom = function( offset, data ) {
	this.mainboard.synchroniser.synchronise();
	this.switch8kChrBank( data );
};

mapper3.prototype.write8ChrRom = function( offset, data ) {
	// do nothing - CHR rom not writable
};


Nes.mappers[3] = mapper3;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var mapper4 = function() {
	this.bankSwapByte = 0;
	this.prgRamDisableWrite = false;
	this.chipEnable = this.interruptsEnabled = true;
	this.irqCounter = this.irqLatch = 0;
	this.mReloadFlag = false;
	this._isMMC6 = false;
	this._mmc6PrgRamWriteByte = 0;

	this.lastA12Raise = 0;

	this.mSpriteAddress = this.mScreenAddress = false;
	this.mRenderingEnabled = false;

	this.banks = new Int32Array( 8 );
	this.banks[0] = 0;
	this.banks[1] = 2;
	this.banks[2] = 4;
	this.banks[3] = 5;
	this.banks[4] = 6;
	this.banks[5] = 7;

	this.banks[6] = 0;
	this.banks[7] = 1;
};

mapper4.prototype = Object.create( Nes.basemapper.prototype );

mapper4.prototype._eventIrq = function() { 
	// don't do anything - call to synchronise() will trigger the irq
	this.mainboard.synchroniser.changeEventTime( this._irqEventId, -1 );
};

mapper4.prototype.mapperSaveState = function( state ) {
	
	state.bankSwapByte = this.bankSwapByte;
	state.prgRamDisableWrite = this.prgRamDisableWrite;
	state.chipEnable = this.chipEnable;
	state.interruptsEnabled = this.interruptsEnabled;
	state.irqCounter = this.irqCounter;
	state.irqLatch = this.irqLatch;
	state.mReloadFlag = this.mReloadFlag;
	state._isMMC6 = this._isMMC6;
	state._mmc6PrgRamWriteByte = this._mmc6PrgRamWriteByte;
	state.lastA12Raise = this.lastA12Raise;
	state.mSpriteAddress = this.mSpriteAddress;
	state.mScreenAddress = this.mScreenAddress;
	state.mRenderingEnabled = this.mRenderingEnabled;
	state.banks = Nes.uintArrayToString( this.banks );
	state._interruptInProgress = this._interruptInProgress;
};

mapper4.prototype.mapperLoadState = function( state ) {

	this.bankSwapByte = state.bankSwapByte;
	this.prgRamDisableWrite = state.prgRamDisableWrite;
	this.chipEnable = state.chipEnable;
	this.interruptsEnabled = state.interruptsEnabled;
	this.irqCounter = state.irqCounter;
	this.irqLatch = state.irqLatch;
	this.mReloadFlag = state.mReloadFlag;
	this._isMMC6 = state._isMMC6;
	this._mmc6PrgRamWriteByte = state._mmc6PrgRamWriteByte;
	this.lastA12Raise = state.lastA12Raise;
	this.mSpriteAddress = state.mSpriteAddress;
	this.mScreenAddress = state.mScreenAddress;
	this.mRenderingEnabled = state.mRenderingEnabled;
	this.banks = Nes.stringToUintArray( state.banks );
	this._interruptInProgress = state._interruptInProgress;
};

mapper4.prototype.syncBanks = function( doPrg, doChr ) {

	if ( doPrg ) {
		this.switch8kPrgBank( this.banks[7], 1 );
		this.switch8kPrgBank( this.get8kPrgBankCount() - 1, 3 );

		if ( ( this.bankSwapByte & 0x40 ) > 0 )
		{
			this.switch8kPrgBank( this.get8kPrgBankCount() - 2, 0 );
			this.switch8kPrgBank( this.banks[6], 2 );
		}
		else
		{
			this.switch8kPrgBank( this.banks[6], 0 );
			this.switch8kPrgBank( this.get8kPrgBankCount() - 2, 2 );
		}
	}
/*
		   0: Select 2 KB CHR bank at PPU $0000-$07FF (or $1000-$17FF);
		   1: Select 2 KB CHR bank at PPU $0800-$0FFF (or $1800-$1FFF);
		   2: Select 1 KB CHR bank at PPU $1000-$13FF (or $0000-$03FF);
		   3: Select 1 KB CHR bank at PPU $1400-$17FF (or $0400-$07FF);
		   4: Select 1 KB CHR bank at PPU $1800-$1BFF (or $0800-$0BFF);
		   5: Select 1 KB CHR bank at PPU $1C00-$1FFF (or $0C00-$0FFF);
*/
	if ( doChr ) {
		this.mainboard.synchroniser.synchronise();
		
		var bank0 = this.banks[0] & 0xFE;
		var bank1 = this.banks[1] & 0xFE;
		if ( ( this.bankSwapByte & 0x80 ) > 0 )
		{
			this.switch1kChrBank( this.banks[2], 0 );
			this.switch1kChrBank( this.banks[3], 1 );
			this.switch1kChrBank( this.banks[4], 2 );
			this.switch1kChrBank( this.banks[5], 3 );
			
			this.switch1kChrBank( bank0, 4 );
			this.switch1kChrBank( bank0 + 1, 5 );
			this.switch1kChrBank( bank1, 6 );
			this.switch1kChrBank( bank1 + 1, 7 );
		}
		else
		{
			this.switch1kChrBank( bank0, 0 );
			this.switch1kChrBank( bank0 + 1, 1 );
			this.switch1kChrBank( bank1, 2 );
			this.switch1kChrBank( bank1 + 1, 3 );

			this.switch1kChrBank( this.banks[2], 4 );
			this.switch1kChrBank( this.banks[3], 5 );
			this.switch1kChrBank( this.banks[4], 6 );
			this.switch1kChrBank( this.banks[5], 7 );
		}
	}
};


mapper4.prototype._lookInDbForMMC6 = function() {
	
	if ( this.mainboard.cart && this.mainboard.cart._dbData ) {
		var db = this.mainboard.cart._dbData;
		if ( db['cartridge'] && db['cartridge'][0]['board'] && db['cartridge'][0]['board'][0] ) {
			var board = db['cartridge'][0]['board'][0];
			if ( board['chip'] && board['chip'][0] ) {
				var chip = board['chip'][0];
				if ( chip['$'] && chip['$']['type'] ) {
					return chip['$']['type'] === "MMC6B";
				}
			}
		}
	}
	return false;
};


mapper4.prototype.reset = function() {
	this.prgRamDisableWrite = false;
	this.chipEnable = this.interruptsEnabled = true;
	this._interruptInProgress = false;

	this._A12LowerLimit = ( COLOUR_ENCODING_VBLANK_SCANLINES ) * MASTER_CYCLES_PER_SCANLINE;
	this._A12UpperLimit = ( COLOUR_ENCODING_FRAME_SCANLINES - 1 ) * MASTER_CYCLES_PER_SCANLINE;
		

	this.lastA12Raise = 0;

	this.mSpriteAddress = this.mScreenAddress = false;
	this.mRenderingEnabled = false;
	this.irqCounter = 0xFF;
	this.irqLatch = 0xFF;
	this.mReloadFlag = false;
	this.lastA12Raise = 0;
	this._isMMC6 = this._lookInDbForMMC6();
	this._mmc6PrgRamWriteByte = 0;
	this.bankSwapByte = 0;
	this.banks[0] = 0;
	this.banks[1] = 2;
	this.banks[2] = 4;
	this.banks[3] = 5;
	this.banks[4] = 6;
	this.banks[5] = 7;

	this.banks[6] = 0;
	this.banks[7] = 1;
	
	if ( this.get1kChrBankCount() === 0 ) {
		this.useVRAM( 8 );
	}
	
	var that = this;
	// TODO: Need to remove this event on mapper unload
	this._irqEventId = this.mainboard.synchroniser.addEvent( 'mmc3 irq', -1, function() { that._eventIrq(); } );
	
	this.syncBanks( true, true );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper4.prototype.write8PrgRom = function( offset, data ) {
	
	var top3Bits = offset & 0xE000;
	switch ( top3Bits ) {
		case 0x8000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even
				if ( this.bankSwapByte !== data & 0xFF ) {
					this.bankSwapByte = data & 0xFF;
							
					if ( this._isMMC6 ) {
						var prgRamEnabled = ( this.bankSwapByte & 0x20 ) > 0;
						if ( !prgRamEnabled ) {
							this._mmc6PrgRamWriteByte = 0;
						}
					}

					this.syncBanks( true, true );
				}
			}
			else
			{ // odd
				var swapByte = this.bankSwapByte & 0x7;
				if ( this.banks[ swapByte ] !== data & 0xFF ) {
					this.banks[ swapByte ] = data & 0xFF;
					this.syncBanks( swapByte >= 6, swapByte <= 5 );
				}
			}
		break;
		case 0xA000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even
				var mirroringMethod = ( data & 0x1 ) > 0 ? PPU_MIRRORING_HORIZONTAL : PPU_MIRRORING_VERTICAL;
				if ( mirroringMethod !== this.mainboard.ppu.getMirroringMethod() ) {
					this.mainboard.synchroniser.synchronise();
					this.mainboard.ppu.changeMirroringMethod( mirroringMethod );
				}
			}
			else
			{ // odd
				if ( this._isMMC6 ) {
					var prgRamEnabled = ( this.bankSwapByte & 0x20 ) > 0;
					if ( prgRamEnabled ) {
						this._mmc6PrgRamWriteByte = data;
					}
				} else {
					this.prgRamDisableWrite = ( data & 0x40 ) > 0;
					this.chipEnable = ( data & 0x80 ) > 0;
				}
			}
		break;
		case 0xC000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even
				if ( this.irqLatch !== data ) {
					this.mainboard.synchroniser.synchronise();
				}
				this.irqLatch = data;
			}
			else
			{ // odd
				if ( !this.mReloadFlag ) {
					this.mainboard.synchroniser.synchronise();
				}
				this.mReloadFlag = true;
			}
			this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
		break;
		case 0xE000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even - "Writing any value to this register will disable MMC3 interrupts AND acknowledge any pending interrupts."
				this.interruptsEnabled = false;
				if ( this._interruptInProgress ) {
					this.mainboard.cpu.holdIrqLineLow( false );
					this._interruptInProgress = false;
				}
//				Log::Write( LOG_MAPPER, ( boost::format( "Interrupts disabled on mapper" ) ).str() );
			}
			else
			{ // odd
				if ( !this.interruptsEnabled ) {
					this.mainboard.synchroniser.synchronise();
				}
				this.interruptsEnabled = true;
//				Log::Write( LOG_MAPPER, ( boost::format( "Interrupts enabled on mapper" ) ).str() );
			}
			this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
		break;
	}
};

mapper4.prototype.decrementIrqCounter = function( tickCount ) {

	//var pos = this.mainboard.ppu.ticksToScreenCoordinates( tickCount );
	//var cpupos = this.mainboard.ppu.ticksToScreenCoordinates( this.mainboard.synchroniser.getCpuMTC() );

	this.lastA12Raise = tickCount;
	var doIrq = false;
	
	//console.log( "[" + this.mainboard.ppu.frameCounter + "] Doing decrement at " + pos.x + "x" + pos.y + " cpu: " + cpupos.x + "x" + cpupos.y + " : " + this.irqCounter );

	if ( this.mReloadFlag )
	{
		doIrq = this.irqLatch === 0;// MMC3 revA behaviour
		this.irqCounter = this.irqLatch;
		this.mReloadFlag = false;
		
	}
	else if ( this.irqCounter === 0 ) {
		this.irqCounter = this.irqLatch;
		if ( this._isMMC6 ) {
			doIrq = false;
		} else {
			if ( this.irqCounter === 0 )
				doIrq = true;
		}
	}
	else
	{
		if ( this.irqCounter > 0 )
			this.irqCounter--;
		doIrq = this.irqCounter === 0;
	}
	
	if ( doIrq && this.interruptsEnabled && !this._interruptInProgress ) {
		//	if ( this.mainboard.ppu.frameCounter === 43 && pos.x === 260 && pos.y === 0 ) {
	//				debugger;
		//		}
		//console.log( "[" + this.mainboard.ppu.frameCounter + "]" + pos.x + "x" + pos.y + " IRQ cpu: " + cpupos.x + "x" + cpupos.y );
		this._interruptInProgress = true;
		this.mainboard.cpu.holdIrqLineLow( true );
	}
};

mapper4.prototype.ppuA12Latch = function() {
	this.mainboard.synchroniser.synchronise();
	var cpuMtc = this.mainboard.synchroniser.getCpuMTC();
	if ( this.lastA12Raise > 0 && cpuMtc - this.lastA12Raise <= 16 * MASTER_CYCLES_PER_PPU ) {
		return; // Required for Bill & Ted to work: Ignore A12 raises that are too close together
	}
	this.decrementIrqCounter( cpuMtc );
	this.updateIRQTime( cpuMtc, true );
};


mapper4.prototype.calculateNextA12Raise = function( cpuMTC ) {

	// TODO: refactor this - could be more efficient
	var pixelEvent = -1;
	var firstScanline = 0;
	if ( this.mRenderingEnabled )
	{
		if ( this.mSpriteAddress && !this.mScreenAddress )
		{
			pixelEvent = 265; // 260
			firstScanline = 0;
		}
		// else if ( this.mSpriteAddress && this.mScreenAddress )
		// {
			// pixelEvent = 340;//324;
			// firstScanline = -1;
		// }
		else //if ( this.mScreenAddress && !this.mSpriteAddress )
		{
			pixelEvent = 9;// 324; // 9;
			firstScanline = 0;// -1;
		}
	}

	if ( cpuMTC >= this._A12UpperLimit || pixelEvent < 0 ) {
		return -1;
	}

	var modmtc = cpuMTC % MASTER_CYCLES_PER_SCANLINE; // ticks from the start of the current scanline
	var scanlineEvent = MASTER_CYCLES_PER_PPU * pixelEvent; // ticks from the start of the scanline when IRQ is decremented

	var startMtc = cpuMTC - modmtc + scanlineEvent; // ticks till next irq decrement event

	if ( startMtc <= cpuMTC )
		startMtc += MASTER_CYCLES_PER_SCANLINE; // if we have already passed the irq event, move onto next scanline
	if ( this._A12UpperLimit <= startMtc )
		return -1;

	if ( startMtc < this._A12LowerLimit )
		startMtc = this._A12LowerLimit + scanlineEvent;

	return startMtc;
};


mapper4.prototype.updateIRQTime = function( cpuTime, doSync ) {

	if ( doSync ) {
		this.mainboard.synchroniser.synchronise();
	}
	
	// tickLimit is the start of the rendering frame - only started being clocked when rendering
	var newEvent = -1;
	var nextRaise = 0;
	var scanlines = 0;
	if ( this.interruptsEnabled ) {
		nextRaise = this.calculateNextA12Raise( cpuTime );
		if ( nextRaise === -1 ) {
			newEvent = -1;
		} else {
			scanlines = this.mReloadFlag ? 0 : Math.max( this.irqCounter - 1, 0 );
			newEvent = nextRaise + ( scanlines * MASTER_CYCLES_PER_SCANLINE );
			if ( newEvent > this._A12UpperLimit ) {
				newEvent = -1;
			} else {
				//var pos = this.mainboard.ppu.ticksToScreenCoordinates( newEvent );
				//var cpupos = this.mainboard.ppu.ticksToScreenCoordinates( this.mainboard.synchroniser.getCpuMTC() );
				// if ( this.mainboard.ppu.frameCounter === 43 && pos.x === 260 && pos.y === 0 ) {
					// debugger;
				// }
				//console.log( "Predicting next IRQ at " + pos.x + "x" + pos.y + " cpu: " + cpupos.x + "x" + cpupos.y );
			}
		}
	}
	this.mainboard.synchroniser.changeEventTime( this._irqEventId, newEvent );
};

	
mapper4.prototype.spriteScreenEnabledUpdate = function( spriteAddress, screenAddress ) {
	this.mSpriteAddress = spriteAddress;
	this.mScreenAddress = screenAddress;
	this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
};

mapper4.prototype.renderingEnabledChanged = function( enabled ) {
	this.mRenderingEnabled = enabled;
	this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
};

mapper4.prototype.synchronise = function( startTicks, endTicks ) {
	/*
The heart of the MMC3. The PPU will cause A12 to rise when it fetches CHR from the right pattern table ($1xxx).
In "normal" conditions (BG uses $0xxx, all sprites use $1xxx), this will occur 8 times per scanline (once for each sprite).
However the BG could also be the culprit (if BG uses $1xxx and all sprites use $0xxx -- ?as seen in Armadillo?), in which case A12 will rise 34 times.
These 42 times per scanline are key times which I call "rise points":

BG rise points: 4, 12, 20, ... , 244, 252
Sp rise points: 260, 268, ..., 308, 316
BG rise points: 324, 332 
	
If sprites are set to $1000-1FFF and the background is set to $0000-0FFF, then A12 will change from 0 to 1 at cycle 260 of each scanline, then change from 1 to 0 at cycle 320 of each scanline.

If sprites are set to $0000-0FFF and the background is set to $1000-1FFF, then A12 will change from 1 to 0 at cycle 256 of each scanline, then change from 0 to 1 at cycle 324 of each scanline. 
*/
	// tickLimit is the start of the rendering frame - only started being clocked when rendering
	var startMtc = this.calculateNextA12Raise( startTicks+1 );
	if ( startMtc >= 0 )
	{
		for ( var mtc = startMtc; mtc <= Math.min( this._A12UpperLimit, endTicks ); mtc += MASTER_CYCLES_PER_SCANLINE )
		{
			this.decrementIrqCounter( mtc );
		}
	}
	this.updateIRQTime( endTicks, false );
};

mapper4.prototype.onEndFrame = function() {
	this.lastA12Raise = 0;
};

mapper4.prototype.write8SRam = function( offset, data ) {

	if ( this._isMMC6 ) {
		if ( offset >= 0x7000 ) {
			var mirroredOffset = offset & 0x3FF;
			var lowHalf = ( mirroredOffset & 0x200 ) === 0;
			var offsetMask = lowHalf ? 0x30 : 0xC0; // writing requires both the write and read bits set
			if ( ( this._mmc6PrgRamWriteByte & offsetMask ) === offsetMask ) {
				Nes.basemapper.prototype.write8SRam.call( this, mirroredOffset, data );
			}
		}
	} else {
		if ( this.chipEnable && !this.prgRamDisableWrite ) {
			Nes.basemapper.prototype.write8SRam.call( this, offset, data );
		}
	}
};

mapper4.prototype.read8SRam = function( offset ) {
	
	if ( this._isMMC6 && offset >= 0x7000 ) {
		if ( offset >= 0x7000 ) {
			var mirroredOffset = offset & 0x3FF;
			var lowHalf = ( mirroredOffset & 0x200 ) === 0;
			var offsetMask = lowHalf ? 0x20 : 0x80;
			if ( ( this._mmc6PrgRamWriteByte & offsetMask ) > 0 ) {
				return Nes.basemapper.prototype.read8SRam.call( this, mirroredOffset );
			}
		}
	} else {
		if ( this.chipEnable ) {
			return Nes.basemapper.prototype.read8SRam.call( this, offset );
		}
	}
	return 0;
};


Nes.mappers[4] = mapper4;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

// TODO: save/load states
// TODO: proper exram support


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var mapper5 = function() {

	this.mRenderingEnabled = false;
	
	this._chrMode = 0;
	this._prgMode = 0;
	this._exRamMode = 0;
	this._prgRegisters = new Int32Array( 4 );
	this._nameTableFill = new Int32Array( 1024 );
	this._internalExRam = new Int32Array( 1024 );
	this._prgRam = new Int32Array( 0x10000 ); // 64kb
	this._prgRamPage = 0;
	this._bigSpritesEnabled = false;
	
	this._writeProtectA = false;
	this._writeProtectB = false;
	this._currentScanline = 0;
	this._irqEnabled = false;
	this._irqActive = false;
	this._irqScanlineTrigger = 0;
	this._triggerMtc = -1;
	this._multiplier1 = 0;
	this._multiplier2 = 0;
	
	this._prgRamMap = new Int32Array( 4 ); // 8k ram banks that map to 0x8000 -> 0x10000 
	this._prgRamIsActive = new Int32Array( 4 );
	this._nameTableMap = new Int32Array( 4 );
	
	this._chrRegsA = new Int32Array( 8 );
	this._chrRegsB = new Int32Array( 4 );
	this._chrUseBMap = false;
	this._chrMapA = new Int32Array( 8 );
	this._chrMapB = new Int32Array( 4 );
	this._chrHighBits = 0;
};

mapper5.prototype = Object.create( Nes.basemapper.prototype );

mapper5.prototype.mapperSaveState = function( state ) {
	
	state.mRenderingEnabled = this.mRenderingEnabled;
	state._chrMode = this._chrMode;
	state._prgMode = this._prgMode;
	state._exRamMode = this._exRamMode;
	
	state._prgRegisters = Nes.uintArrayToString( this._prgRegisters );
	state._nameTableFill = Nes.uintArrayToString( this._nameTableFill );
	state._internalExRam = Nes.uintArrayToString( this._internalExRam );
	state._prgRam = Nes.uintArrayToString( this._prgRam );
	
	state._prgRamPage = this._prgRamPage;
	state._bigSpritesEnabled = this._bigSpritesEnabled;
	
	state._writeProtectA = this._writeProtectA;
	state._writeProtectB = this._writeProtectB;
	state._currentScanline = this._currentScanline;
	state._irqEnabled = this._irqEnabled;
	state._irqActive = this._irqActive;
	state._irqScanlineTrigger = this._irqScanlineTrigger;
	state._triggerMtc = this._triggerMtc;
	state._multiplier1 = this._multiplier1;
	state._multiplier2 = this._multiplier2;
	
	state._prgRamMap = Nes.uintArrayToString( this._prgRamMap );
	state._prgRamIsActive = Nes.uintArrayToString( this._prgRamIsActive );
	state._nameTableMap = Nes.uintArrayToString( this._nameTableMap );
	
	state._chrRegsA = Nes.uintArrayToString( this._chrRegsA );
	state._chrRegsB = Nes.uintArrayToString( this._chrRegsB );
	
	state._chrUseBMap = this._chrUseBMap;
	state._chrMapA = Nes.uintArrayToString( this._chrMapA );
	state._chrMapB = Nes.uintArrayToString( this._chrMapB );
	state._chrHighBits = this._chrHighBits;
};

mapper5.prototype.mapperLoadState = function( state ) {
	
	this.mRenderingEnabled = state.mRenderingEnabled;
	this._chrMode = state._chrMode;
	this._prgMode = state._prgMode;
	this._exRamMode = state._exRamMode;
	
	this._prgRegisters = Nes.stringToUintArray( state._prgRegisters );
	this._nameTableFill = Nes.stringToUintArray( state._nameTableFill );
	this._internalExRam = Nes.stringToUintArray( state._internalExRam );
	this._prgRam = Nes.stringToUintArray( state._prgRam );
	
	this._prgRamPage = state._prgRamPage;
	this._bigSpritesEnabled = state._bigSpritesEnabled;
	
	this._writeProtectA = state._writeProtectA;
	this._writeProtectB = state._writeProtectB;
	this._currentScanline = state._currentScanline;
	this._irqEnabled = state._irqEnabled;
	this._irqActive = state._irqActive;
	this._irqScanlineTrigger = state._irqScanlineTrigger;
	this._triggerMtc = state._triggerMtc;
	this._multiplier1 = state._multiplier1;
	this._multiplier2 = state._multiplier2;
	
	this._prgRamMap = Nes.stringToUintArray( state._prgRamMap );
	this._prgRamIsActive = Nes.stringToUintArray( state._prgRamIsActive );
	this._nameTableMap = Nes.stringToUintArray( state._nameTableMap );
	
	this._chrRegsA = Nes.stringToUintArray( state._chrRegsA );
	this._chrRegsB = Nes.stringToUintArray( state._chrRegsB );
	
	this._chrUseBMap = state._chrUseBMap;
	this._chrMapA = Nes.stringToUintArray( state._chrMapA );
	this._chrMapB = Nes.stringToUintArray( state._chrMapB );
	this._chrHighBits = state._chrHighBits;
};


mapper5.prototype.reset = function() {

	this.mRenderingEnabled = false;
	this._chrMode = 0;
	this._prgMode = 3;
	this._exRamMode = 0;
	this._chrHighBits = 0;
	this._prgRamPage = 0;
	this._writeProtectA = false;
	this._writeProtectB = false;
	this._irqEnabled = false;
	this._irqScanlineTrigger = 0;
	this._irqActive = false;
	this._multiplier1 = 0;
	this._multiplier2 = 0;
	this._currentScanline = 0;
	this._triggerMtc = -1;
	this._chrUseBMap = false;
	this._bigSpritesEnabled = false;
	
	for ( var i=0; i<this._prgRamMap.length; ++i ) {
		this._prgRamMap[i] = 0;
		this._prgRamIsActive[i] = 0;
	}
	for ( var i=0; i<this._nameTableMap.length; ++i ) {
		this._nameTableMap[i] = 0;
	}
	
	for ( var i=0; i<this._prgRegisters.length; ++i ) {
		this._prgRegisters[ i ] = this.get8kPrgBankCount() - 4 + i;
	}
	for ( var i=0; i<this._chrRegsA.length; ++i ) {
		this._chrRegsA[i] = 0;
	}
	for ( var i=0; i<this._chrRegsB.length; ++i ) {
		this._chrRegsB[i] = 0;
	}
	for ( var i=0; i<this._chrMapA.length; ++i ) {
		this._chrMapA[i] = 0;
	}
	for ( var i=0; i<this._chrMapB.length; ++i ) {
		this._chrMapB[i] = 0;
	}
	this._syncPrg();
	this._syncChr();
	this.switch8kChrBank( 0 );
	
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
	
	// TODO: Need to remove this event on mapper unload
	var that = this;
	this._irqEventId = this.mainboard.synchroniser.addEvent( 'mmc5 irq', -1, function( eventTime ) { that._irqEvent( eventTime ); } );
};

mapper5.prototype.renderingEnabledChanged = function( enabled ) {
	this.mRenderingEnabled = enabled;
	this._predictIrq( this.mainboard.synchroniser.getCpuMTC() );
};

mapper5.prototype._irqEvent = function( eventTime ) {

	if ( this.mRenderingEnabled && !this._irqActive && this._irqEnabled && this._irqScanlineTrigger > 0 ) {
		this._irqActive = true;
		this.mainboard.cpu.holdIrqLineLow( true );
	}
	this._predictIrq( eventTime );
};

mapper5.prototype._syncPrg = function() {

	this.mainboard.synchroniser.synchronise();
			
	for ( var i=0; i<this._prgRamMap.length; ++i ) {
		this._prgRamMap[i] = 0;
		this._prgRamIsActive[i] = 0;
	}
	
	switch ( this._prgMode ) {
		default:
		case 0:
			// 32k bank at 0x8000
			this.switch32kPrgBank( ( this._prgRegisters[ 3 ] & 0x7f ) >> 2 );
		break;
		case 1:
			// 16k bank at 0x8000
			if ( ( this._prgRegisters[ 1 ] & 0x80 ) === 0 ) {
				this._prgRamIsActive[ 0 ] = 1;
				this._prgRamIsActive[ 1 ] = 1;
				this._prgRamMap[ 0 ] = ( ( this._prgRegisters[ 1 ] & 0xE ) >> 1 ) * 2;
				this._prgRamMap[ 1 ] = this._prgRamMap[ 0 ] + 1;
			} else {
				this.switch16kPrgBank( ( this._prgRegisters[ 1 ] & 0x7f ) >> 1, true );
			}
			// 16k bank at 0xC000
			this.switch16kPrgBank( ( this._prgRegisters[ 3 ] & 0x7f ) >> 1, false );
		break;
		case 2:
			// 8k bank at 0xE000
			this.switch8kPrgBank( ( this._prgRegisters[3] & 0x7f ), 3 );
			
			// 8k bank at 0xC000
			if ( ( this._prgRegisters[ 2 ] & 0x80 ) === 0 ) {
				this._prgRamIsActive[ 2 ] = 1;
				this._prgRamMap[ 2 ] = ( this._prgRegisters[2] & 0x7 );
			} else {
				this.switch8kPrgBank( ( this._prgRegisters[2] & 0x7f ), 2 );
			}
			
			// 16k bank at 0x8000
			if ( ( this._prgRegisters[ 1 ] & 0x80 ) === 0 ) {
				this._prgRamIsActive[ 0 ] = 1;
				this._prgRamIsActive[ 1 ] = 1;
				this._prgRamMap[ 0 ] = ( ( this._prgRegisters[1] & 0xE ) >> 1 ) * 2;
				this._prgRamMap[ 1 ] = this._prgRamMap[ 0 ] + 1;
			} else {
				this.switch16kPrgBank( ( this._prgRegisters[1] & 0x7f ) >> 1, true );
			}
		break;
		case 3:
			// 8k bank at 0xE000
			this.switch8kPrgBank( ( this._prgRegisters[3] & 0x7f ), 3 );
			// 8k bank at 0xC000
			if ( ( this._prgRegisters[ 2 ] & 0x80 ) === 0 ) {
				this._prgRamIsActive[ 2 ] = 1;
				this._prgRamMap[ 2 ] = this._prgRegisters[2] & 0x7;
			} else {
				this.switch8kPrgBank( ( this._prgRegisters[2] & 0x7f ), 2 );
			}
			// 8k bank at 0xA000
			if ( ( this._prgRegisters[ 1 ] & 0x80 ) === 0 ) {
				this._prgRamIsActive[ 1 ] = 1;
				this._prgRamMap[ 1 ] = this._prgRegisters[1] & 0x7;
			} else {
				this.switch8kPrgBank( ( this._prgRegisters[1] & 0x7f ), 1 );
			}
			// 8k bank at 0x8000
			if ( ( this._prgRegisters[ 0 ] & 0x80 ) === 0 ) {
				this._prgRamIsActive[ 0 ] = 1;
				this._prgRamMap[ 0 ] = this._prgRegisters[0] & 0x7;
			} else {
				this.switch8kPrgBank( ( this._prgRegisters[0] & 0x7f ), 0 );
			}
		break;
	}
};


mapper5.prototype._chrBank = function( chrMap, banksize, bankpos, banknum ) {
	
	for ( var i=0; i<banksize; ++i ) {
		chrMap[ i + bankpos ] = ( banknum + i ) % this.get1kChrBankCount();
	}
};


mapper5.prototype._syncChr = function() {

	this.mainboard.synchroniser.synchronise();

	switch (this._chrMode) {
		default:
		case 0:
			this._chrBank( this._chrMapA, 8, 0, this._chrRegsA[7] );
			this._chrBank( this._chrMapB, 4, 0, this._chrRegsB[3] );
			break;
		case 1:
			this._chrBank( this._chrMapA, 4, 0, this._chrRegsA[3] );
			this._chrBank( this._chrMapA, 4, 4, this._chrRegsA[7] );
			this._chrBank( this._chrMapB, 4, 0, this._chrRegsB[3] );
			break;
		case 2:
			this._chrBank( this._chrMapA, 2, 0, this._chrRegsA[1] );
			this._chrBank( this._chrMapA, 2, 2, this._chrRegsA[3] );
			this._chrBank( this._chrMapA, 2, 4, this._chrRegsA[5] );
			this._chrBank( this._chrMapA, 2, 6, this._chrRegsA[7] );
			this._chrBank( this._chrMapB, 2, 0, this._chrRegsB[1] );
			this._chrBank( this._chrMapB, 2, 2, this._chrRegsB[3] );
			break;
		case 3:
			for ( var i=0; i<8; ++i ) {
				this._chrBank( this._chrMapA, 1, i, this._chrRegsA[i] );
			}
			for ( var i=0; i<4; ++i ) {
				this._chrBank( this._chrMapB, 1, i, this._chrRegsB[i] );
			}
			break;
	}
};

mapper5.prototype.write8PrgRom = function( offset, data ) {
	if ( this._writeProtectA && this._writeProtectB ) {
		var top3Bits = ( offset & 0xE000 ) >> 13;
		if ( this._prgRamIsActive[ top3Bits ] === 1 ) {
			this._prgRam[ ( this._prgRamMap[ top3Bits ] << 13 ) | ( offset & 0x1FFF ) ] = data;
		} else {
			Nes.basemapper.prototype.write8PrgRom.call( this, offset, data );
		}
	}
};

mapper5.prototype.read8PrgRom = function( offset ) {
	var top3Bits = ( offset & 0xE000 ) >> 13;
	if ( this._prgRamIsActive[ top3Bits ] === 1 ) {
		return this._prgRam[ ( this._prgRamMap[ top3Bits ] << 13 ) | ( offset & 0x1FFF ) ]; // this._prgRamMap[0] * 0x2000 + ( offset % 0x2000 ) ];
	}
	return Nes.basemapper.prototype.read8PrgRom.call( this, offset );
};

mapper5.prototype.onEndFrame = function() {
	this._predictIrq( 0 );
};

mapper5.prototype._predictIrq = function( cpuMTC ) {

	// TODO: Check if MMC5 counter includes pre-render scanline
	if ( this.mRenderingEnabled && !this._irqActive && this._irqEnabled && this._irqScanlineTrigger > 0 ) {
		var targetScanline = this._irqScanlineTrigger;
		var triggerMtc = this.mainboard.ppu.screenCoordinatesToTicks( 0, targetScanline );
		if ( triggerMtc > cpuMTC ) {
			if ( this._triggerMtc !== triggerMtc ) {
				//var pos = this.mainboard.ppu.ticksToScreenCoordinates( triggerMtc );
				this.mainboard.synchroniser.changeEventTime( this._irqEventId, triggerMtc );
				this._triggerMtc = triggerMtc;
			}
		}
		return;
	}
	
	if ( this._triggerMtc !== -1 ) {
		this._triggerMtc = -1;
		this.mainboard.synchroniser.changeEventTime( this._irqEventId, -1 );
	}
};

mapper5.prototype.write8EXRam = function( offset, data ) {
	// 0x4018 -> 0x6000
	switch ( offset ) {
	case 0x5100: // PRG mode
		this._prgMode = data & 0x3;
		this._syncPrg();
	break;
	case 0x5101: // CHR mode
		this._chrMode = data & 0x3;
		this._syncChr();
	break;
	case 0x5102: // PRG RAM write protect 1
		this._writeProtectA = ( data & 0x3 ) === 0x2;
	break;
	case 0x5103: // PRG RAM write protect 2
		this._writeProtectB = ( data & 0x3 ) === 0x1;
	break;
	case 0x5104: // extended RAM mode
		this.mainboard.synchroniser.synchronise();
		this._exRamMode = data & 0x3;
	break;
	case 0x5105: // nametable mode
		this.mainboard.synchroniser.synchronise();
		this._setNametableMirroring( data );
	break;
	case 0x5106: // fill mode tile number
		this.mainboard.synchroniser.synchronise();
		for ( var i=0; i< (32 * 30); ++i ) {
			this._nameTableFill[ i ] = data;
		}
	break;
	case 0x5107: // fill mode colour
		this.mainboard.synchroniser.synchronise();
		var attribute = data & 0x3 + (data & 3) << 2 + (data & 3) << 4 + (data & 3) << 6;
		for ( var i=(32 * 30); i<this._nameTableFill.length; ++i ) {
			this._nameTableFill[ i ] = attribute;
		}
	break;
	case 0x5113: // prg ram bank
		this._prgRamPage = data & 0x7;
	break;
	case 0x5114: // prg bank 0
		this._prgRegisters[ 0 ] = data;
		this._syncPrg();
	break;
	case 0x5115: // prg bank 1
		this._prgRegisters[ 1 ] = data;
		this._syncPrg();
	break;
	case 0x5116: // prg bank 2
		this._prgRegisters[ 2 ] = data;
		this._syncPrg();
	break;
	case 0x5117: // prg bank 3
		this._prgRegisters[ 3 ] = data;
		this._syncPrg();
	break;
	case 0x5120: // chr registers A
		this._chrRegsA[ 0 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5121:
		this._chrRegsA[ 1 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5122:
		this._chrRegsA[ 2 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5123:
		this._chrRegsA[ 3 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5124:
		this._chrRegsA[ 4 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5125:
		this._chrRegsA[ 5 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5126:
		this._chrRegsA[ 6 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5127:
		this._chrRegsA[ 7 ] = data | this._chrHighBits;
		this._chrUseBMap = false;
		this._syncChr();
	break;
	case 0x5128: // Chr registers B
		this._chrRegsB[ 0 ] = data | this._chrHighBits;
		this._chrUseBMap = true;
		this._syncChr();
	break;
	case 0x5129:
		this._chrRegsB[ 1 ] = data | this._chrHighBits;
		this._chrUseBMap = true;
		this._syncChr();
	break;
	case 0x512A:
		this._chrRegsB[ 2 ] = data | this._chrHighBits;
		this._chrUseBMap = true;
		this._syncChr();
	break;
	case 0x512B:
		this._chrRegsB[ 3 ] = data | this._chrHighBits;
		this._chrUseBMap = true;
		this._syncChr();
	break;
	case 0x5130: // CHR bank high bits
		this.mainboard.synchroniser.synchronise();
		this._chrHighBits = ( data & 0x3 ) << 8;
	break;
	case 0x5200: // vertical split mode
		// dont bother with vertical mode as it was only used once in commercial games, for the intro sequence
	break;
	case 0x5201: // vertical split scroll
	break;
	case 0x5202: // vertical split chr page
	break;
	case 0x5203: // irq scanline number trigger
		this.mainboard.synchroniser.synchronise();
		this._irqScanlineTrigger = data;
		this._predictIrq( this.mainboard.synchroniser.getCpuMTC() );
	break;
	case 0x5204: // irq enable (different behaviour on read)
		this.mainboard.synchroniser.synchronise();
		this._irqEnabled = ( data & 0x80 ) > 0;
		this._predictIrq( this.mainboard.synchroniser.getCpuMTC() );
	break;
	case 0x5205: //  Writes specify the eight-bit multiplicand; reads return the lower eight bits of the product
		this._multiplier1 = data;
	break;
	case 0x5206: // Writes specify the eight-bit multiplier; reads return the upper eight bits of the product
		this._multiplier2 = data;
	break;
	}
	
	if ( offset >= 0x5C00 ) {
		// TODO: Remove synchronise and work out isRendering by mtc
		this.mainboard.synchroniser.synchronise();
		if ( this._exRamMode === 0 || this._exRamMode === 1 ) {
			// only allow writing during rendering, otherwise write 0
			if ( this.mainboard.ppu.isRendering( this.mainboard.synchroniser.getCpuMTC(), false ) ) {
				this._internalExRam[ offset - 0x5C00 ] = data;
			} else {
				this._internalExRam[ offset - 0x5C00 ] = 0;
			}
		} else if ( this._exRamMode === 2 ) {
			// always write
			this._internalExRam[ offset - 0x5C00 ] = data;
		}
	}
	
	//Nes.basemapper.prototype.write8EXRam.call( this, offset, data );
};

mapper5.prototype.read8EXRam = function( offset ) {
	// 0x4018 -> 0x6000
	switch ( offset ) {
	case 0x5015:
		//sound status
//			return soundchip.status();
		break;
	case 0x5204:
		//irq status
		this.mainboard.synchroniser.synchronise();
		var scan = this.mainboard.ppu.ticksToScreenCoordinates( this.mainboard.synchroniser.getCpuMTC() );
		var stat = ( this._irqActive ? 0x80 : 0 ) + ( scan.y >= 0 && scan.y < 240 ? 0x40 : 0 );
		if ( this._irqActive ) {
			this._irqActive = false;
			this.mainboard.cpu.holdIrqLineLow( false );
		}
		this._predictIrq( this.mainboard.synchroniser.getCpuMTC() );
		return stat;
	case 0x5205: //  Writes specify the eight-bit multiplicand; reads return the lower eight bits of the product
		return (this._multiplier1 * this._multiplier2) & 0xff;
	break;
	case 0x5206: // Writes specify the eight-bit multiplier; reads return the upper eight bits of the product
		return ((this._multiplier1 * this._multiplier2) >> 8) & 0xff;
	break;
	}
	
	if ( offset >= 0x5C00 ) {
		if ( this._exRamMode === 2 || this._exRamMode === 3 ) {
			return this._internalExRam[ offset - 0x5C00 ];
		}
	}
	
	return 0; // supposed to be open bus
};

mapper5.prototype.write8SRam = function( offset, data ) {
	// 0x6000 -> 0x8000
	this._prgRam[ ( this._prgRamPage << 13 ) | ( offset & 0x1FFF ) ] = data; // this._prgRamPage * 0x2000 + ( offset % 0x2000 ) ] = data;
};

mapper5.prototype.read8SRam = function( offset ) {
	// 0x6000 -> 0x8000
	return this._prgRam[ ( this._prgRamPage << 13 ) | ( offset & 0x1FFF ) ];
};

mapper5.prototype._setNametableMirroring = function( data ) {

	for ( var nt=0; nt<4; ++nt ) {
		this._nameTableMap[ nt ] = data & 0x3;
		data >>= 2;
	}
};

mapper5.prototype.read8ChrRom = function( offset, renderingSprites, readType ) {

	// Pattern table read < 0x2000
	if ( renderingSprites ) {
		var pageid = ( offset & 0x1C00 ) >> 10; // Math.floor( offset / 0x400 );
		var pagepos = this._chrMapA[ pageid & 0x7 ];
		var chrOffset = ( pagepos * 0x400 ) + ( offset & 0x3FF );
		return  this._chrData[ chrOffset ];
	}/* else {
		if ( this._exRamMode === 1 ) {
			
		}
	}*/
	
	var useMapB = false;
	
	if ( this._bigSpritesEnabled ) {
		useMapB = !renderingSprites;
	} else {
		useMapB = this._chrUseBMap;
	}

	var pageid = ( offset & 0x1C00 ) >> 10; // Math.floor( offset / 0x400 );
	var pagepos = useMapB ? this._chrMapB[ pageid & 0x3 ] : this._chrMapA[ pageid & 0x7 ];
	var chrOffset = (pagepos*0x400) + ( offset & 0x3FF );
	return  this._chrData[ chrOffset ];
};

mapper5.prototype.nameTableRead = function( nameTables, pageId, pageOffset ) {

	switch ( this._nameTableMap[ pageId ] ) {
		default:
		case 0:
			return nameTables[ 0 ][ pageOffset ];
		case 1:
			return nameTables[ 1 ][ pageOffset ];
		case 2:
			if ( this._exRamMode === 0 || this._exRamMode === 1 ) {
				return this._internalExRam[ pageOffset ];
			} else {
				return 0;
			}
		case 3:
			return this._nameTableFill[ pageOffset ];
	}
};

mapper5.prototype.nameTableWrite = function( nameTables, pageId, pageOffset, data ) {

	switch ( this._nameTableMap[ pageId ] ) {
		default:
		case 0:
			 nameTables[ 0 ][ pageOffset] =  data ;
		break;
		case 1:
			 nameTables[ 1 ][ pageOffset] =  data ;
		break;
		case 2:
			if ( this._exRamMode === 0 || this._exRamMode === 1 ) {
				this._internalExRam[ pageOffset ] = data;
			}
		break;
		case 3:
			this._nameTableFill[ pageOffset ] = data;
		break;
	}
};

mapper5.prototype.spriteSizeChanged = function( bigSprites ) {
	
	this._bigSpritesEnabled = bigSprites;
};

Nes.mappers[5] = mapper5;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper6 = function() {
};

mapper6.prototype = Object.create( Nes.basemapper.prototype );

mapper6.prototype.reset = function() {

	this.switch16kPrgBank( 0, true );
	this.switch16kPrgBank( 7, false );
	this.switch8kChrBank( 0 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper6.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	this.switch8kChrBank( data & 0x3 );
	this.switch16kPrgBank( ( data & 0x3C ) >> 2, true );
};
	
Nes.mappers[6] = mapper6;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper7 = function() {
};

mapper7.prototype = Object.create( Nes.basemapper.prototype );

mapper7.prototype.reset = function() {

	this.switch32kPrgBank( 0 );

	if ( this.get8kChrBankCount() === 0 )
		this.useVRAM();
	else
		this.switch8kChrBank( 0 );
	
	this.mirroringMethod = PPU_MIRRORING_SINGLESCREEN_NT0;
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper7.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	this.switch32kPrgBank( data & 0xFF );
	
	var mirroringMethod;
	if ( ( data & 0x10 ) > 0 )
		mirroringMethod = PPU_MIRRORING_SINGLESCREEN_NT1;
	else
		mirroringMethod = PPU_MIRRORING_SINGLESCREEN_NT0;
	this.mainboard.ppu.changeMirroringMethod( mirroringMethod );
};
	
Nes.mappers[7] = mapper7;

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper8 = function() {
};

mapper8.prototype = Object.create( Nes.basemapper.prototype );

mapper8.prototype.reset = function() {

	this.switch16kPrgBank( 0, true );
	this.switch16kPrgBank( 1, false );
	this.switch8kChrBank( 0 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper8.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	this.switch8kChrBank( data & 0x7 );
	this.switch16kPrgBank( ( data & 0xF8 ) >> 3, true );
};
	
Nes.mappers[8] = mapper8;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper9 = function() {

	this._banks = new Int32Array( 4 );
};

mapper9.prototype = Object.create( Nes.basemapper.prototype );


mapper9.prototype.mapperSaveState = function( state ) {

	state._banks = Nes.uintArrayToString( this._banks );
	state._latches = this._latches.slice( 0 );
};

mapper9.prototype.mapperLoadState = function( state ) {

	this._banks = Nes.stringToUintArray( state._banks );
	this._latches = state._latches.slice( 0 );
};

mapper9.prototype.reset = function() {

	this._latches = [ true, false ];
	for ( var i=0; i<this._banks.length; ++i ) {
		this._banks[i] = 0;
	}

	this.switch32kPrgBank( this.get32kPrgBankCount() - 1 );
	for ( var i=0; i<8; ++i ) {
		this.switch1kChrBank( 0, i );
	}
//	this.switch8kChrBank( 0 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper9.prototype._syncChrBanks = function( performSync ) {

	if ( performSync === undefined ? true : performSync ) {
		this.mainboard.synchroniser.synchronise();
	}
	var lowerBankId = this._latches[ 0 ] ? 1 : 0;
	this.switch4kChrBank( this._banks[ lowerBankId ], true );
	var upperBankId = this._latches[ 1 ] ? 3 : 2;
	this.switch4kChrBank( this._banks[ upperBankId ], false );
};

mapper9.prototype.MMC2Latch = function( ppuReadAddress ) {

	// http://wiki.nesdev.com/w/index.php/MMC2
	if ( ppuReadAddress === 0xFD8 ) {
		this._latches[ 0 ] = false;
		this._syncChrBanks( false );
	} else if ( ppuReadAddress === 0xFE8 ) {
		this._latches[ 0 ] = true;
		this._syncChrBanks( false );
	} else if ( ppuReadAddress >= 0x1FD8 && ppuReadAddress <= 0x1FDF ) {
		this._latches[ 1 ] = false;
		this._syncChrBanks( false );
	} else if ( ppuReadAddress >= 0x1FE8 && ppuReadAddress <= 0x1FEF ) {
		this._latches[ 1 ] = true;
		this._syncChrBanks( false );
	}
	// var latchId = ( ppuReadAddress & 0x1000 ) > 0 ? 1 : 0;
	// var tilenum = ( ppuReadAddress >> 4 ) & 0xFF;
	// var isFE = tilenum === 0xFE;
	// if ( tilenum === 0xFD || isFE ) {
		// this._latches[ latchId ] = isFE;
		// this._syncChrBanks();
	// }
};

mapper9.prototype.write8PrgRom = function( offset, data ) {

	var top4Bits = offset & 0xF000;
	switch ( top4Bits ) {
	case 0xA000:
		this.mainboard.synchroniser.synchronise();
		this.switch8kPrgBank( data & 0xf, 0 );
	break;
	case 0xB000:
		this._banks[0] = data & 0x1F;
		this._syncChrBanks();
	break;
	case 0xC000:
		this._banks[1] = data & 0x1F;
		this._syncChrBanks();
	break;
	case 0xD000:
		this._banks[2] = data & 0x1F;
		this._syncChrBanks();
	break;
	case 0xE000:
		this._banks[3] = data & 0x1F;
		this._syncChrBanks();
	break;
	case 0xF000:
		this.mainboard.synchroniser.synchronise();
		this.mainboard.ppu.changeMirroringMethod( ( ( data & 0x1 ) > 0 ) ? PPU_MIRRORING_HORIZONTAL : PPU_MIRRORING_VERTICAL );
	break;
	default:
		Nes.basemapper.prototype.write8PrgRom.call( this, offset, data );
	break;
	}
};
	
Nes.mappers[9] = mapper9;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper11 = function() {
};

mapper11.prototype = Object.create( Nes.basemapper.prototype );

mapper11.prototype.reset = function() {

	this.switch32kPrgBank( this.get32kPrgBankCount() - 1 );
	//this.switch8kChrBank( this.get8kChrBankCount() - 1 );
	this.switch8kChrBank( 0 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper11.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	this.switch32kPrgBank( data & 0x3 );
	this.switch8kChrBank( ( data & 0xF0 ) >> 4 );
};
	
Nes.mappers[11] = mapper11;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";



var mapper13 = function() {
};

mapper13.prototype = Object.create( Nes.basemapper.prototype );

mapper13.prototype.reset = function() {

	this.switch32kPrgBank( 0 );
	this.useVRAM( 16 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper13.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	this.switch4kChrBank( data, false );
};
	
Nes.mappers[13] = mapper13;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";




var mapper15 = function() {
};

mapper15.prototype = Object.create( Nes.basemapper.prototype );

mapper15.prototype.reset = function() {

	this.switch32kPrgBank( 0 );
	this.useVRAM();
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper15.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	
	var mirroringMethod;
	if ( ( data & 0x40 ) > 0 )
		mirroringMethod = PPU_MIRRORING_HORIZONTAL;
	else
		mirroringMethod = PPU_MIRRORING_VERTICAL;
	this.mainboard.ppu.changeMirroringMethod( mirroringMethod );
	
	var upper8k = ( data & 0x80 ) > 0;
	var prgBank = data & 0x3F;

	switch ( offset & 0x3 )
	{
	case 2: // 8k mode ( 1 8k bank mirrored )
		for ( var i=0; i<4; ++i )
			this.switch8kPrgBank( prgBank * 2 + ( upper8k ? 1 : 0 ), i );
		break;
	case 3: // 16k mode ( 1 16k bank mirrored )
		this.switch16kPrgBank( prgBank, true );
		this.switch16kPrgBank( prgBank, false );
		break;
	case 0: // 32k mode ( 1 32k bank, or if odd number, same as 16k mode )
		this.switch16kPrgBank( prgBank, true );
		this.switch16kPrgBank( prgBank | 1, false );
		break;
	case 1: // 128k mode ( 1 16k bank, last 16k bank fixed at 0xC00 )
		this.switch16kPrgBank( prgBank, true );
		this.switch16kPrgBank( this.get16kPrgBankCount() - 1, false );
		break;
	}
};
	
Nes.mappers[15] = mapper15;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper17 = function() {
};

mapper17.prototype = Object.create( Nes.basemapper.prototype );

mapper17.prototype.reset = function() {

	this.switch32kPrgBank( 0 );
	this.switch8kChrBank( 0 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};
	
mapper17.prototype.write8EXRom = function( offset, data ) {
	
	this.mainboard.synchroniser.synchronise();
	switch ( offset )
	{
	case 0x4504:
		this.switch8kPrgBank( data, 0 );
		break;
	case 0x4505:
		this.switch8kPrgBank( data, 1 );
		break;
	case 0x4506:
		this.switch8kPrgBank( data, 2 );
		break;
	case 0x4507:
		this.switch8kPrgBank( data, 3 );
		break;
	case 0x4510:
		this.switch1kChrBank( data, 0 );
		break;
	case 0x4511:
		this.switch1kChrBank( data, 1 );
		break;
	case 0x4512:
		this.switch1kChrBank( data, 2 );
		break;
	case 0x4513:
		this.switch1kChrBank( data, 3 );
		break;
	case 0x4514:
		this.switch1kChrBank( data, 4 );
		break;
	case 0x4515:
		this.switch1kChrBank( data, 5 );
		break;
	case 0x4516:
		this.switch1kChrBank( data, 6 );
		break;
	case 0x4517:
		this.switch1kChrBank( data, 7 );
		break;
	}
};
	
Nes.mappers[17] = mapper17;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper34 = function() {
};

mapper34.prototype = Object.create( Nes.basemapper.prototype );

mapper34.prototype.reset = function() {
	
	var isImpossibleMission2 = this.mainboard.cart.getHash() === "68315AFB344108CB0D43E119BA0353D5A44BD489";
	this._isNinaBoard = isImpossibleMission2;
	this.switch32kPrgBank( 0 );
	if ( this.get8kChrBankCount() === 0 )
	{
		this.useVRAM();
	}
	else
	{
		this.switch8kChrBank( 0 );
	}
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};


mapper34.prototype.write8SRam = function( offset, data ) {
	if ( this._isNinaBoard ) {
		this.mainboard.synchroniser.synchronise();
		if ( offset === 0x7FFE ) {
			this.switch4kChrBank( data & 0xF, true );
		} else if ( offset === 0x7FFF ) {
			this.switch4kChrBank( data & 0xF, false );
		} else if ( offset === 0x7FFD ) {
			this.switch32kPrgBank( data & 0x1 );
		} else {
			Nes.basemapper.prototype.write8SRam.call( this, offset, data );
		}
	} else {
		Nes.basemapper.prototype.write8SRam.call( this, offset, data );
	}
};

mapper34.prototype.write8PrgRom = function( offset, data ) {
	if ( !this._isNinaBoard ) {
		this.mainboard.synchroniser.synchronise();
		this.switch32kPrgBank( data & 0xFF );
	} else {
		Nes.basemapper.prototype.write8PrgRom.call( this, offset, data );
	}
};
	
Nes.mappers[34] = mapper34;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper41 = function() {
};

mapper41.prototype = Object.create( Nes.basemapper.prototype );

mapper41.prototype.reset = function() {

	this._prgBank = 0;
	this._chrOuter = 0;
	this._chrInner = 0;
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
	this._sync();
};


mapper41.prototype.write8SRam = function( offset, data ) {

	if ( ( offset & 0xF800 ) === 0x6000 ) {
		
		this.mainboard.synchroniser.synchronise();
		this._prgBank = offset & 0x7;
		this._chrOuter = ( offset & 0x18 ) >> 1;
		
		if ( ( offset & 0x20 ) === 0 ) {
			this.mainboard.ppu.changeMirroringMethod( PPU_MIRRORING_VERTICAL );
		} else {
			this.mainboard.ppu.changeMirroringMethod( PPU_MIRRORING_HORIZONTAL );
		}
		
		this._sync();
	}
};


mapper41.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	if ( ( this._prgBank & 0x4 ) > 0 ) {
		// enable inner chr bank select if bit 0x4 is set in prg bank id
		this._chrInner = data & 0x3;
	}
	this._sync();
};


mapper41.prototype._sync = function() {

	this.switch32kPrgBank( this._prgBank );
	var chr8kBank = this._chrOuter | this._chrInner;
	this.switch8kChrBank( chr8kBank );
};


Nes.mappers[41] = mapper41;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// RAMBO-1 - MMC3 inspired mapper.

// TODO: Accurate IRQ timing ( currently the scanline-mode works exactly like MMC3, which is not correct http://forums.nesdev.com/viewtopic.php?p=117323#p117323 )


var mapper64 = function() {
	this.bankSwapByte = 0;
	this.prgRamDisableWrite = false;
	this.chipEnable = this.interruptsEnabled = true;
	this.irqCounter = this.irqLatch = 0;
	this.mReloadFlag = false;

	this.lastA12Raise = 0;

	this.mSpriteAddress = this.mScreenAddress = false;
	this.mRenderingEnabled = false;
	this._cpuCycleMode = false;

	this.banks = new Int32Array( 16 );
	this.banks[0] = 0;
	this.banks[1] = 2;
	this.banks[2] = 4;
	this.banks[3] = 5;
	this.banks[4] = 6;
	this.banks[5] = 7;

	this.banks[6] = 0;
	this.banks[7] = 1;
	
	this.banks[8] = 2;
	this.banks[9] = 3;
	// inbetween banks not used
	this.banks[15] = 0;
};

mapper64.prototype = Object.create( Nes.basemapper.prototype );

mapper64.prototype._eventIrq = function() { 
	// don't do anything - call to synchronise() will trigger the irq
	this.mainboard.synchroniser.changeEventTime( this._irqEventId, -1 );
};

mapper64.prototype.mapperSaveState = function( state ) {
	
	state.bankSwapByte = this.bankSwapByte;
	state.prgRamDisableWrite = this.prgRamDisableWrite;
	state.chipEnable = this.chipEnable;
	state._cpuCycleMode = this._cpuCycleMode;
	state.interruptsEnabled = this.interruptsEnabled;
	state.irqCounter = this.irqCounter;
	state.irqLatch = this.irqLatch;
	state.mReloadFlag = this.mReloadFlag;
	state.lastA12Raise = this.lastA12Raise;
	state.mSpriteAddress = this.mSpriteAddress;
	state.mScreenAddress = this.mScreenAddress;
	state.mRenderingEnabled = this.mRenderingEnabled;
	state.banks = Nes.uintArrayToString( this.banks );
	state._interruptInProgress = this._interruptInProgress;
};

mapper64.prototype.mapperLoadState = function( state ) {

	this.bankSwapByte = state.bankSwapByte;
	this.prgRamDisableWrite = state.prgRamDisableWrite;
	this._cpuCycleMode = state._cpuCycleMode;
	this.chipEnable = state.chipEnable;
	this.interruptsEnabled = state.interruptsEnabled;
	this.irqCounter = state.irqCounter;
	this.irqLatch = state.irqLatch;
	this.mReloadFlag = state.mReloadFlag;
	this.lastA12Raise = state.lastA12Raise;
	this.mSpriteAddress = state.mSpriteAddress;
	this.mScreenAddress = state.mScreenAddress;
	this.mRenderingEnabled = state.mRenderingEnabled;
	this.banks = Nes.stringToUintArray( state.banks );
	this._interruptInProgress = state._interruptInProgress;
};

mapper64.prototype.syncBanks = function( doPrg, doChr ) {

	if ( doPrg ) {
		this.switch8kPrgBank( this.get8kPrgBankCount() - 1, 3 );

		// RAMBO-1 changes prg banks slightly different to mmc3
		if ( ( this.bankSwapByte & 0x40 ) > 0 ) {
			this.switch8kPrgBank( this.banks[15], 0 );
			this.switch8kPrgBank( this.banks[6], 1 );
			this.switch8kPrgBank( this.banks[7], 2 );
		} else {
			this.switch8kPrgBank( this.banks[6], 0 );
			this.switch8kPrgBank( this.banks[7], 1 );
			this.switch8kPrgBank( this.banks[15], 2 );
		}
	}
/*
		   0: Select 2 KB CHR bank at PPU $0000-$07FF (or $1000-$17FF);
		   1: Select 2 KB CHR bank at PPU $0800-$0FFF (or $1800-$1FFF);
		   2: Select 1 KB CHR bank at PPU $1000-$13FF (or $0000-$03FF);
		   3: Select 1 KB CHR bank at PPU $1400-$17FF (or $0400-$07FF);
		   4: Select 1 KB CHR bank at PPU $1800-$1BFF (or $0800-$0BFF);
		   5: Select 1 KB CHR bank at PPU $1C00-$1FFF (or $0C00-$0FFF);
*/
	if ( doChr ) {
		this.mainboard.synchroniser.synchronise();
		
		var bank0 = this.banks[0] & 0xFE;
		var bank1 = this.banks[1] & 0xFE;
		
		// RAMBO-1 supports a full 1k chr bank mode in addition to the 2kb/1kb bank swap
		switch ( this.bankSwapByte & 0xA0 ) {
			case 0x00: // 2 KiB switchable CHR banks at $0000, $0800; 1 KiB switchable CHR banks at $1000, $1400, $1800, $1C00
				this.switch1kChrBank( bank0, 0 );
				this.switch1kChrBank( bank0 + 1, 1 );
				this.switch1kChrBank( bank1, 2 );
				this.switch1kChrBank( bank1 + 1, 3 );
				this.switch1kChrBank( this.banks[2], 4 );
				this.switch1kChrBank( this.banks[3], 5 );
				this.switch1kChrBank( this.banks[4], 6 );
				this.switch1kChrBank( this.banks[5], 7 );
			break;
			case 0x20: // 1 KiB switchable CHR banks at $0000, $0400, $0800, $0C00, $1000, $1400, $1800, $1C00
				this.switch1kChrBank( this.banks[0], 0 );
				this.switch1kChrBank( this.banks[8], 1 );
				this.switch1kChrBank( this.banks[1], 2 );
				this.switch1kChrBank( this.banks[9], 3 );
				this.switch1kChrBank( this.banks[2], 4 );
				this.switch1kChrBank( this.banks[3], 5 );
				this.switch1kChrBank( this.banks[4], 6 );
				this.switch1kChrBank( this.banks[5], 7 );
			break;
			case 0x80: // 2 KiB switchable CHR banks at $1000, $1800; 1 KiB switchable CHR banks at $0000, $0400, $0800, $0C00
				this.switch1kChrBank( this.banks[2], 0 );
				this.switch1kChrBank( this.banks[3], 1 );
				this.switch1kChrBank( this.banks[4], 2 );
				this.switch1kChrBank( this.banks[5], 3 );
				this.switch1kChrBank( bank0, 4 );
				this.switch1kChrBank( bank0 + 1, 5 );
				this.switch1kChrBank( bank1, 6 );
				this.switch1kChrBank( bank1 + 1, 7 );
			break;
			case 0xA0: // 0x80 + 0x20 =  // 1 KiB switchable CHR banks at $0000, $0400, $0800, $0C00, $1000, $1400, $1800, $1C00
				this.switch1kChrBank( this.banks[2], 0 );
				this.switch1kChrBank( this.banks[3], 1 );
				this.switch1kChrBank( this.banks[4], 2 );
				this.switch1kChrBank( this.banks[5], 3 );
				this.switch1kChrBank( this.banks[0], 4 );
				this.switch1kChrBank( this.banks[8], 5 );
				this.switch1kChrBank( this.banks[1], 6 );
				this.switch1kChrBank( this.banks[9], 7 );	
			break;
		}
	}
};


mapper64.prototype.reset = function() {
	this.prgRamDisableWrite = false;
	this.chipEnable = this.interruptsEnabled = true;
	this._interruptInProgress = false;

	this._A12LowerLimit = ( COLOUR_ENCODING_VBLANK_SCANLINES ) * MASTER_CYCLES_PER_SCANLINE;
	this._A12UpperLimit = ( COLOUR_ENCODING_FRAME_SCANLINES - 1 ) * MASTER_CYCLES_PER_SCANLINE;
		

	this.lastA12Raise = 0;

	this.mSpriteAddress = this.mScreenAddress = false;
	this.mRenderingEnabled = false;
	this.irqCounter = 0xFF;
	this.irqLatch = 0xFF;
	this.mReloadFlag = false;
	this.lastA12Raise = 0;
	this._cpuCycleMode = false;
	this.bankSwapByte = 0;
	this.banks[0] = 0;
	this.banks[1] = 2;
	this.banks[2] = 4;
	this.banks[3] = 5;
	this.banks[4] = 6;
	this.banks[5] = 7;

	this.banks[6] = 0;
	this.banks[7] = 1;
	
	this.banks[8] = 2;
	this.banks[9] = 3;
	// inbetween banks not used
	this.banks[15] = this.get8kPrgBankCount()-2;
	
	if ( this.get1kChrBankCount() === 0 ) {
		this.useVRAM( 8 );
	}
	
	var that = this;
	// TODO: Need to remove this event on mapper unload
	this._irqEventId = this.mainboard.synchroniser.addEvent( 'mapper64 irq', -1, function() { that._eventIrq(); } );
	
	this.syncBanks( true, true );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper64.prototype.write8PrgRom = function( offset, data ) {
	
	var top3Bits = offset & 0xE000;
	switch ( top3Bits ) {
		case 0x8000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even
				if ( this.bankSwapByte !== data & 0xFF ) {
					this.bankSwapByte = data & 0xFF;
					this.syncBanks( true, true );
				}
			}
			else
			{ // odd
				var swapByte = this.bankSwapByte & 0xF;
				if ( this.banks[ swapByte ] !== data & 0xFF ) {
					this.banks[ swapByte ] = data & 0xFF;
					var isPrgSwap = swapByte === 6 || swapByte === 7 || swapByte === 15;
					var isChrSwap = swapByte <= 5 || swapByte === 8 || swapByte === 9;
					this.syncBanks( isPrgSwap, isChrSwap );
				}
			}
		break;
		case 0xA000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even
				var mirroringMethod = ( data & 0x1 ) > 0 ? PPU_MIRRORING_HORIZONTAL : PPU_MIRRORING_VERTICAL;
				if ( mirroringMethod !== this.mainboard.ppu.getMirroringMethod() ) {
					this.mainboard.synchroniser.synchronise();
					this.mainboard.ppu.changeMirroringMethod( mirroringMethod );
				}
			}
			else
			{ // odd
				this.prgRamDisableWrite = ( data & 0x40 ) > 0;
				this.chipEnable = ( data & 0x80 ) > 0;
			}
		break;
		case 0xC000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even
				if ( this.irqLatch !== data ) {
					this.mainboard.synchroniser.synchronise();
				}
				this.irqLatch = data;
			}
			else
			{ // odd // RAMBO-1: Writing to this register also clears the IRQ counter so that it will be reloaded at next clock,
				// or the next scanline, depending on the selected mode. This also resets the prescaler in cycle mode, so the next clock will occur 4 cycles later.
				if ( !this.mReloadFlag ) {
					this.mainboard.synchroniser.synchronise();
				}
				this.mReloadFlag = true;
				this._cpuCycleMode = ( data & 0x1 ) > 0;
				// if ( this._cpuCycleMode ) {
					// console.log( "Mapper 64 cpu cycle mode is active" );
				// } else {
					// console.log( "Mapper 64 cpu cycle mode is inactive" );
				// }
			}
			this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
		break;
		case 0xE000:
			if ( ( offset & 0x1 ) === 0 )
			{ // even - "Writing any value to this register will disable MMC3 interrupts AND acknowledge any pending interrupts."
				this.interruptsEnabled = false;
				if ( this._interruptInProgress ) {
					this.mainboard.cpu.holdIrqLineLow( false );
					this._interruptInProgress = false;
				}
//				Log::Write( LOG_MAPPER, ( boost::format( "Interrupts disabled on mapper" ) ).str() );
			}
			else
			{ // odd
				if ( !this.interruptsEnabled ) {
					this.mainboard.synchroniser.synchronise();
				}
				this.interruptsEnabled = true;
//				Log::Write( LOG_MAPPER, ( boost::format( "Interrupts enabled on mapper" ) ).str() );
			}
			this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
		break;
	}
};

mapper64.prototype.decrementIrqCounter = function( tickCount ) {

	this.lastA12Raise = tickCount;
	var doIrq = false;
	
	if ( this.mReloadFlag )
	{
		//doIrq = this.irqLatch === 0;// MMC3 revA behaviour
		this.irqCounter = this.irqLatch + 1;
		this.mReloadFlag = false;
		
	}
	else if ( this.irqCounter === 0 ) {
		this.irqCounter = this.irqLatch;
		//if ( this.irqCounter === 0 )
		//	doIrq = true;
	}
	else
	{
		if ( this.irqCounter > 0 )
			this.irqCounter--;
		doIrq = this.irqCounter === 0;
	}
	
	if ( doIrq && this.interruptsEnabled && !this._interruptInProgress ) {
		//console.log( "[" + this.mainboard.ppu.frameCounter + "]" + pos.x + "x" + pos.y + " IRQ cpu: " + cpupos.x + "x" + cpupos.y );
		this._interruptInProgress = true;
		this.mainboard.cpu.holdIrqLineLow( true );
	}
};

mapper64.prototype.ppuA12Latch = function() {
	this.mainboard.synchroniser.synchronise();
	this.decrementIrqCounter( this.mainboard.synchroniser.getCpuMTC() );
	this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
};


mapper64.prototype.calculateNextA12Raise = function( cpuMTC ) {

	// TODO: refactor this - could be more efficient
	var pixelEvent = -1;
	var firstScanline = 0;
	if ( this.mRenderingEnabled )
	{
		if ( this.mSpriteAddress && !this.mScreenAddress )
		{
			pixelEvent = 265; // 260
			firstScanline = 0;
		}
		// else if ( this.mSpriteAddress && this.mScreenAddress )
		// {
			// pixelEvent = 340;//324;
			// firstScanline = -1;
		// }
		else //if ( this.mScreenAddress && !this.mSpriteAddress )
		{
			pixelEvent = 9;// 324; // 9;
			firstScanline = 0;// -1;
		}
	}

	if ( cpuMTC >= this._A12UpperLimit || pixelEvent < 0 ) {
		return -1;
	}

	var modmtc = cpuMTC % MASTER_CYCLES_PER_SCANLINE; // ticks from the start of the current scanline
	var scanlineEvent = MASTER_CYCLES_PER_PPU * pixelEvent; // ticks from the start of the scanline when IRQ is decremented

	var startMtc = cpuMTC - modmtc + scanlineEvent; // ticks till next irq decrement event

	if ( startMtc <= cpuMTC )
		startMtc += MASTER_CYCLES_PER_SCANLINE; // if we have already passed the irq event, move onto next scanline
	if ( this._A12UpperLimit <= startMtc )
		return -1;

	if ( startMtc < this._A12LowerLimit )
		startMtc = this._A12LowerLimit + scanlineEvent;

	return startMtc;
};


mapper64.prototype.updateIRQTime = function( cpuTime, doSync ) {

	if ( doSync ) {
		this.mainboard.synchroniser.synchronise();
	}
	
	var newEvent = -1;
	
	if ( !this._cpuCycleMode ) {
		// tickLimit is the start of the rendering frame - only started being clocked when rendering
		
		var nextRaise = 0;
		var scanlines = 0;
		if ( this.interruptsEnabled ) {
			nextRaise = this.calculateNextA12Raise( cpuTime );
			if ( nextRaise === -1 ) {
				newEvent = -1;
			} else {
				scanlines = this.mReloadFlag ? 0 : Math.max( this.irqCounter - 1, 0 );
				newEvent = nextRaise + ( scanlines * MASTER_CYCLES_PER_SCANLINE );
				if ( newEvent > this._A12UpperLimit ) {
					newEvent = -1;
				} else {
					// RAMBO-1: The actual interrupt triggers one M2 cycle later than one would naively expect.
					newEvent += COLOUR_ENCODING_MTC_PER_CPU;
				}
			}
		}
		this.mainboard.synchroniser.changeEventTime( this._irqEventId, newEvent );
	} else {
		var nextDecrement = 0;
		var count = 0;
		if ( this.interruptsEnabled ) {
			nextDecrement = this.calculateNextCpuCycleDecrement( cpuTime );
			if ( nextDecrement === -1 ) {
				newEvent = -1;
			} else {
				count = this.mReloadFlag ? 0 : Math.max( this.irqCounter - 1, 0 );
				newEvent = nextDecrement + ( count * ( COLOUR_ENCODING_MTC_PER_CPU * 4 ) ) + COLOUR_ENCODING_MTC_PER_CPU; // RAMBO-1: The actual interrupt triggers one M2 cycle later than one would naively expect.
			}
		}
		this.mainboard.synchroniser.changeEventTime( this._irqEventId, newEvent );
	}
};


mapper64.prototype.spriteScreenEnabledUpdate = function( spriteAddress, screenAddress ) {
	this.mSpriteAddress = spriteAddress;
	this.mScreenAddress = screenAddress;
	this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
};

mapper64.prototype.renderingEnabledChanged = function( enabled ) {
	this.mRenderingEnabled = enabled;
	this.updateIRQTime( this.mainboard.synchroniser.getCpuMTC(), true );
};


mapper64.prototype.calculateNextCpuCycleDecrement = function( startTicks ) {
	var interval = ( COLOUR_ENCODING_MTC_PER_CPU * 4 );
	var nextDecrementDiff = startTicks % interval;
	var nextDecrement = startTicks + ( interval - nextDecrementDiff );
	return nextDecrement;
};


mapper64.prototype.synchronise = function( startTicks, endTicks ) {

	if ( !this._cpuCycleMode ) {
		/*
	The heart of the MMC3. The PPU will cause A12 to rise when it fetches CHR from the right pattern table ($1xxx).
	In "normal" conditions (BG uses $0xxx, all sprites use $1xxx), this will occur 8 times per scanline (once for each sprite).
	However the BG could also be the culprit (if BG uses $1xxx and all sprites use $0xxx -- ?as seen in Armadillo?), in which case A12 will rise 34 times.
	These 42 times per scanline are key times which I call "rise points":

	BG rise points: 4, 12, 20, ... , 244, 252
	Sp rise points: 260, 268, ..., 308, 316
	BG rise points: 324, 332 
		
	If sprites are set to $1000-1FFF and the background is set to $0000-0FFF, then A12 will change from 0 to 1 at cycle 260 of each scanline, then change from 1 to 0 at cycle 320 of each scanline.

	If sprites are set to $0000-0FFF and the background is set to $1000-1FFF, then A12 will change from 1 to 0 at cycle 256 of each scanline, then change from 0 to 1 at cycle 324 of each scanline. 
	*/
		// tickLimit is the start of the rendering frame - only started being clocked when rendering
		var startMtc = this.calculateNextA12Raise( startTicks+1 );
		if ( startMtc >= 0 )
		{
			for ( var mtc = startMtc; mtc <= Math.min( this._A12UpperLimit, endTicks ); mtc += MASTER_CYCLES_PER_SCANLINE )
			{
				this.decrementIrqCounter( mtc );
			}
		}
	} else {
		// in cpu mode, decrement occurs every 4 cpu cycles
		var nextDecrement = this.calculateNextCpuCycleDecrement( startTicks );
		for ( var mtc = nextDecrement; mtc <= endTicks; mtc += ( COLOUR_ENCODING_MTC_PER_CPU * 4 ) )
		{
			this.decrementIrqCounter( mtc );
		}
	}
	this.updateIRQTime( endTicks, false );
};

mapper64.prototype.onEndFrame = function() {
	this.lastA12Raise = 0;
};

mapper64.prototype.write8SRam = function( offset, data ) {

	if ( this.chipEnable && !this.prgRamDisableWrite ) {
		Nes.basemapper.prototype.write8SRam.call( this, offset, data );
	}
};

mapper64.prototype.read8SRam = function( offset ) {

	if ( this.chipEnable ) {
		return Nes.basemapper.prototype.read8SRam.call( this, offset );
	}
	return 0;
};


Nes.mappers[64] = mapper64;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

	
var mapper65 = function() {
};

mapper65.prototype = Object.create( Nes.basemapper.prototype );

mapper65.prototype.reset = function() {

	this._irqEnabled = false;
	this._irqCounter = 0;
	this._irqReload = 0;
	this._nextIrqRaise = -1;
	
	this.switch8kPrgBank( 0, 0 );
	this.switch8kPrgBank( 1, 1 );
	this.switch8kPrgBank( 0xFE, 2 );
	this.switch8kPrgBank( this.get8kPrgBankCount() - 1, 3 );
	this.switch8kChrBank( this.get8kChrBankCount() - 1 );
	
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
	
	// TODO: Need to remove this event on mapper unload
	var that = this;
	this._irqEventId = this.mainboard.synchroniser.addEvent( 'mapper65 irq', -1, function() {} );
};

mapper65.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	
	switch ( offset & 0xF000 ) {
		case 0x8000: // prg select
			this.switch8kPrgBank( data, 0 );
		break;
		case 0x9000: // irq / mirroring registers
		{
			switch ( offset ) {
			case 0x9001: //Mirroring
				if ( ( data & 0x80 ) === 0 ) {
					this.mainboard.ppu.changeMirroringMethod( PPU_MIRRORING_VERTICAL );
				} else {
					this.mainboard.ppu.changeMirroringMethod( PPU_MIRRORING_HORIZONTAL );
				}
				break;
			case 0x9003: //IRQ Enable
				this._irqEnabled = ( data & 0x80 ) > 0;
				this.mainboard.cpu.holdIrqLineLow( false );
				break;
			case 0x9004: //IRQ Reload
				this._irqCounter = this._irqReload * COLOUR_ENCODING_MTC_PER_CPU;
				this.mainboard.cpu.holdIrqLineLow( false );
				var nextIrqRaise = -1;
				if ( this._irqEnabled ) {
					nextIrqRaise = this.mainboard.synchroniser.getCpuMTC() + this._irqCounter;
				}
				if ( nextIrqRaise !== this._nextIrqRaise ) {
					this.mainboard.synchroniser.changeEventTime( this._irqEventId, nextIrqRaise );
					this._nextIrqRaise = nextIrqRaise;
				}
				break;
			case 0x9005: //High 8 bits of IRQ Reload
				this._irqReload = ( this._irqReload & 0xFF ) | ( data << 8 );
				break;
			case 0x9006: //Low 8 bits of IRQ Reload
				this._irqReload = ( this._irqReload & 0xFF00 ) | data;
				break;
			}
		}
		break;
		case 0xA000: // prg select
			this.switch8kPrgBank( data, 1 );
		break;
		case 0xB000: // chr registers
		{
			var chrBank = offset & 0x7;
			this.switch1kChrBank( data, chrBank );
		}
		break;
		case 0xC000: // prg select
			this.switch8kPrgBank( data, 2 );
		break;
	}
};


mapper65.prototype.synchronise = function( startTicks, endTicks ) {

	if ( this._irqEnabled ) {
		this._irqCounter -= ( endTicks - startTicks );
		if ( this._irqCounter <= 0 ) {
			this.mainboard.synchroniser.changeEventTime( this._irqEventId, -1 );
			this.mainboard.cpu.holdIrqLineLow( true );
			this._irqCounter = 0;
			this._irqEnabled = false;
		}
	}
};


Nes.mappers[65] = mapper65;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

	
var mapper66 = function() {
};

mapper66.prototype = Object.create( Nes.basemapper.prototype );

mapper66.prototype.reset = function() {

	this.switch32kPrgBank( this.get32kPrgBankCount() - 1 );
	this.switch8kChrBank( this.get8kChrBankCount() - 1 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper66.prototype.write8PrgRom = function( offset, data ) {

	this.mainboard.synchroniser.synchronise();
	this.switch8kChrBank( data & 0x3 );
	this.switch32kPrgBank( ( data & 0x30 ) >> 4 );
};
	
Nes.mappers[66] = mapper66;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var mapper71 = function() {
};

mapper71.prototype = Object.create( Nes.basemapper.prototype );

mapper71.prototype.reset = function() {

	this._isFireHawk = this.mainboard.cart.getHash() === "334781C830F135CF30A33E392D8AAA4AFDC223F9";
	this.useVRAM();
	this.switch32kPrgBank( this.get32kPrgBankCount() - 1 );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper71.prototype.write8PrgRom = function( offset, data ) {
	
	if ( ( offset & 0xC000 ) === 0x8000 ) { // IS_INT_BETWEEN( offset, 0x8000, 0xC000 ) ) {
		// fire hawk only - Select 1 KiB CIRAM bank for PPU $2000-$2FFF
		if ( this._isFireHawk ) {
			//fire hawk is only game with mapper controlled mirroring
			//micro machines glitches hard if this is on
			var mirroringMethod = ( data & 0x10 ) > 0 ? PPU_MIRRORING_SINGLESCREEN_NT1 : PPU_MIRRORING_SINGLESCREEN_NT0;
			this.mainboard.synchroniser.synchronise();
			this.mainboard.ppu.changeMirroringMethod( mirroringMethod );
		}
	}
	else
	{
		// Select 16 KiB PRG ROM bank for CPU $8000-$BFFF
		this.mainboard.synchroniser.synchronise();
		this.switch16kPrgBank( data & 0xF, true );
	}
};


Nes.mappers[71] = mapper71;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

(function(){
	"use strict";
	
		

	var mapper78 = function() {
	};
	
	mapper78.prototype = Object.create( Nes.basemapper.prototype );

	mapper78.prototype.reset = function() {
	
		this.switch16kPrgBank( 0, true );
		this.switch16kPrgBank( this.get16kPrgBankCount() - 1, false );
	//     "   - The first 8K VROM bank may or may not be swapped into $0000 when
    //       the cart is reset. I have no ROM images to test."
		this.switch8kChrBank( 0 );
		this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
	};
	
	mapper78.prototype.write8PrgRom = function( offset, data ) {
	
		this.mainboard.synchroniser.synchronise();
		this.switch16kPrgBank( data & 0xF, true );
		this.switch8kChrBank( ( data & 0xF0 ) >> 4 );
	};
		
	Nes.mappers[78] = mapper78;
	

	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

(function(){
	"use strict";
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	var mapper79 = function() {


	};
	
	mapper79.prototype = Object.create( Nes.basemapper.prototype );

	mapper79.prototype.reset = function() {
	
		this.switch32kPrgBank( this.get32kPrgBankCount() - 1 );
		this.switch8kChrBank( this.get8kChrBankCount() - 1 );
		this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
	};

	mapper79.prototype.write8EXRam = function( offset, data ) {
	
		if ( ( offset & 0x4100 ) === 0x4100 ) {
			this.mainboard.synchroniser.synchronise();
			this.switch32kPrgBank( ( data & 0x8 ) >> 3 );
			this.switch8kChrBank( data & 0x7 );
		}
		//Nes.basemapper.prototype.write8EXRam.call( this, offset, data );
	};
	
	Nes.mappers[79] = mapper79;
	
	
}());

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var mapper180 = function() {
};

mapper180.prototype = Object.create( Nes.basemapper.prototype );

mapper180.prototype.reset = function() {
	this.switch16kPrgBank( 0, true );
	this.switch16kPrgBank( this.get16kPrgBankCount() - 1, false );
	this.useVRAM();
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper180.prototype.write8PrgRom = function( offset, data ) {
//	this.mainboard.synchroniser.synchronise();
	this.switch16kPrgBank( data, false );
};

Nes.mappers[180] = mapper180;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var mapper206 = function() {
	this.bankSwapByte = 0;

	this.banks = new Int32Array( 8 );
	this.banks[0] = 0;
	this.banks[1] = 2;
	this.banks[2] = 4;
	this.banks[3] = 5;
	this.banks[4] = 6;
	this.banks[5] = 7;

	this.banks[6] = 0;
	this.banks[7] = 1;
};

mapper206.prototype = Object.create( Nes.basemapper.prototype );

mapper206.prototype.mapperSaveState = function( state ) {
	
	state.bankSwapByte = this.bankSwapByte;
	state.banks = Nes.uintArrayToString( this.banks );
};

mapper206.prototype.mapperLoadState = function( state ) {

	this.bankSwapByte = state.bankSwapByte;
	this.banks = Nes.stringToUintArray( state.banks );
};

mapper206.prototype.syncBanks = function( doPrg, doChr ) {

	if ( doPrg ) {
		this.switch8kPrgBank( this.banks[7] & 0xF, 1 );
		this.switch8kPrgBank( this.get8kPrgBankCount() - 2, 2 );
		this.switch8kPrgBank( this.get8kPrgBankCount() - 1, 3 );

		// if ( ( this.bankSwapByte & 0x40 ) > 0 )
		// {
			// this.switch8kPrgBank( this.get8kPrgBankCount() - 2, 0 );
		// }
		// else
		// {
			this.switch8kPrgBank( this.banks[6] & 0xF, 0 );
		//}
	}
/*
		   0: Select 2 KB CHR bank at PPU $0000-$07FF (or $1000-$17FF);
		   1: Select 2 KB CHR bank at PPU $0800-$0FFF (or $1800-$1FFF);
		   2: Select 1 KB CHR bank at PPU $1000-$13FF (or $0000-$03FF);
		   3: Select 1 KB CHR bank at PPU $1400-$17FF (or $0400-$07FF);
		   4: Select 1 KB CHR bank at PPU $1800-$1BFF (or $0800-$0BFF);
		   5: Select 1 KB CHR bank at PPU $1C00-$1FFF (or $0C00-$0FFF);
*/
	if ( doChr ) {
		this.mainboard.synchroniser.synchronise();
		
		var bank0 = this.banks[0] & 0x3E;
		var bank1 = this.banks[1] & 0x3E;

		this.switch1kChrBank( bank0, 0 );
		this.switch1kChrBank( bank0 + 1, 1 );
		this.switch1kChrBank( bank1, 2 );
		this.switch1kChrBank( bank1 + 1, 3 );

		this.switch1kChrBank( this.banks[2] & 0x3F, 4 );
		this.switch1kChrBank( this.banks[3] & 0x3F, 5 );
		this.switch1kChrBank( this.banks[4] & 0x3F, 6 );
		this.switch1kChrBank( this.banks[5] & 0x3F, 7 );
	}
};


mapper206.prototype.reset = function() {

	this.bankSwapByte = 0;
	this.banks[0] = 0;
	this.banks[1] = 2;
	this.banks[2] = 4;
	this.banks[3] = 5;
	this.banks[4] = 6;
	this.banks[5] = 7;

	this.banks[6] = 0;
	this.banks[7] = 1;
	
	if ( this.get1kChrBankCount() === 0 ) {
		this.useVRAM( 8 );
	}
	
	this.syncBanks( true, true );
	this.mainboard.ppu.changeMirroringMethod( this.mirroringMethod );
};

mapper206.prototype.write8PrgRom = function( offset, data ) {
	
	if ( ( offset & 0x1 ) === 0 )
	{ // even
		if ( this.bankSwapByte !== data & 0xFF ) {
			this.bankSwapByte = data & 0xFF;
			this.syncBanks( true, true );
		}
	}
	else
	{ // odd
		var swapByte = this.bankSwapByte & 0x7;
		if ( this.banks[ swapByte ] !== data & 0xFF ) {
			this.banks[ swapByte ] = data & 0xFF;
			this.syncBanks( swapByte >= 6, swapByte <= 5 );
		}
	}
};


mapper206.prototype.synchronise = function( startTicks, endTicks ) {

};

mapper206.prototype.onEndFrame = function() {
};


Nes.mappers[206] = mapper206;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var calculateSha1 = function( binaryArray, startIndex ) {

	try {
		startIndex = startIndex || 0;
		var r = new Rusha( binaryArray.length - startIndex );
		// Using a subarray doesn't work. Need to copy contents into a new array (bit shit but it works)
	//	var sha1 = r.digestFromArrayBuffer( binaryArray.subarray( startIndex ).buffer ).toUpperCase();
		var buf = [];
		for ( var i=startIndex; i<binaryArray.length; ++i ) {
			buf.push( binaryArray[i] );
		}
		var sha1 = r.digestFromBuffer( buf ).toUpperCase();
		while ( sha1.length < 40 ) {
			sha1 = '0' + sha1;
		}
		return sha1;
	}
	catch ( err ) {
		console.error( err );
		console.log( err.stack );
	}
};

Nes.calculateSha1 = calculateSha1;



var dbLookup = function( shaString, callback ) {

	if ( shaString.length !== 40 ) {
		throw new Error( "dbLookup : SHA1 must be 40 characters long! [" + shaString + "]" );
	}

	var path = 'js/db/' + shaString + '.js';
	var data;
	$.getScript( path ).always(function() {
		callback( null, window['NesDb'] ? window['NesDb'][ shaString ] : null );
	} );
};


Nes.dbLookup = dbLookup;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var codes = {
	'A': 0x00, // 0000
	'P': 0x01, // 0001
	'Z': 0x02, // 0010
	'L': 0x03, // 0011
	'G': 0x04, // 0100
	'I': 0x05, // 0101
	'T': 0x06, // 0110
	'Y': 0x07, // 0111
	'E': 0x08, // 1000
	'O': 0x09, // 1001
	'X': 0x0A, // 1010
	'U': 0x0B, // 1011
	'K': 0x0C, // 1100
	'S': 0x0D, // 1101
	'V': 0x0E, // 1110
	'N': 0x0F // 1111
};

var ggcodeArray = new Int32Array( 8 );


var stringToCodeArray = function( codeString ) {

	for ( var i=0; i<codeString.length; ++i ) {
		var code = codes[ codeString[ i ] ];
		if ( code === undefined ) {
			throw new Error( "Invalid character in game genie code" );
		}
		ggcodeArray[i] = code;
	}
	return ggcodeArray;
};


var processGameGenieCode = function( mainboard, codeString, enable ) {

	if ( codeString.length !== 6 && codeString.length !== 8 ) {
		throw new Error( "Invalid game genie code entered '" + codeString + "'" );
	}
	
	if ( enable ) {
		var code = stringToCodeArray( codeString );
		
		// Char # |   0   |   1   |   2   |   3   |   4   |   5   |
		// Bit  # |3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|
		// maps to|1|6|7|8|H|2|3|4|-|I|J|K|L|A|B|C|D|M|N|O|5|E|F|G|
		if ( codeString.length === 6 ) {
			var value = ( code[0] & 0x7 ); // 678
			value |= ( code[5] & 0x8 ) // 5
			value |= ( code[1] & 0x7 ) << 4; // 234
			value |= ( code[0] & 0x8 ) << 4; // 1
			
			var address = ( code[4] & 0x7 ); // MNO
			address |= ( code[3] & 0x8 ); // L
			address |= ( code[2] & 0x7 ) << 4; // IJK
			address |= ( code[1] & 0x8 ) << 4; // H
			address |= ( code[5] & 0x7 ) << 8; // EFG
			address |= ( code[4] & 0x8 ) << 8; // D
			address |= ( code[3] & 0x7 ) << 12; // ABC
			
			mainboard.cart.memoryMapper.gameGeniePoke( codeString, address + 0x8000, value, -1 );
			
		} else if ( codeString.length === 8 ) {
			// Note: Similar to 6 character code but '5' is in different place
			// Char # |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |	
			// Bit  # |3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|3|2|1|0|
			// maps to|1|6|7|8|H|2|3|4|-|I|J|K|L|A|B|C|D|M|N|O|%|E|F|G|!|^|&|*|5|@|#|$|
			// compareValue = !@#$%^&*
			var value = ( code[0] & 0x7 ); // 678
			value |= ( code[7] & 0x8 ) // 5
			value |= ( code[1] & 0x7 ) << 4; // 234
			value |= ( code[0] & 0x8 ) << 4; // 1
			
			var address = ( code[4] & 0x7 ); // MNO
			address |= ( code[3] & 0x8 ); // L
			address |= ( code[2] & 0x7 ) << 4; // IJK
			address |= ( code[1] & 0x8 ) << 4; // H
			address |= ( code[5] & 0x7 ) << 8; // EFG
			address |= ( code[4] & 0x8 ) << 8; // D
			address |= ( code[3] & 0x7 ) << 12; // ABC
			
			var compareValue = ( code[6] & 0x7 ); // ^&*
			compareValue |= ( code[5] & 0x8 ); // %
			compareValue |= ( code[7] & 0x7 ) << 4; // @#$
			compareValue |= ( code[6] & 0x8 ) << 4; // !
			
			// It then checks the value to be replaced with the compare
			// value, if they are the same it replaces the original value with the new
			// value if not the value remains the same.
			mainboard.cart.memoryMapper.gameGeniePoke( codeString, address + 0x8000, value, compareValue );
		}
	} else {
		mainboard.cart.memoryMapper.removeGameGeniePoke( codeString );
	}
};


Nes.processGameGenieCode = processGameGenieCode;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


var cartridge = function( mainboard ) {

	this.mainboard = mainboard;
	this.memoryMapper = null;
	this._sha1 = '';
	this._name = '';
	this._dbData = null;
	this._colourEncodingType = g_DefaultColourEncoding;
};


cartridge.prototype.areGameGenieCodesAvailable = function() {

	return !!( this._dbData && this._dbData['gameGenieCodes'] && this._dbData['gameGenieCodes'].length > 0 );
};


cartridge.prototype.loadRom = function( name, rawBinaryString, completeCallback ) {

	var that = this;

	try {
		Nes.decompressIfNecessary( name, rawBinaryString, function( err, binaryString ) {
			if ( err ) {
				completeCallback( err );
			} else {
				that._loadData( name, binaryString, completeCallback );
			}
		} );
	}
	catch ( err ) {
		completeCallback( err );
	}
};


var getHighestFrequencyElement = function( map ) {
	var mostFrequent = null;
	var frequency = 0;
	for ( var mapperId in map ) {
		if ( map.hasOwnProperty( mapperId ) ) {
			if ( map[ mapperId ] > frequency ) {
				frequency = map[ mapperId ];
				mostFrequent = mapperId;
			}
		}
	}
	return mostFrequent;
};


cartridge.prototype._getMapperFromDatabase = function( mapperIdFromInes ) {

	var mapperIdFrequency = {};
	if ( this._dbData && this._dbData['cartridge'] ) {
		var foundInesMapper = false;
		this._dbData['cartridge'].forEach( function( cart ) {
			if ( cart['board'] ) {
				cart['board'].forEach( function( board ) {
					if ( board['$']['mapper'] === mapperIdFromInes ) {
						// Mapper ID in iNes file has been found in database - use that
						foundInesMapper = true;
					} else {
						mapperIdFrequency[ board['$']['mapper'] ] = ( mapperIdFrequency[ board['$']['mapper'] ] + 1 ) || 1;
					}
				} );
			}
		} );
		if ( foundInesMapper ) {
			return mapperIdFromInes;
		}
		
		// iNes mapper was not found in DB - use the most likely mapper ID found
		var mostFrequentMapperId = getHighestFrequencyElement( mapperIdFrequency );
		if ( mostFrequentMapperId !== null ) {
			return parseInt( mostFrequentMapperId );
		} else {
			return null;
		}
	}
	return null;
};


cartridge.prototype._workOutColourEncodingFromFilename = function( filename ) {

	if ( filename.match( /[\[\(][E][\]\)]/i ) ) {
		return 'PAL';
	} else if ( filename.match( /[\[\(][JU][\]\)]/i ) ) {
		return 'NTSC';
	} else {
		return g_DefaultColourEncoding;
	}
};


cartridge.prototype._determineColourEncodingType = function( filename ) {
	
	// look in database	
	var stringStartsWith = function( str, test ) {
		return str.slice( 0, test.length ) === test;
	};
	
	var systemFrequency = {};
	if ( this._dbData && this._dbData['cartridge'] ) {
		this._dbData['cartridge'].forEach( function( cart ) {
			if ( cart['$']['system'] ) {
				var lower = cart['$']['system'].toLowerCase();

				if ( stringStartsWith( lower, 'nes-pal' ) ) {
					systemFrequency[ 'PAL' ] = systemFrequency[ 'PAL' ] || 0;
					systemFrequency[ 'PAL' ]++;
				} else {
					systemFrequency[ 'NTSC' ] = systemFrequency[ 'NTSC' ] || 0;
					systemFrequency[ 'NTSC' ]++;
				}
			}
		} );
		
		var mostFrequentType = getHighestFrequencyElement( systemFrequency );
		if ( mostFrequentType !== null ) {
			this._colourEncodingType = mostFrequentType;
			return;
		}
	}
	
	this._colourEncodingType = this._workOutColourEncodingFromFilename( filename );
};


cartridge.prototype.getName = function() {
	return this._name;
};


cartridge.prototype.getHash = function() {
	return this._sha1;
};


var create32IntArray = function( array, length ) {
	var a = new Int32Array( length );
	for ( var i=0; i<length; ++i ) {
		a[ i ] = array[i] | 0;
	}
	return a;
};


cartridge.prototype._loadData = function( name, binaryString, completeCallback ) {

	var that = this;
	try {
		this._name = name;
		
		var stringIndex = 0;
		var correctHeader = [ 78, 69, 83, 26 ];
		
		for ( var i=0; i<correctHeader.length; ++i )
		{
			if ( correctHeader[ i ] !== binaryString[ stringIndex++ ] )
				throw new Error( 'Invalid NES header for file!' );
		}

		var prgPageCount = binaryString[ stringIndex++ ];
		var chrPageCount = binaryString[ stringIndex++ ];
		var controlByte1 = binaryString[ stringIndex++ ];
		var controlByte2 = binaryString[ stringIndex++ ];
		
		if ( prgPageCount === 0 ) {
			prgPageCount = 1; // 0 means 1
		}
		
		var horizontalMirroring = (controlByte1 & 0x01) === 0;
		var sramEnabled = (controlByte1 & 0x02) > 0;
		var hasTrainer = (controlByte1 & 0x04) > 0;
		var fourScreenRamLayout = (controlByte1 & 0x08) > 0;
		
		var mirroringMethod = 0;
		if ( fourScreenRamLayout )
			mirroringMethod = PPU_MIRRORING_FOURSCREEN;
		else if ( !horizontalMirroring )
			mirroringMethod = PPU_MIRRORING_VERTICAL;
		else
			mirroringMethod = PPU_MIRRORING_HORIZONTAL;
			
		var mapperId = ( (controlByte1 & 0xF0) >> 4 ) | (controlByte2 & 0xF0);

		stringIndex = 16;
		if ( hasTrainer )
			stringIndex += 512;

		// calculate SHA1 on PRG and CHR data, look it up in the db, then load it
		this._sha1 = Nes.calculateSha1( binaryString, stringIndex );			
		console.log( "SHA1: " + this._sha1 );
	
		Nes.dbLookup( this._sha1, function( err, data ) {
			if ( err ) {
				completeCallback( err );
				return;
			}
			try {
				that._dbData = data;

				if ( that._dbData ) {
					that._name = that._dbData['$']['name'];
					console.log( "Game found in database: " + that._name );
				} else {
					console.log( "Game not found in database" );
				}
			
				var mapperFromDb = that._getMapperFromDatabase( mapperId );

				if ( mapperFromDb !== null && mapperFromDb !== mapperId ) {
					console.log( "Game has different mapper in database [" + mapperFromDb + "] from the iNes file [" + mapperId + "]. Using value from database..." );
					mapperId = mapperFromDb;
				}

				that.memoryMapper = Nes.createMapper( mapperId, that.mainboard, mirroringMethod );
				
				// read in program code
				var prg8kChunkCount = prgPageCount * 2; // read in 8k chunks, prgPageCount is 16k chunks
				var prgSize = 0x2000 * prg8kChunkCount;
				that.memoryMapper.setPrgData( create32IntArray( binaryString.subarray( stringIndex, stringIndex + prgSize ), prgSize ), prg8kChunkCount );
				stringIndex += prgSize;
				
				// read in character maps
				var chr1kChunkCount = chrPageCount * 8; // 1kb per pattern table, chrPageCount is the 8kb count
				var chrSize = 0x400 * chr1kChunkCount;
				that.memoryMapper.setChrData( create32IntArray( binaryString.subarray( stringIndex, stringIndex + chrSize ), chrSize ), chr1kChunkCount );
				stringIndex += chrSize;
				
				// determine NTSC or PAL
				that._determineColourEncodingType( name );
				setColourEncodingType( that._colourEncodingType );
				var prgKb = prg8kChunkCount * 8;
				console.log( 'Cartridge \'' + name + '\' loaded. Mapper ' + mapperId + ', ' + Nes.mirroringMethodToString( mirroringMethod ) + ' mirroring, ' + prgKb + 'kb PRG, ' + chr1kChunkCount + 'kb CHR' );
				console.log( 'Encoding: ' + that._colourEncodingType );
				
				completeCallback();
			}
			catch ( err2 ) {
				completeCallback( err2 );
			}
		} );
	}
	catch ( err ) {
		completeCallback( err );
	}
};


cartridge.prototype.reset = function() {
	this.memoryMapper.reset();
};


Nes.cartridge = cartridge;

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";


///////////////////////////////////////////////////////////////////////////////////////
var g_ClearScreenArray = new Int32Array( SCREEN_WIDTH * SCREEN_HEIGHT );
for ( var ii=0; ii<g_ClearScreenArray.length; ++ii ) {
	g_ClearScreenArray[ ii ] = 0;
}


var renderbuffer = function( mainboard, renderSurface ) {
		
	this._mainboard = mainboard;
	this._renderSurface = renderSurface;
	// this.defaultPalette = [
		// [ 0x80,0x80,0x80 ], [ 0x00,0x3D,0xA6 ], [ 0x00,0x12,0xB0 ], [ 0x44,0x00,0x96 ],
		// [ 0xA1,0x00,0x5E ], [ 0xC7,0x00,0x28 ], [ 0xBA,0x06,0x00 ], [ 0x8C,0x17,0x00 ],
		// [ 0x5C,0x2F,0x00 ], [ 0x10,0x45,0x00 ], [ 0x05,0x4A,0x00 ], [ 0x00,0x47,0x2E ],
		// [ 0x00,0x41,0x66 ], [ 0x00,0x00,0x00 ], [ 0x05,0x05,0x05 ], [ 0x05,0x05,0x05 ],
		// [ 0xC7,0xC7,0xC7 ], [ 0x00,0x77,0xFF ], [ 0x21,0x55,0xFF ], [ 0x82,0x37,0xFA ],
		// [ 0xEB,0x2F,0xB5 ], [ 0xFF,0x29,0x50 ], [ 0xFF,0x22,0x00 ], [ 0xD6,0x32,0x00 ],
		// [ 0xC4,0x62,0x00 ], [ 0x35,0x80,0x00 ], [ 0x05,0x8F,0x00 ], [ 0x00,0x8A,0x55 ],
		// [ 0x00,0x99,0xCC ], [ 0x21,0x21,0x21 ], [ 0x09,0x09,0x09 ], [ 0x09,0x09,0x09 ],
		// [ 0xFF,0xFF,0xFF ], [ 0x0F,0xD7,0xFF ], [ 0x69,0xA2,0xFF ], [ 0xD4,0x80,0xFF ],
		// [ 0xFF,0x45,0xF3 ], [ 0xFF,0x61,0x8B ], [ 0xFF,0x88,0x33 ], [ 0xFF,0x9C,0x12 ],
		// [ 0xFA,0xBC,0x20 ], [ 0x9F,0xE3,0x0E ], [ 0x2B,0xF0,0x35 ], [ 0x0C,0xF0,0xA4 ],
		// [ 0x05,0xFB,0xFF ], [ 0x5E,0x5E,0x5E ], [ 0x0D,0x0D,0x0D ], [ 0x0D,0x0D,0x0D ],
		// [ 0xFF,0xFF,0xFF ], [ 0xA6,0xFC,0xFF ], [ 0xB3,0xEC,0xFF ], [ 0xDA,0xAB,0xEB ],
		// [ 0xFF,0xA8,0xF9 ], [ 0xFF,0xAB,0xB3 ], [ 0xFF,0xD2,0xB0 ], [ 0xFF,0xEF,0xA6 ],
		// [ 0xFF,0xF7,0x9C ], [ 0xD7,0xE8,0x95 ], [ 0xA6,0xED,0xAF ], [ 0xA2,0xF2,0xDA ],
		// [ 0x99,0xFF,0xFC ], [ 0xDD,0xDD,0xDD ], [ 0x11,0x11,0x11 ], [ 0x11,0x11,0x11 ]
	// ];
	
	var paletteArray = [ 0x808080, 0xA63D00, 0xB01200, 0x960044,
		0x5E00A1, 0x2800C7, 0x0006BA, 0x00178C,
		0x002F5C, 0x004510, 0x004A05, 0x2E4700,
		0x664100, 0x000000, 0x050505, 0x050505,
		0xC7C7C7, 0xFF7700, 0xFF5521, 0xFA3782,
		0xB52FEB, 0x5029FF, 0x0022FF, 0x0032D6,
		0x0062C4, 0x008035, 0x008F05, 0x558A00,
		0xCC9900, 0x212121, 0x090909, 0x090909,
		0xFFFFFF, 0xFFD70F, 0xFFA269, 0xFF80D4,
		0xF345FF, 0x8B61FF, 0x3388FF, 0x129CFF,
		0x20BCFA, 0x0EE39F, 0x35F02B, 0xA4F00C,
		0xFFFB05, 0x5E5E5E, 0x0D0D0D, 0x0D0D0D,
		0xFFFFFF, 0xFFFCA6, 0xFFECB3, 0xEBABDA,
		0xF9A8FF, 0xB3ABFF, 0xB0D2FF, 0xA6EFFF,
		0x9CF7FF, 0x95E8D7, 0xAFEDA6, 0xDAF2A2,
		0xFCFF99, 0xDDDDDD, 0x111111, 0x111111,
		0x000000 ];
	
	this.defaultPalette32BitVals = new Uint32Array( paletteArray.length );
	// var paletteArray = [ 0xFF808080, 0xFFA63D00, 0xFFB01200, 0xFF960044,
		// 0xFF5E00A1, 0xFF2800C7, 0xFF0006BA, 0xFF00178C,
		// 0xFF002F5C, 0xFF004510, 0xFF004A05, 0xFF2E4700,
		// 0xFF664100, 0xFF000000, 0xFF050505, 0xFF050505,
		// 0xFFC7C7C7, 0xFFFF7700, 0xFFFF5521, 0xFFFA3782,
		// 0xFFB52FEB, 0xFF5029FF, 0xFF0022FF, 0xFF0032D6,
		// 0xFF0062C4, 0xFF008035, 0xFF008F05, 0xFF558A00,
		// 0xFFCC9900, 0xFF212121, 0xFF090909, 0xFF090909,
		// 0xFFFFFFFF, 0xFFFFD70F, 0xFFFFA269, 0xFFFF80D4,
		// 0xFFF345FF, 0xFF8B61FF, 0xFF3388FF, 0xFF129CFF,
		// 0xFF20BCFA, 0xFF0EE39F, 0xFF35F02B, 0xFFA4F00C,
		// 0xFFFFFB05, 0xFF5E5E5E, 0xFF0D0D0D, 0xFF0D0D0D,
		// 0xFFFFFFFF, 0xFFFFFCA6, 0xFFFFECB3, 0xFFEBABDA,
		// 0xFFF9A8FF, 0xFFB3ABFF, 0xFFB0D2FF, 0xFFA6EFFF,
		// 0xFF9CF7FF, 0xFF95E8D7, 0xFFAFEDA6, 0xFFDAF2A2,
		// 0xFFFCFF99, 0xFFDDDDDD, 0xFF111111, 0xFF111111,
		// 0xFF000000 ]; // last value is tacked on for default black value - put in this array so the variable type is consistent and can be optimised better

	for ( var i=0; i<paletteArray.length; ++i ) {
		this.defaultPalette32BitVals[i] = paletteArray[i];
	}
	
	var that = this;
	this._clipTopAndBottomY = false;
	this._mainboard.connect( 'reset', function( cold ) { that._reset( cold ); } );
	this.priorityBuffer = new Int32Array( SCREEN_WIDTH * SCREEN_HEIGHT );
	this.clearBuffer();
};


renderbuffer.prototype._reset = function( cold ) {

	this._clipTopAndBottomY = COLOUR_ENCODING_NAME === "NTSC";
};


renderbuffer.prototype.clearBuffer = function() {

	this.priorityBuffer.set( g_ClearScreenArray );
};

renderbuffer.prototype.pickColour = function( paletteIndex ) {

	var pindex = 0;
	if ( paletteIndex < 64 ) {
		pindex = paletteIndex;
	} else {
		pindex = 64;
	}
	return  this.defaultPalette32BitVals[ pindex ];
};

renderbuffer.prototype._renderPixel = function( bufferIndex, insertIndex, y, paletteIndex ) {

	if ( this._clipTopAndBottomY && ( y < 8 || y > 231 ) ) {
		return;
	}
	
	var colour = this.pickColour( paletteIndex|0 );
	this._renderSurface.writeToBuffer( bufferIndex, insertIndex, colour );
};


renderbuffer.prototype.renderSpritePixelDebug = function( spritenum, x, y ) {

	//this._renderSurface.writeToBuffer( 2, x, y, 0xFFE92BFF );
};


renderbuffer.prototype.renderSpritePixel = function( spritenum, isBehind, x, y, paletteIndex ) {
	var index = y*SCREEN_WIDTH + x;
	var bufferIndex = isBehind ? 0 : 2;
	if (  this.priorityBuffer[ index ] === 0 ) {
		 this.priorityBuffer[ index] =  spritenum + 1 ;
		this._renderPixel( bufferIndex, index, y, paletteIndex );	
	}
};	


renderbuffer.prototype.renderPixel = function( x, y, paletteIndex ) {
	var hitzero = false;
	var index = y*SCREEN_WIDTH + x;
	if (  this.priorityBuffer[ index ] === 1 && x < (SCREEN_WIDTH-1) ) {
		hitzero = true;
	}
	this._renderPixel( 1, index, y, paletteIndex );
	return hitzero;
};


renderbuffer.prototype.saveState = function() {
	
	return { priorityBuffer: Nes.uintArrayToString( this.priorityBuffer ) };
};


renderbuffer.prototype.loadState = function( state ) {
	
	this.priorityBuffer = Nes.stringToUintArray( state.priorityBuffer );
};
	

Nes.renderbuffer = renderbuffer;

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Nes = this.Nes || {};

"use strict";

var mainboard = function( renderSurface ) {
	var that = this;
	this.running = false;
	this.cart = null;
	this._eventBus = new Nes.EventBus();
	
	this.memory = new Nes.memory( this );
	window.ppu = new Nes.ppu( this );
	this.ppu = window.ppu;
	this.apu = new Nes.ApuLegacy( this ); // Replace with Nes.Apu to use new (unfinished) APU
	this.inputdevicebus = new Nes.inputdevicebus();

	this.cpu = new Nes.cpu6502( this );
	//this.cpu.enableTrace( true );
	this.renderBuffer = new Nes.renderbuffer( this, renderSurface );

	this.synchroniser = new Nes.synchroniser( this );
	this.synchroniser.connect( 'frameEnd', function() { that._onFrameEnd(); } );
	this.synchroniser.addObject( 'ppu', this.ppu );
	this.synchroniser.addObject( 'apu', this.apu );

	this.ppu.hookSyncEvents( this.synchroniser );
	
	this.enableSound( true );
};


mainboard.prototype.connect = function( name, cb ) {
	this._eventBus.connect( name, cb );
};


mainboard.prototype.enableSound = function( enable ) {
	this.apu.enableSound( enable );
	this._eventBus.invoke( 'soundEnabled', this.apu.soundEnabled(), this.apu.soundSupported() );
};


mainboard.prototype.setVolume = function( val ) {
	this.apu.setVolume( val );
};


mainboard.prototype.setTraceOption = function( traceType, checked ) {
	
	if ( traceType === Nes.trace_all || traceType === Nes.trace_cpuInstructions ) {
		this.cpu.enableTrace( checked ); // cpu instructions require different code path, needs to be invoked seperately
	}
	Nes.Trace.enableType( traceType, checked );
};

	
mainboard.prototype._onFrameEnd = function() {
	this.running = false;
	this._eventBus.invoke( 'frameEnd' );
};


mainboard.prototype.doFrame = function() {
	if ( this.cart )
	{
		this.running = true;
		while ( this.running )
		{ // keep going until a frame is rendered
			this.synchroniser.runCycle();
		}
	}
};


mainboard.prototype.loadCartridge = function( cart ) {

	this.cart = cart;
	this.synchroniser.addObject( 'mapper', this.cart.memoryMapper );
	
	this.reset( true );
	this._eventBus.invoke( 'romLoaded', this.cart );
};


mainboard.prototype.powerButton = function( on ) {
	
	var isOn = on && this.cart;
	if ( isOn ) {
		this.reset();
	} else {
		this.running = false;
		this.cart = null;
	}
	this._eventBus.invoke( 'power', isOn );
};


mainboard.prototype.reset = function( cold ) {

	cold = cold === undefined ? true : cold;
	if ( this.cart )
		this.cart.reset( cold );
	this._eventBus.invoke( 'reset', cold );
};


mainboard.prototype.saveState = function() {

	var data = {};
	data.memory = this.memory.saveState();
	data.ppu = this.ppu.saveState();
	data.apu = this.apu.saveState();
//	data.joypad1 = this.joypad1.saveState();
	data.cpu = this.cpu.saveState();
	data.synchroniser = this.synchroniser.saveState();
	data.renderBuffer = this.renderBuffer.saveState();
	if ( this.cart && this.cart.memoryMapper ) {
		data.memoryMapper = this.cart.memoryMapper.saveState();
	}
	return data;
};


mainboard.prototype.loadState = function( data ) {

	this.memory.loadState( data.memory );
	this.ppu.loadState( data.ppu );
	this.apu.loadState( data.apu );
//	this.joypad1.loadState( data.joypad1 );
	this.cpu.loadState( data.cpu );
	this.renderBuffer.loadState( data.renderBuffer );
	this.synchroniser.loadState( data.synchroniser );
	if ( this.cart && this.cart.memoryMapper ) {
		this.cart.memoryMapper.loadState( data.memoryMapper );
	}
};


Nes.mainboard = mainboard;


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};
var animateFunction;


(function(){
	"use strict";

	
	var App = function() {
		var that = this;
		
		this._cart = null;
		this._romLoaded = false;
		this._mainboard = null;
		this._renderSurface = null;
		this._fpsMeter = null;
		this._spriteDisplay = null;
		this._paletteDisplay = null;
		this._logWindow = null;
		this._cpuInstructionsWindow = null;	
		this._input = null;
		this._encodingTypeToSet = '';
		this._newRomWaiting = false;
		this._newRomLoaded = { name: '', binaryString: null };
		this._eventBus = new Nes.EventBus();
		
		this._frameTimeTarget = 0;
		this._lastFrameTime = 0;
		this._gameSpeed = 100; // 100% normal speed
		
		this._isPaused = 0;
		this._pauseNextFrame = false;
		this._pauseOnFrame = -1;
		
		this._options = {};
		
		window.onerror = function(e) { that._showError( e ); };
	};
	
	
	App.prototype.connect = function( name, cb ) {
		
		this._eventBus.connect( name, cb );
	};
	
	
	App.prototype.setColourEncodingType = function( encodingType ) {
		
		this._encodingTypeToSet = encodingType;
	};
	

	App.prototype._loadRomCallback = function( name, binaryString ) {

		this._newRomWaiting = true;
		this._newRomLoaded = { name: name, binaryString: binaryString };
	};
	
	
	App.prototype.start = function( options ) {
	
		this._options = options || {};
		this._options.triggerFrameRenderedEvent = this._options.triggerFrameRenderedEvent === undefined ? false : this._options.triggerFrameRenderedEvent;
		this._options.createGuiComponents = this._options.createGuiComponents === undefined ? true : this._options.createGuiComponents;
	
		var that = this;

		if ( this._options.createGuiComponents ) {
			window.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
			
			this._fpsMeter = new FPSMeter( null, { top: '10%', left: '80%' } );
			this._fpsMeter.hide();
			Gui.hookDragDropEvents( function( name, binaryString ) { that._loadRomCallback( name, binaryString ); } );

			this._canvasParent = new Gui.CanvasParent();
			this._renderSurface = null;
			if ( WebGl.webGlSupported() ) {
				console.log( "Using WebGL for rendering..." );
				this._renderSurface = new Gui.WebGlRenderSurface( this._canvasParent );
				$('#postProcessingDiv').css( 'display', 'block' ); // Show shader drop list
			} else {
				console.log( "WebGL not supported. Using canvas for rendering..." );
				this._renderSurface = new Gui.CanvasRenderSurface( this._canvasParent );
			}
		} else {
			this._renderSurface = new Test.TestRenderSurface();
		}

		this._mainboard = new Nes.mainboard( this._renderSurface );
		this._mainboard.connect( 'reset', function() { that._onReset(); } );

		if ( this._options.createGuiComponents ) {
			this._ggDialog = new Gui.GameGenieDialog( this );
			this._controlBar = new Gui.ControlBar( this );
			this._controlBar.connect( 'romLoaded', function( name, binaryString ) { that._loadRomCallback( name, binaryString ); } );
			this._input = new Gui.Input( this._mainboard );
			this._keyboardRemapDialog = new Gui.KeyboardRemapper( this );
		}
		
		this._saveStateManager = new Gui.SaveStateManager( this, this._options.createGuiComponents );
		
		// var sde = $( ".spriteDisplay" );
		// if ( sde.length > 0 ) {
			// this._spriteDisplay = new Gui.SpriteDisplayWindow( this._mainboard, sde[0] );
		// }
		// var pde = $( ".paletteDisplay" );
		// if ( pde.length > 0 ) {
			// this._paletteDisplay = new Gui.PaletteDisplayWindow( this._mainboard, pde[0] );
		// }
		// var cpu = $( ".cpuInstructions" );
		// if ( cpu.length > 0 ) {
			// this._cpuInstructionsWindow = new Nes.CpuInstructionsWindow( this._mainboard, cpu[0] );
		// }
		// var log = $( ".logWindow" );
		// if ( log.length > 0  ) {
			// this._logWindow = new Nes.LogWindow( this._mainboard, log[0] );
		// }

		window.setFastTimeout( animateFunction );
		if ( this._options.loadUrl ) {
			this.loadRomFromUrl( this._options.loadUrl );
		}
		this._animate();
	};
	
	
	App.prototype.pause = function( isPaused ) {
	
		var changed = false;

		if ( isPaused ) {
			changed = this._isPaused === 0;
			this._isPaused = 1;
		} else {
			changed = this._isPaused === 1;
			this._isPaused = 0;
		}
	
		if ( changed ) {
			this._eventBus.invoke( 'isPausedChange', this.isPaused() );
		}
	};
	
	
	App.prototype.isPaused = function() {
		return this._isPaused > 0;
	};
	
	
	App.prototype._onReset = function() {
	
		this._calculateFrameTimeTarget();
	};
	
	
	App.prototype._calculateFrameTimeTarget = function() {
		if ( this._gameSpeed > 0 ) {
			var base = ( 100000 / this._gameSpeed ); // 100000 = 1000 * 100 ( 1000 milliseconds, multiplied by 100 as gameSpeed is a %)
			this._frameTimeTarget = ( base / COLOUR_ENCODING_REFRESHRATE );
		}
	};
	
	
	App.prototype.reset = function() {
		
		this._mainboard.reset();
	};
	
	
	App.prototype.playOneFrame = function() {
		this.pause( false );
		this._pauseNextFrame = true;
	};
		
	
	App.prototype.playUntilFrame = function( frameNum ) {
		this.pause( false );
		this._pauseOnFrame = frameNum;
	};
	
	
	App.prototype.enableSound = function( enable ) {
		this._mainboard.enableSound( enable );
	};
	
	
	App.prototype.soundEnabled = function() {
		return this._mainboard.apu.soundEnabled();
	};
	
	
	App.prototype.soundSupported = function() {
		return this._mainboard.apu.soundSupported();
	};
	
	
	App.prototype.setVolume = function( val ) {
		this._mainboard.setVolume( val );
	};
	
	
	App.prototype.setGameSpeed = function( gameSpeed ) {
		
		this._gameSpeed = gameSpeed;
		this._calculateFrameTimeTarget();
	};
	
	
	App.prototype.setTraceOption = function( traceType, checked ) {

		this._mainboard.setTraceOption( traceType, checked );
	};
	
	
	App.prototype._readyToRender = function() {
		if ( this._gameSpeed <= 0 ) {
			return true;
		}
		var now = performance ? performance.now() : Date.now(); // Date.now() in unsupported browsers
		var diff = now - this._lastFrameTime;
		if ( diff >= this._frameTimeTarget ) {
			this._lastFrameTime = now;
			return true;
		} else {
			return false;
		}
	};
	
	
	App.prototype.showFpsMeter = function( show ) {
		if ( show ) {
			this._fpsMeter.show();
		} else {
			this._fpsMeter.hide();
		}
	};
		
	
	App.prototype.startTrace = function() {
	
		this._eventBus.invoke( 'traceRunning', true );
		// if ( traceType === 'cpuInstructions' ) {
		this._mainboard.cpu.enableTrace( true );
		// }
		Nes.Trace.start();
	};
		
		
	App.prototype.stopTrace = function() {
		
		Nes.Trace.stop();
		this._mainboard.cpu.enableTrace( false );
		this._eventBus.invoke( 'traceRunning', false );
	};
			
	
	App.prototype.screenshot = function() {
	
		this._renderSurface.screenshotToFile();
	};
	
	
	App.prototype._animate = function() {
		
		var that = this;

		if ( this._newRomWaiting ) {
			this._doRomLoad( this._newRomLoaded.name, this._newRomLoaded.binaryString );
			this._newRomWaiting = false;
		}
		
		if ( this._romLoaded ) {
			this._romLoaded = false;
			this._mainboard.loadCartridge( this._cart );
			this._eventBus.invoke( 'cartLoaded', this._cart );
		}
		
		if ( this._encodingTypeToSet.length > 0 ) {
			setColourEncodingType( this._encodingTypeToSet );
			this._encodingTypeToSet = '';
		}

		if ( this._isPaused <= 0 ) {
			if ( this._readyToRender() ) {
			
				if ( this._input ) {
					this._input.poll();
				}
				
				var bgColour = this._mainboard.renderBuffer.pickColour( this._mainboard.ppu.getBackgroundPaletteIndex() );
				this._renderSurface.clearBuffers( bgColour );
				this._mainboard.renderBuffer.clearBuffer();
				
				this._mainboard.doFrame();
				this._renderSurface.render( this._mainboard );
				
				if ( this._options.triggerFrameRenderedEvent ) {
					this._eventBus.invoke( 'frameRendered', this._renderSurface, this._mainboard.ppu.frameCounter );
				}

				if ( this._fpsMeter ) {
					this._fpsMeter.tick();
				}
			}

			if ( this._pauseNextFrame ) {
				this._pauseNextFrame = false;
				this.pause( true );
			}
			
			if ( this._pauseOnFrame >= 0 && this._pauseOnFrame === this._mainboard.ppu.frameCounter ) {
				this._pauseOnFrame = -1;
				this.pause( true );
			}
		
			this._saveStateManager.onFrame();

			// Note: Use setImmediate polyfill instead of homemade message implementation, as it doesn't work on firefox
			setImmediate( animateFunction );
			//window.invokeFastTimeout();
		} else {
			setTimeout( animateFunction, 300 );
		}
	};
	
	
	App.prototype._doRomLoad = function( name, binaryString ) {
		var that = this;
		this._cart = new Nes.cartridge( this._mainboard );
		this._cart.loadRom( name, binaryString, function( err ) {
			if ( !err ) {
				that._romLoaded = true;
			} else {
				that._showError( err );
			}
		} );
	};
	
	
	App.prototype.loadRomFromUrl = function( url ) {
		
		var that = this;
		Nes.loadRomFromUrl( url, function( err, name, binary ) {
			if ( !err ) {
				that._loadRomCallback( name, binary );
			} else {
				that._showError( err );
			}
		} );
	};
	
	
	App.prototype._showError = function( err ) {
	
		console.log( err );
		var errorType = typeof err;
		var msg = '';
		if ( errorType === 'string' ) {
			msg = err;
		} else if ( errorType === 'object' ) {
			if ( err.message ) {
				msg = err.message;
			} else {
				msg = err.toString();
			}
		} else {
			msg = err.toString();
		}
		this._eventBus.invoke( 'romLoadFailure', msg );
	};
	
	
	App.prototype.gameGenieCode = function( code ) {
	
		Nes.processGameGenieCode( this._mainboard, code, true );
	};
	
	
	App.prototype.loadShaderFromUrl = function( url ) {
	
		if ( this._renderSurface.loadShaderFromUrl ) {
			this._renderSurface.loadShaderFromUrl( url );
		}
	};

	
	Gui.App = new App();

}());

	
animateFunction = function() {
	Gui.App._animate();
};

/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/


this.Gui = this.Gui || {};


(function(){
	"use strict";

	
	var SaveStateManager = function( app, createGuiComponents ) {

		this._app = app;
		this._mainboard = this._app._mainboard;
		this._renderSurface = this._app._renderSurface;
		
		this._loadPending = '';
		this._loadStatePending = false;
		this._saveStatePending = false;
		if ( createGuiComponents ) {
			this._lsDialog = new Gui.LoadStateDialog( app );
		}
	};
	

	SaveStateManager.prototype.quickSaveState = function() {
		this._saveStatePending = true;
	};
	
	
	SaveStateManager.prototype.quickLoadState = function() {
		this.loadState( 'quicksave' );
	};
	
	
	SaveStateManager.prototype.loadState = function( slotName ) {
		this._loadPending = slotName;
		this._loadStatePending = true;
	};
	

	SaveStateManager.prototype._doQuickSave = function() {
		// push back previous quicksaves by renaming them, pushing them back in the queue
		var hash = this._mainboard.cart.getHash();
		Gui.renameQuickSaveStates( "quicksave", hash, 3 );
		var screen = this._renderSurface.screenshotToString();
		var state = this._mainboard.saveState();
		Gui.saveState( "quicksave", hash, state, screen );
	};
	
	
	SaveStateManager.prototype._doQuickLoad = function() {
		var state = Gui.loadState( this._loadPending, this._mainboard.cart.getHash() );
		if ( state ) {
			this._mainboard.loadState( state );
		}
	};
	
	
	SaveStateManager.prototype.showLoadStateDialog = function() {
	
		var hash = this._mainboard.cart.getHash();
		var metaData = Gui.getStateMetaData( hash, true );
		this._lsDialog.show( hash, metaData );
	};
	
	
	SaveStateManager.prototype.onFrame = function() {
	
		var that = this;
		if ( this._mainboard.cart ) {
			if ( this._saveStatePending ) {
				this._saveStatePending = false;
				this._doQuickSave();
			} else if ( this._loadStatePending ) {
				this._loadStatePending = false;
				this._doQuickLoad();
			}
		}
	};
	
	
	Gui.SaveStateManager = SaveStateManager;

}());


/*
This file is part of WebNES.

WebNES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

WebNES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with WebNES.  If not, see <http://www.gnu.org/licenses/>.
*/

this.Gui = this.Gui || {};

function getParameterByName(name) {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results == null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}


window.onload = function() {
	let romValue;
	let shaderValue;

	// This allows a list box to be on the page to load a given nes file local to the site
	romValue = "roms/Super Mario Bros (E).nes.zip";
	console.log( "Loading ROM " + romValue );
	Gui.App.loadRomFromUrl( romValue );
	// var sel = $('#loadGameComboBox');
	// if ( sel ) {
	// 	sel['change'](function(){
	// 		var value = $(this)['val']();
	// 		if ( value.length > 0 ) {
	// 			console.log( "Loading ROM " + value );
	// 			Gui.App.loadRomFromUrl( value );
	// 		}
	// 	});
	// }
	
	// And this is the select box for selecting a WebGL shader
	shaderValue = "shaders/v1.0/CRT.xml";
	console.log( "Loading shader " + shaderValue );
	Gui.App.loadShaderFromUrl( shaderValue );
	// sel = $('#shaderListComboBox');
	// if ( sel ) {
	// 	sel['change'](function(){
	// 		var value = $(this)['val']();
	// 		if ( value.length > 0 ) {
	// 			console.log( "Loading shader " + value );
	// 			Gui.App.loadShaderFromUrl( value );
	// 		} else {
	// 			Gui.App.loadShaderFromUrl( null );
	// 		}
	// 	});
	// }
	
	var requestedGameToLoad = getParameterByName( 'gameUrl' );
	Gui.App.start( { createGuiComponents: true, loadUrl: requestedGameToLoad } );
};
